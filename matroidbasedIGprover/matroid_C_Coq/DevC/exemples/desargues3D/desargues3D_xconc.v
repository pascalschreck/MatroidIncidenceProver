Load "preamble3D.v".


(* dans la couche 0 *)
Lemma LOoAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoAp requis par la preuve de (?)OoAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HOoApm2 : rk(Oo :: Ap :: nil) >= 2).
{
	assert(HApBpDpMtmp : rk(Ap :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HApBpDpeq HApBpDpM3).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: nil) (Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Ap :: Bp :: Dp :: nil) ((Oo :: Ap :: nil) ++ (Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_2 (Oo :: Ap :: nil) (Ap :: Bp :: Dp :: nil) (Ap :: nil) 4 1 3 HOoApBpDpmtmp HApmtmp HApBpDpMtmp Hincl);apply HT.
}

assert(HOoApM : rk(Oo :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoApeq HOoApM2).
assert(HOoApm : rk(Oo :: Ap ::  nil) >= 1) by (solve_hyps_min HOoApeq HOoApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAAp *)
(* dans constructLemma(), requis par LABAp *)
(* dans constructLemma(), requis par LBAp *)
(* dans la couche 0 *)
Lemma LOoABCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApm4 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApM : rk(Oo :: A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApm : rk(Oo :: A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABCApeq HOoABCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBAp *)
(* dans la couche 0 *)
Lemma LBAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)BAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)BAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HBApm2 : rk(B :: Ap :: nil) >= 2).
{
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 3 HOoABCApmtmp HApmtmp HOoACApMtmp Hincl);apply HT.
}

assert(HBApM : rk(B :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBApeq HBApM2).
assert(HBApm : rk(B :: Ap ::  nil) >= 1) by (solve_hyps_min HBApeq HBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABAp *)
(* dans la couche 0 *)
Lemma LBCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCAp requis par la preuve de (?)BCAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApm3 : rk(B :: C :: Ap :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HBCApM : rk(B :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCApeq HBCApM3).
assert(HBCApm : rk(B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HBCApeq HBCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoACAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABAp requis par la preuve de (?)ABAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 5 et 5*)
assert(HABApm2 : rk(A :: B :: Ap :: nil) >= 2).
{
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (A :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (A :: B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Oo :: A :: C :: Ap :: nil) ((A :: B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApmtmp HAApmtmp HOoACApMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 4*)
assert(HABApm3 : rk(A :: B :: Ap :: nil) >= 3).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (A :: B :: Ap :: nil) (B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: nil) (A :: B :: Ap :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: B :: C :: Ap :: nil) ((A :: B :: Ap :: nil) ++ (B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApmtmp;try rewrite HT2 in HABCApmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: nil) (B :: C :: Ap :: nil) (B :: Ap :: nil) 4 2 3 HABCApmtmp HBApmtmp HBCApMtmp Hincl);apply HT.
}

assert(HABApM : rk(A :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABApeq HABApM3).
assert(HABApm : rk(A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HABApeq HABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)AAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HAApm2 : rk(A :: Ap :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (B :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: nil) (A :: Ap :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: Ap :: nil) ((A :: Ap :: nil) ++ (B :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApmtmp;try rewrite HT2 in HABApmtmp.
	assert(HT := rule_2 (A :: Ap :: nil) (B :: Ap :: nil) (Ap :: nil) 3 1 2 HABApmtmp HApmtmp HBApMtmp Hincl);apply HT.
}

assert(HAApM : rk(A :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAApeq HAApM2).
assert(HAApm : rk(A :: Ap ::  nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBAp *)
(* dans la couche 0 *)
Lemma LOoACAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

assert(HOoACApM : rk(Oo :: A :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApm : rk(Oo :: A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoACApeq HOoACApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBAp requis par la preuve de (?)OoBAp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBApm3 : rk(Oo :: B :: Ap :: nil) >= 3).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: Oo :: A :: C :: Ap :: nil) ((Oo :: B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (Oo :: B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApmtmp HOoApmtmp HOoACApMtmp Hincl);apply HT.
}

assert(HOoBApM : rk(Oo :: B :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBApeq HOoBApM3).
assert(HOoBApm : rk(Oo :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoBApeq HOoBApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABAp *)
(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)OoABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (B :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: Ap :: nil) ((B :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HBMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HCApMtmp Hincl);apply HT.
}

assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)CAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApm2 : rk(C :: Ap :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: nil) (Ap :: nil) 4 1 3 HOoABCApmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HCApM : rk(C :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCApeq HCApM2).
assert(HCApm : rk(C :: Ap ::  nil) >= 1) by (solve_hyps_min HCApeq HCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACAp requis par la preuve de (?)ACAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApm2 : rk(A :: C :: Ap :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 4 et 4*)
assert(HACApm3 : rk(A :: C :: Ap :: nil) >= 3).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApmtmp : rk(A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HABCApeq HABCApm4).
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (A :: C :: Ap :: nil) (B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: nil) (A :: C :: Ap :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: B :: C :: Ap :: nil) ((A :: C :: Ap :: nil) ++ (B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApmtmp;try rewrite HT2 in HABCApmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: nil) (B :: C :: Ap :: nil) (C :: Ap :: nil) 4 2 3 HABCApmtmp HCApmtmp HBCApMtmp Hincl);apply HT.
}

assert(HACApM : rk(A :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACApeq HACApM3).
assert(HACApm : rk(A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HACApeq HACApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBp *)
(* dans la couche 0 *)
Lemma LOoApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpm2 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm3 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCp requis par la preuve de (?)OoApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApCpm2 : rk(Oo :: Ap :: Cp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApCpeq HOoABApCpm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpmtmp;try rewrite HT2 in HOoABApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApCpmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -1 et -2*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HOoApCpm3 : rk(Oo :: Ap :: Cp :: nil) >= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Bp :: Oo :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: Ap :: Cp :: nil) ((Bp :: nil) ++ (Oo :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_4 (Bp :: nil) (Oo :: Ap :: Cp :: nil) (nil) 4 0 1 HOoApBpCpmtmp Hmtmp HBpMtmp Hincl); apply HT.
}

assert(HOoApCpM : rk(Oo :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApCpeq HOoApCpM3).
assert(HOoApCpm : rk(Oo :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoApCpeq HOoApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoBp requis par la preuve de (?)OoBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 4*)
assert(HOoBpm2 : rk(Oo :: Bp :: nil) >= 2).
{
	assert(HOoApCpeq : rk(Oo :: Ap :: Cp :: nil) = 3) by (apply LOoApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApCpMtmp : rk(Oo :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoApCpeq HOoApCpM3).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: Bp :: nil) (Oo :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: Oo :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Oo :: Ap :: Cp :: nil) ((Oo :: Bp :: nil) ++ (Oo :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_2 (Oo :: Bp :: nil) (Oo :: Ap :: Cp :: nil) (Oo :: nil) 4 1 3 HOoApBpCpmtmp HOomtmp HOoApCpMtmp Hincl);apply HT.
}

assert(HOoBpM : rk(Oo :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoBpeq HOoBpM2).
assert(HOoBpm : rk(Oo :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBpeq HOoBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABp *)
(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBp requis par la preuve de (?)ABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)BCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)OoABCApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCBp requis par la preuve de (?)BCBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpm2 : rk(B :: C :: Bp :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: nil) (nil) 4 0 2 HOoABCApBpmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	assert(HBCBpMtmp : rk(B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HBCBpeq HBCBpM3).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (A :: Bp :: nil) (B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: nil) (A :: Bp :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: B :: C :: Bp :: nil) ((A :: Bp :: nil) ++ (B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpmtmp;try rewrite HT2 in HABCBpmtmp.
	assert(HT := rule_2 (A :: Bp :: nil) (B :: C :: Bp :: nil) (Bp :: nil) 4 1 3 HABCBpmtmp HBpmtmp HBCBpMtmp Hincl);apply HT.
}

assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABp *)
(* dans la couche 0 *)
Lemma LOoABCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBp requis par la preuve de (?)OoABCBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpm4 : rk(Oo :: A :: B :: C :: Bp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpM : rk(Oo :: A :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpm : rk(Oo :: A :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABCBpeq HOoABCBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABp *)
(* dans constructLemma(), requis par LOoBCBp *)
(* dans la couche 0 *)
Lemma LOoABCApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)OoABCApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpM : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpm : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBCBpM3 : rk(Oo :: B :: C :: Bp :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: nil) (C :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Bp :: nil) ((C :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HCMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 1 et 2 *)
assert(HOoBCBpm2 : rk(Oo :: B :: C :: Bp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil) (nil) 4 0 2 HOoABCApBpmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpm3 : rk(Oo :: B :: C :: Bp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil) (Oo :: nil) 4 1 2 HOoABCApBpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCBpM : rk(Oo :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpm : rk(Oo :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBCBpeq HOoBCBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoABp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBp requis par la preuve de (?)OoABBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABBpM3 : rk(Oo :: A :: B :: Bp :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (A :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: B :: Bp :: nil) ((A :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HAMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpm2 : rk(Oo :: A :: B :: Bp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: nil) (nil) 4 0 2 HOoABCApBpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABp requis par la preuve de (?)OoABp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABpm2 : rk(Oo :: A :: Bp :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpmtmp : rk(Oo :: A :: B :: Bp :: nil) >= 2) by (solve_hyps_min HOoABBpeq HOoABBpm2).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: Bp :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: nil) (Oo :: A :: Bp :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Oo :: B :: Bp :: nil) ((Oo :: A :: Bp :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpmtmp;try rewrite HT2 in HOoABBpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: nil) (Oo :: B :: Bp :: nil) (Oo :: Bp :: nil) 2 2 2 HOoABBpmtmp HOoBpmtmp HOoBBpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpm3 : rk(Oo :: A :: Bp :: nil) >= 3).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpeq : rk(Oo :: A :: B :: C :: Bp :: nil) = 4) by (apply LOoABCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpmtmp : rk(Oo :: A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCBpeq HOoABCBpm4).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: A :: Bp :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: nil) (Oo :: A :: Bp :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Oo :: B :: C :: Bp :: nil) ((Oo :: A :: Bp :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpmtmp;try rewrite HT2 in HOoABCBpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: nil) (Oo :: B :: C :: Bp :: nil) (Oo :: Bp :: nil) 4 2 3 HOoABCBpmtmp HOoBpmtmp HOoBCBpMtmp Hincl);apply HT.
}

assert(HOoABpM : rk(Oo :: A :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoABpeq HOoABpM3).
assert(HOoABpm : rk(Oo :: A :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABpeq HOoABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBp *)
(* dans la couche 0 *)
Lemma LBBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBp requis par la preuve de (?)BBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACBp requis par la preuve de (?)ACBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACBpm2 : rk(A :: C :: Bp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: A :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Bp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Bp :: nil) (A :: nil) 4 1 3 HOoABCApBpmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BBp requis par la preuve de (?)BBp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HBBpm2 : rk(B :: Bp :: nil) >= 2).
{
	assert(HACBpMtmp : rk(A :: C :: Bp :: nil) <= 3) by (solve_hyps_max HACBpeq HACBpM3).
	assert(HABCBpmtmp : rk(A :: B :: C :: Bp :: nil) >= 4) by (solve_hyps_min HABCBpeq HABCBpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (A :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Bp :: nil) (B :: Bp :: A :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: A :: C :: Bp :: nil) ((B :: Bp :: nil) ++ (A :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCBpmtmp;try rewrite HT2 in HABCBpmtmp.
	assert(HT := rule_2 (B :: Bp :: nil) (A :: C :: Bp :: nil) (Bp :: nil) 4 1 3 HABCBpmtmp HBpmtmp HACBpMtmp Hincl);apply HT.
}

assert(HBBpM : rk(B :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBBpeq HBBpM2).
assert(HBBpm : rk(B :: Bp ::  nil) >= 1) by (solve_hyps_min HBBpeq HBBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBp *)
(* dans la couche 0 *)
Lemma LOoBApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBApBp requis par la preuve de (?)OoBApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBApBp requis par la preuve de (?)OoBApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBp requis par la preuve de (?)OoBApBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBApBpM3 : rk(Oo :: B :: Ap :: Bp :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: nil) (Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Oo :: B :: Bp :: nil) ((Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HApMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpm2 : rk(Oo :: B :: Ap :: Bp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpm3 : rk(Oo :: B :: Ap :: Bp :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

assert(HOoBApBpM : rk(Oo :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpm : rk(Oo :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBApBpeq HOoBApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApBp requis par la preuve de (?)ApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpm2 : rk(Ap :: Bp :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpeq : rk(Oo :: B :: Ap :: Bp :: nil) = 3) by (apply LOoBApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApBpmtmp : rk(Oo :: B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HOoBApBpeq HOoBApBpm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpmtmp;try rewrite HT2 in HOoBApBpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: nil) (Bp :: nil) 3 1 2 HOoBApBpmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABApBpM3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoBBpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpm2 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpm3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBp requis par la preuve de (?)OoApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApBpm2 : rk(Oo :: Ap :: Bp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HOoABApBpeq HOoABApBpm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpmtmp;try rewrite HT2 in HOoABApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApBpmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoApBpm3 : rk(Oo :: Ap :: Bp :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpeq : rk(Oo :: B :: Ap :: Bp :: nil) = 3) by (apply LOoBApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApBpmtmp : rk(Oo :: B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HOoBApBpeq HOoBApBpm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: nil) (Oo :: B :: Bp :: Oo :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Ap :: Bp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpmtmp;try rewrite HT2 in HOoBApBpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBApBpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HOoApBpM : rk(Oo :: Ap :: Bp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApBpeq HOoApBpM3).
assert(HOoApBpm : rk(Oo :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoApBpeq HOoApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABApBpM3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoBBpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpm2 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpm3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApBpM : rk(Oo :: A :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpm : rk(Oo :: A :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABApBpeq HOoABApBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBp *)
(* dans constructLemma(), requis par LOoACApBpCp *)
(* dans la couche 0 *)
Lemma LOoABCApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCp requis par la preuve de (?)OoABCApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACApBpCpm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Oo :: Bp :: nil) 4 2 2 HOoABCApBpCpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpM : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpm : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBp *)
(* dans constructLemma(), requis par LOoACApCp *)
(* dans la couche 0 *)
Lemma LOoABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCp requis par la preuve de (?)OoABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpM : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpm : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoACApCpM3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: C :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoCCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApCpm2 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApCpm3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (Ap :: nil) 4 1 2 HOoABCApCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

assert(HOoACApCpM : rk(Oo :: A :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApCpm : rk(Oo :: A :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApCpeq HOoACApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBp requis par la preuve de (?)ACApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApBpm2 : rk(A :: C :: Ap :: Bp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApBpmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpm3 : rk(A :: C :: Ap :: Bp :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACApBpm4 : rk(A :: C :: Ap :: Bp :: nil) >= 4).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm4).
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hincl : incl (A :: C :: Ap :: nil) (list_inter (A :: C :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: C :: Ap :: Bp :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Bp :: Oo :: A :: C :: Ap :: Cp :: nil) ((A :: C :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (A :: C :: Ap :: nil) 4 3 3 HOoACApBpCpmtmp HACApmtmp HOoACApCpMtmp Hincl);apply HT.
}

assert(HACApBpM : rk(A :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpm : rk(A :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HACApBpeq HACApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoCp requis par la preuve de (?)OoCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -1 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoCpm2 : rk(Oo :: Cp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Oo :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Ap :: Bp :: Oo :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Oo :: Cp :: nil) ((Ap :: Bp :: nil) ++ (Oo :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Oo :: Cp :: nil) (nil) 4 0 2 HOoApBpCpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}

assert(HOoCpM : rk(Oo :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoCpeq HOoCpM2).
assert(HOoCpm : rk(Oo :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCpeq HOoCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans la couche 0 *)
Lemma LABCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm3 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApCpmtmp : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABCApCpeq HABCApCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: nil) (C :: Ap :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: Cp :: nil) ((C :: Ap :: nil) ++ (A :: B :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpmtmp;try rewrite HT2 in HABCApCpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: Cp :: nil) (nil) 4 0 2 HABCApCpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HABCpm3 : rk(A :: B :: Cp :: nil) >= 3).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HABCCpeq HABCCpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: nil) (A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpmtmp;try rewrite HT2 in HABCCpmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 2 HABCCpmtmp HCpmtmp HCCpMtmp Hincl);apply HT.
}

assert(HABCpM : rk(A :: B :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCpeq HABCpM3).
assert(HABCpm : rk(A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HABCpeq HABCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABCp *)
(* dans la couche 0 *)
Lemma LOoABCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCp requis par la preuve de (?)OoABCCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpm4 : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpM : rk(Oo :: A :: B :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpm : rk(Oo :: A :: B :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCCpeq HOoABCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 2 pour CCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)CCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HCCpm2 : rk(C :: Cp :: nil) >= 2).
{
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpMtmp : rk(A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HABCpeq HABCpM3).
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HABCCpeq HABCCpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: nil) (A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpmtmp;try rewrite HT2 in HABCCpmtmp.
	assert(HT := rule_4 (A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 3 HABCCpmtmp HCpmtmp HABCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCp requis par la preuve de (?)OoABCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABCpm2 : rk(Oo :: A :: B :: Cp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (C :: Ap :: Oo :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Cp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Cp :: nil) (nil) 4 0 2 HOoABCApCpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 5*)
assert(HOoABCpm3 : rk(Oo :: A :: B :: Cp :: nil) >= 3).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 4) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpmtmp : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCCpeq HOoABCCpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: nil) (Oo :: A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: C :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpmtmp;try rewrite HT2 in HOoABCCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 2 HOoABCCpmtmp HCpmtmp HCCpMtmp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoABCpm4 : rk(Oo :: A :: B :: Cp :: nil) >= 4).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 4) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpmtmp : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCCpeq HOoABCCpm4).
	assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: nil) (Oo :: A :: B :: Cp :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Cp :: Oo :: C :: Cp :: nil) ((Oo :: A :: B :: Cp :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpmtmp;try rewrite HT2 in HOoABCCpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil) (Oo :: Cp :: nil) 4 2 2 HOoABCCpmtmp HOoCpmtmp HOoCCpMtmp Hincl);apply HT.
}

assert(HOoABCpM : rk(Oo :: A :: B :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpm : rk(Oo :: A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCpeq HOoABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CCp requis par la preuve de (?)CCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Cp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: B :: Cp ::   de rang : 3 et 3 *)
assert(HCCpm2 : rk(C :: Cp :: nil) >= 2).
{
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpMtmp : rk(A :: B :: Cp :: nil) <= 3) by (solve_hyps_max HABCpeq HABCpM3).
	assert(HABCCpmtmp : rk(A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HABCCpeq HABCCpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Cp :: nil) (A :: B :: Cp :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCCpmtmp;try rewrite HT2 in HABCCpmtmp.
	assert(HT := rule_4 (A :: B :: Cp :: nil) (C :: Cp :: nil) (Cp :: nil) 4 1 3 HABCCpmtmp HCpmtmp HABCpMtmp Hincl); apply HT.
}

assert(HCCpM : rk(C :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCCpeq HCCpM2).
assert(HCCpm : rk(C :: Cp ::  nil) >= 1) by (solve_hyps_min HCCpeq HCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApCp requis par la preuve de (?)ApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HApCpm2 : rk(Ap :: Cp :: nil) >= 2).
{
	assert(HOoApBpeq : rk(Oo :: Ap :: Bp :: nil) = 3) by (apply LOoApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpMtmp : rk(Oo :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoApBpeq HOoApBpM3).
	assert(HOoApBpCpmtmp : rk(Oo :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoApBpCpeq HOoApBpCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: Ap :: Bp :: nil) (Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Cp :: nil) (Oo :: Ap :: Bp :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: Ap :: Cp :: nil) ((Oo :: Ap :: Bp :: nil) ++ (Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpCpmtmp;try rewrite HT2 in HOoApBpCpmtmp.
	assert(HT := rule_4 (Oo :: Ap :: Bp :: nil) (Ap :: Cp :: nil) (Ap :: nil) 4 1 3 HOoApBpCpmtmp HApmtmp HOoApBpMtmp Hincl); apply HT.
}

assert(HApCpM : rk(Ap :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApCpeq HApCpM2).
assert(HApCpm : rk(Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HApCpeq HApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApCp *)
(* dans la couche 0 *)
Lemma LOoABApCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 4) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCpmtmp : rk(Oo :: A :: B :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCpeq HOoABCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 4 4 HOoABCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabM : rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabm : rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApCp *)
(* dans la couche 0 *)
Lemma LOoABApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABApabM3 : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: nil) (Oo :: A :: Ap :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil) (A :: nil) 2 2 1 HOoAApMtmp HABabMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabm2 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabm3 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApabM : rk(Oo :: A :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabm : rk(Oo :: A :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoABApabeq HOoABApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCp requis par la preuve de (?)ABApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpm2 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpm3 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpm3 : rk(A :: B :: Ap :: Cp :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApCpeq HOoABApCpm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpmtmp;try rewrite HT2 in HOoABApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABApCpm4 : rk(A :: B :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoABApabeq : rk(Oo :: A :: B :: Ap :: ab :: nil) = 3) by (apply LOoABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabMtmp : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoABApabeq HOoABApabM3).
	assert(HOoABApCpabeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) = 4) by (apply LOoABApCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: nil) (A :: B :: Ap :: Cp :: Oo :: A :: B :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: Oo :: A :: B :: Ap :: ab :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (Oo :: A :: B :: Ap :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabmtmp;try rewrite HT2 in HOoABApCpabmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: ab :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABApCpabmtmp HABApmtmp HOoABApabMtmp Hincl);apply HT.
}

assert(HABApCpM : rk(A :: B :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpm : rk(A :: B :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABApCpeq HABApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm3 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApCpM : rk(A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpm : rk(A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABCApCpeq HABCApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpCp *)
(* dans la couche 0 *)
Lemma LOoABBpCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpab requis par la preuve de (?)OoABCApBpCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpCpab requis par la preuve de (?)OoABBpCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpCpabm2 : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpCpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Cp :: ab :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabmtmp;try rewrite HT2 in HOoABCApBpCpabmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil) (nil) 4 0 2 HOoABCApBpCpabmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpabm3 : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpCpabm4 : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCpeq : rk(Oo :: A :: B :: Cp :: nil) = 4) by (apply LOoABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCpmtmp : rk(Oo :: A :: B :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCpeq HOoABCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Cp :: nil) (Oo :: A :: B :: Bp :: Cp :: ab :: nil) 4 4 HOoABCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABBpCpabM : rk(Oo :: A :: B :: Bp :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpCpabm : rk(Oo :: A :: B :: Bp :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABBpCpabeq HOoABBpCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpCp *)
(* dans la couche 0 *)
Lemma LOoABBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpab requis par la preuve de (?)OoABBpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpab requis par la preuve de (?)OoABBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpab requis par la preuve de (?)OoABBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpabm2 : rk(Oo :: A :: B :: Bp :: ab :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ab :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ab :: nil) (nil) 4 0 2 HOoABCApBpabmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpabm3 : rk(Oo :: A :: B :: Bp :: ab :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ab :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABBpabM3 : rk(Oo :: A :: B :: Bp :: ab :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: Bp :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ab :: nil) (Oo :: B :: Bp :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: A :: B :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (A :: B :: ab :: nil) (B :: nil) 2 2 1 HOoBBpMtmp HABabMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoABBpabM : rk(Oo :: A :: B :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpabm : rk(Oo :: A :: B :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABBpabeq HOoABBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpCp requis par la preuve de (?)BBpCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpCp requis par la preuve de (?)BBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCp requis par la preuve de (?)OoBBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBCApBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCp requis par la preuve de (?)OoBBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpCpm2 : rk(Oo :: B :: Bp :: Cp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpCpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoBCApBpCpeq HOoBCApBpCpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (C :: Ap :: Oo :: B :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: Cp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpmtmp;try rewrite HT2 in HOoBCApBpCpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: Cp :: nil) (nil) 4 0 2 HOoBCApBpCpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpCpM3 : rk(Oo :: B :: Bp :: Cp :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Cp :: nil) (nil) 2 1 0 HOoBBpMtmp HCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpCp requis par la preuve de (?)BBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Cp ::  de rang :  2 et 3 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBBpCpm2 : rk(B :: Bp :: Cp :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpCpmtmp : rk(Oo :: B :: Bp :: Cp :: nil) >= 2) by (solve_hyps_min HOoBBpCpeq HOoBBpCpm2).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: nil) (Oo :: B :: Bp :: B :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: Bp :: Cp :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpmtmp;try rewrite HT2 in HOoBBpCpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: Bp :: Cp :: nil) (B :: Bp :: nil) 2 2 2 HOoBBpCpmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBBpCpm3 : rk(B :: Bp :: Cp :: nil) >= 3).
{
	assert(HOoABBpabeq : rk(Oo :: A :: B :: Bp :: ab :: nil) = 3) by (apply LOoABBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpabMtmp : rk(Oo :: A :: B :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoABBpabeq HOoABBpabM3).
	assert(HOoABBpCpabeq : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoABBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpCpabmtmp : rk(Oo :: A :: B :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABBpCpabeq HOoABBpCpabm4).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (B :: Bp :: Cp :: nil) (Oo :: A :: B :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Cp :: ab :: nil) (B :: Bp :: Cp :: Oo :: A :: B :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Cp :: Oo :: A :: B :: Bp :: ab :: nil) ((B :: Bp :: Cp :: nil) ++ (Oo :: A :: B :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpCpabmtmp;try rewrite HT2 in HOoABBpCpabmtmp.
	assert(HT := rule_2 (B :: Bp :: Cp :: nil) (Oo :: A :: B :: Bp :: ab :: nil) (B :: Bp :: nil) 4 2 3 HOoABBpCpabmtmp HBBpmtmp HOoABBpabMtmp Hincl);apply HT.
}

assert(HBBpCpM : rk(B :: Bp :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBBpCpeq HBBpCpM3).
assert(HBBpCpm : rk(B :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HBBpCpeq HBBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCp requis par la preuve de (?)OoBCApBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpCpM : rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpCpm : rk(Oo :: B :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoBCApBpCpeq HOoBCApBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAab *)
(* dans la couche 0 *)
Lemma LACApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpab requis par la preuve de (?)ACApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpab requis par la preuve de (?)ACApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)ACApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpab requis par la preuve de (?)ACApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApBpabm2 : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApBpabmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpabm3 : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: Bp :: ab :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApBpabm4 : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	assert(HACApBpeq : rk(A :: C :: Ap :: Bp :: nil) = 4) by (apply LACApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApBpmtmp : rk(A :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HACApBpeq HACApBpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: ab :: nil) 4 4 HACApBpmtmp Hcomp Hincl);apply HT.
}

assert(HACApBpabM : rk(A :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpabm : rk(A :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HACApBpabeq HACApBpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAab *)
(* dans constructLemma(), requis par LCApBpab *)
(* dans constructLemma(), requis par LOoBCApBpab *)
(* dans la couche 0 *)
Lemma LOoABCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpab requis par la preuve de (?)OoBCApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabm4 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoABCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpabmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpabM : rk(Oo :: B :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpabm : rk(Oo :: B :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoBCApBpabeq HOoBCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApBpab requis par la preuve de (?)BCApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApBpabm3 : rk(B :: C :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoABCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Bp :: ab :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCApBpabM3 : rk(C :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: ab :: nil) (C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: nil) ((C :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HCMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Bp :: ab ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApBpabm2 : rk(C :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApBpabmtmp : rk(B :: C :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HBCApBpabeq HBCApBpabm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: ab :: nil) (B :: Ap :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: Bp :: ab :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpabmtmp;try rewrite HT2 in HBCApBpabmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: Bp :: ab :: nil) (Ap :: nil) 3 1 2 HBCApBpabmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCApBpabm3 : rk(C :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCApBpabeq : rk(Oo :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoBCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApBpabmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoBCApBpabeq HOoBCApBpabm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabmtmp;try rewrite HT2 in HOoBCApBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Ap :: Bp :: ab :: nil) (Bp :: nil) 4 1 2 HOoBCApBpabmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HCApBpabM : rk(C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpabm : rk(C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HCApBpabeq HCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aab requis par la preuve de (?)Aab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et 4*)
assert(HAabm2 : rk(A :: ab :: nil) >= 2).
{
	assert(HCApBpabeq : rk(C :: Ap :: Bp :: ab :: nil) = 3) by (apply LCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApBpabMtmp : rk(C :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HCApBpabeq HCApBpabM3).
	assert(HACApBpabeq : rk(A :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LACApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApBpabmtmp : rk(A :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HACApBpabeq HACApBpabm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: ab :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: ab :: nil) (A :: ab :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: C :: Ap :: Bp :: ab :: nil) ((A :: ab :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpabmtmp;try rewrite HT2 in HACApBpabmtmp.
	assert(HT := rule_2 (A :: ab :: nil) (C :: Ap :: Bp :: ab :: nil) (ab :: nil) 4 1 3 HACApBpabmtmp Habmtmp HCApBpabMtmp Hincl);apply HT.
}

assert(HAabM : rk(A :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAabeq HAabM2).
assert(HAabm : rk(A :: ab ::  nil) >= 1) by (solve_hyps_min HAabeq HAabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBab *)
(* dans constructLemma(), requis par LBApBpab *)
(* dans la couche 0 *)
Lemma LOoBApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpab requis par la preuve de (?)OoBApBpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoBApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpab requis par la preuve de (?)OoBApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabm3 : rk(Oo :: B :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoABApBpabeq HOoABApBpabm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabmtmp;try rewrite HT2 in HOoABApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoBApBpabM3 : rk(Oo :: B :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: nil) (Bp :: nil) 2 2 1 HOoBBpMtmp HApBpabMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBApBpabM : rk(Oo :: B :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpabm : rk(Oo :: B :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoBApBpabeq HOoBApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBApBpabM3 : rk(B :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Bp :: ab :: nil) ((B :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HBMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApBpabm2 : rk(B :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBApBpabm3 : rk(B :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpabeq : rk(Oo :: B :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApBpabmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoBApBpabeq HOoBApBpabm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabmtmp;try rewrite HT2 in HOoBApBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil) (B :: Bp :: nil) 3 2 2 HOoBApBpabmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HBApBpabM : rk(B :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpabm : rk(B :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HBApBpabeq HBApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bab requis par la preuve de (?)Bab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBabm2 : rk(B :: ab :: nil) >= 2).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBApBpabeq : rk(B :: Ap :: Bp :: ab :: nil) = 3) by (apply LBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApBpabmtmp : rk(B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HBApBpabeq HBApBpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (B :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: Ap :: Bp :: ab :: nil) ((B :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpabmtmp;try rewrite HT2 in HBApBpabmtmp.
	assert(HT := rule_2 (B :: ab :: nil) (Ap :: Bp :: ab :: nil) (ab :: nil) 3 1 2 HBApBpabmtmp Habmtmp HApBpabMtmp Hincl);apply HT.
}

assert(HBabM : rk(B :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBabeq HBabM2).
assert(HBabm : rk(B :: ab ::  nil) >= 1) by (solve_hyps_min HBabeq HBabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApab *)
(* dans la couche 0 *)
Lemma LABApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABApab requis par la preuve de (?)ABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABApab requis par la preuve de (?)ABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApab requis par la preuve de (?)ABApab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABApabM3 : rk(A :: B :: Ap :: ab :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: nil) (Ap :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: ab :: nil) ((Ap :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HApMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabm2 : rk(A :: B :: Ap :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (A :: B :: Ap :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabm3 : rk(A :: B :: Ap :: ab :: nil) >= 3).
{
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HABApabM : rk(A :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabm : rk(A :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HABApabeq HABApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apab requis par la preuve de (?)Apab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab ::  de rang :  3 et 3 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabm2 : rk(Ap :: ab :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabeq : rk(A :: B :: Ap :: ab :: nil) = 3) by (apply LABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApabmtmp : rk(A :: B :: Ap :: ab :: nil) >= 3) by (solve_hyps_min HABApabeq HABApabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: nil) (A :: B :: ab :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabmtmp;try rewrite HT2 in HABApabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: nil) (ab :: nil) 3 1 2 HABApabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

assert(HApabM : rk(Ap :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApabeq HApabM2).
assert(HApabm : rk(Ap :: ab ::  nil) >= 1) by (solve_hyps_min HApabeq HApabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApab *)
(* dans la couche 0 *)
Lemma LOoApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpab requis par la preuve de (?)OoABApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoApBpabM3 : rk(Oo :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: ab :: nil) ((Oo :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HOoMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApBpabm2 : rk(Oo :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoABApBpabeq HOoABApBpabm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Bp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabmtmp;try rewrite HT2 in HOoABApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApBpabmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoApBpabm3 : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpabeq : rk(Oo :: B :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApBpabmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoBApBpabeq HOoBApBpabm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: nil) (Oo :: B :: Bp :: Oo :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Ap :: Bp :: ab :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabmtmp;try rewrite HT2 in HOoBApBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBApBpabmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HOoApBpabM : rk(Oo :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpabm : rk(Oo :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoApBpabeq HOoApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApab requis par la preuve de (?)OoApab pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApab requis par la preuve de (?)OoApab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab ::  de rang :  3 et 3 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApabm2 : rk(Oo :: Ap :: ab :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabeq : rk(Oo :: A :: B :: Ap :: ab :: nil) = 3) by (apply LOoABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabmtmp : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 3) by (solve_hyps_min HOoABApabeq HOoABApabm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabmtmp;try rewrite HT2 in HOoABApabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApabmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoApabm3 : rk(Oo :: Ap :: ab :: nil) >= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(HApabeq : rk(Ap :: ab :: nil) = 2) by (apply LApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabmtmp : rk(Ap :: ab :: nil) >= 2) by (solve_hyps_min HApabeq HApabm2).
	assert(Hincl : incl (Ap :: ab :: nil) (list_inter (Oo :: Ap :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: ab :: Ap :: Bp :: ab :: nil) ((Oo :: Ap :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpabmtmp;try rewrite HT2 in HOoApBpabmtmp.
	assert(HT := rule_2 (Oo :: Ap :: ab :: nil) (Ap :: Bp :: ab :: nil) (Ap :: ab :: nil) 3 2 2 HOoApBpabmtmp HApabmtmp HApBpabMtmp Hincl);apply HT.
}

assert(HOoApabM : rk(Oo :: Ap :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApabeq HOoApabM3).
assert(HOoApabm : rk(Oo :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoApabeq HOoApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpab requis par la preuve de (?)OoABCApBpCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpabM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAac *)
(* dans constructLemma(), requis par LAApCpac *)
(* dans la couche 0 *)
Lemma LABApCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabac requis par la preuve de (?)ABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)ABApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabacm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabac requis par la preuve de (?)ABApCpabac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ac ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabacm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabacmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3) by (solve_hyps_min HOoABApCpabaceq HOoABApCpabacm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabacmtmp;try rewrite HT2 in HOoABApCpabacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabacmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabacM : rk(A :: B :: Ap :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabacm : rk(A :: B :: Ap :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HABApCpabaceq HABApCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)AApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacm3 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpacm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpacmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApCpacM3 : rk(A :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Cp :: ac :: nil) ((A :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HAMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApCpacm2 : rk(A :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApCpacmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HABCApCpaceq HABCApCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: nil) (B :: C :: Ap :: A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Cp :: ac :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacmtmp;try rewrite HT2 in HABCApCpacmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil) (Ap :: nil) 4 1 3 HABCApCpacmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpacm3 : rk(A :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabaceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) = 4) by (apply LABApCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpabacmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HABApCpabaceq HABApCpabacm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: nil) (A :: B :: ab :: A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Cp :: ac :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacmtmp;try rewrite HT2 in HABApCpabacmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Cp :: ac :: nil) (A :: nil) 4 1 2 HABApCpabacmtmp HAmtmp HABabMtmp Hincl); apply HT.
}

assert(HAApCpacM : rk(A :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpacm : rk(A :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HAApCpaceq HAApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aac requis par la preuve de (?)Aac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAacm2 : rk(A :: ac :: nil) >= 2).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HAApCpaceq : rk(A :: Ap :: Cp :: ac :: nil) = 3) by (apply LAApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpacmtmp : rk(A :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HAApCpaceq HAApCpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: Ap :: Cp :: ac :: nil) ((A :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpacmtmp;try rewrite HT2 in HAApCpacmtmp.
	assert(HT := rule_2 (A :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HAApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HAacM : rk(A :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAaceq HAacM2).
assert(HAacm : rk(A :: ac ::  nil) >= 1) by (solve_hyps_min HAaceq HAacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCac *)
(* dans constructLemma(), requis par LCApCpac *)
(* dans la couche 0 *)
Lemma LOoCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpac requis par la preuve de (?)OoCApCpac pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpac requis par la preuve de (?)OoCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacm3 : rk(Oo :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoCApCpacM3 : rk(Oo :: C :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: nil) (Cp :: nil) 2 2 1 HOoCCpMtmp HApCpacMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoCApCpacM : rk(Oo :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpacm : rk(Oo :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoCApCpaceq HOoCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacm3 : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCApCpacM3 : rk(C :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Cp :: ac :: nil) ((C :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HCMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApCpacm2 : rk(C :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApCpacmtmp : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HBCApCpaceq HBCApCpacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: nil) (B :: Ap :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacmtmp;try rewrite HT2 in HBCApCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 3 1 2 HBCApCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac ::  de rang :  3 et 3 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HCApCpacm3 : rk(C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpaceq : rk(Oo :: C :: Ap :: Cp :: ac :: nil) = 3) by (apply LOoCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApCpacmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoCApCpaceq HOoCApCpacm3).
	assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: C :: Cp :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: C :: Ap :: Cp :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacmtmp;try rewrite HT2 in HOoCApCpacmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil) (C :: Cp :: nil) 3 2 2 HOoCApCpacmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HCApCpacM : rk(C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApCpacm : rk(C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HCApCpaceq HCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cac requis par la preuve de (?)Cac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCacm2 : rk(C :: ac :: nil) >= 2).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HCApCpaceq : rk(C :: Ap :: Cp :: ac :: nil) = 3) by (apply LCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApCpacmtmp : rk(C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HCApCpaceq HCApCpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (C :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: Ap :: Cp :: ac :: nil) ((C :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApCpacmtmp;try rewrite HT2 in HCApCpacmtmp.
	assert(HT := rule_2 (C :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HCApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HCacM : rk(C :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCaceq HCacM2).
assert(HCacm : rk(C :: ac ::  nil) >= 1) by (solve_hyps_min HCaceq HCacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApac *)
(* dans la couche 0 *)
Lemma LACApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApac requis par la preuve de (?)ACApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApac requis par la preuve de (?)ACApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApac requis par la preuve de (?)ABCApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApac requis par la preuve de (?)ABCApac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacm3 : rk(A :: B :: C :: Ap :: ac :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApaceq HOoABCApacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacmtmp;try rewrite HT2 in HOoABCApacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApac requis par la preuve de (?)ACApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApac requis par la preuve de (?)ACApac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACApacM3 : rk(A :: C :: Ap :: ac :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: nil) (Ap :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: ac :: nil) ((Ap :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HApMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacm2 : rk(A :: C :: Ap :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacmtmp : rk(A :: B :: C :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HABCApaceq HABCApacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: nil) (B :: Ap :: A :: C :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacmtmp;try rewrite HT2 in HABCApacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: nil) (Ap :: nil) 3 1 2 HABCApacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacm3 : rk(A :: C :: Ap :: ac :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

assert(HACApacM : rk(A :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacm : rk(A :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HACApaceq HACApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apac requis par la preuve de (?)Apac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac ::  de rang :  3 et 3 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacm2 : rk(Ap :: ac :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApaceq : rk(A :: C :: Ap :: ac :: nil) = 3) by (apply LACApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApacmtmp : rk(A :: C :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HACApaceq HACApacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: nil) (A :: C :: ac :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacmtmp;try rewrite HT2 in HACApacmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: nil) (ac :: nil) 3 1 2 HACApacmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

assert(HApacM : rk(Ap :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApaceq HApacM2).
assert(HApacm : rk(Ap :: ac ::  nil) >= 1) by (solve_hyps_min HApaceq HApacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApac *)
(* dans la couche 0 *)
Lemma LOoApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpac requis par la preuve de (?)OoApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpac requis par la preuve de (?)OoABApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpac requis par la preuve de (?)OoABApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpacm2 : rk(Oo :: A :: B :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpacm3 : rk(Oo :: A :: B :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoApCpacM3 : rk(Oo :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: ac :: nil) ((Oo :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HOoMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApCpacm2 : rk(Oo :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpacmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoABApCpaceq HOoABApCpacm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpacmtmp;try rewrite HT2 in HOoABApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApCpacmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac ::  de rang :  3 et 3 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoApCpacm3 : rk(Oo :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpaceq : rk(Oo :: C :: Ap :: Cp :: ac :: nil) = 3) by (apply LOoCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApCpacmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoCApCpaceq HOoCApCpacm3).
	assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: nil) (Oo :: C :: Cp :: Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: Ap :: Cp :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacmtmp;try rewrite HT2 in HOoCApCpacmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Cp :: nil) 3 2 2 HOoCApCpacmtmp HOoCpmtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HOoApCpacM : rk(Oo :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpacm : rk(Oo :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoApCpaceq HOoApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApac requis par la preuve de (?)OoApac pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacm2 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacm3 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApac requis par la preuve de (?)OoApac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApacm2 : rk(Oo :: Ap :: ac :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacmtmp : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoABApaceq HOoABApacm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacmtmp;try rewrite HT2 in HOoABApacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApacmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoApacm3 : rk(Oo :: Ap :: ac :: nil) >= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HOoApCpaceq : rk(Oo :: Ap :: Cp :: ac :: nil) = 3) by (apply LOoApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApCpacmtmp : rk(Oo :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoApCpaceq HOoApCpacm3).
	assert(HApaceq : rk(Ap :: ac :: nil) = 2) by (apply LApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacmtmp : rk(Ap :: ac :: nil) >= 2) by (solve_hyps_min HApaceq HApacm2).
	assert(Hincl : incl (Ap :: ac :: nil) (list_inter (Oo :: Ap :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: ac :: Ap :: Cp :: ac :: nil) ((Oo :: Ap :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpacmtmp;try rewrite HT2 in HOoApCpacmtmp.
	assert(HT := rule_2 (Oo :: Ap :: ac :: nil) (Ap :: Cp :: ac :: nil) (Ap :: ac :: nil) 3 2 2 HOoApCpacmtmp HApacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HOoApacM : rk(Oo :: Ap :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApaceq HOoApacM3).
assert(HOoApacm : rk(Oo :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoApaceq HOoApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacM : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacm : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApaceq HOoABCApacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApCpac *)
(* dans la couche 0 *)
Lemma LOoABCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpac requis par la preuve de (?)ABCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacm3 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpaceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) = 4) by (apply LOoABCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpacm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpaceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) = 4) by (apply LOoABCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpacmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApCpacM : rk(A :: B :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpacm : rk(A :: B :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HABCApCpaceq HABCApCpacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbc *)
(* dans la couche 0 *)
Lemma LBBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBBpCpbcM3 : rk(B :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Cp :: bc :: nil) ((B :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HBMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpCpbcm2 : rk(B :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpCpbcm3 : rk(B :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HBBpCpeq : rk(B :: Bp :: Cp :: nil) = 3) by (apply LBBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}

assert(HBBpCpbcM : rk(B :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpbcm : rk(B :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBBpCpbceq HBBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bbc requis par la preuve de (?)Bbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBbcm2 : rk(B :: bc :: nil) >= 2).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HBBpCpbceq : rk(B :: Bp :: Cp :: bc :: nil) = 3) by (apply LBBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpCpbcmtmp : rk(B :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HBBpCpbceq HBBpCpbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: Bp :: Cp :: bc :: nil) ((B :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpbcmtmp;try rewrite HT2 in HBBpCpbcmtmp.
	assert(HT := rule_2 (B :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HBBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}

assert(HBbcM : rk(B :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBbceq HBbcM2).
assert(HBbcm : rk(B :: bc ::  nil) >= 1) by (solve_hyps_min HBbceq HBbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbc *)
(* dans constructLemma(), requis par LCBpCpbc *)
(* dans la couche 0 *)
Lemma LOoCBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpCpbc requis par la preuve de (?)OoCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcm2 : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpbcmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpCpbcm3 : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbceq HOoBCBpCpbcm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcmtmp;try rewrite HT2 in HOoBCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpCpbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoCBpCpbcM3 : rk(Oo :: C :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: C :: Cp :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Bp :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: nil) (Cp :: nil) 2 2 1 HOoCCpMtmp HBpCpbcMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoCBpCpbcM : rk(Oo :: C :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpCpbcm : rk(Oo :: C :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoCBpCpbceq HOoCBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCBpCpbcM3 : rk(C :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Cp :: bc :: nil) ((C :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HCMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpCpbcm2 : rk(C :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbceq HOoBCBpCpbcm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcmtmp;try rewrite HT2 in HOoBCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil) (Bp :: nil) 3 1 2 HOoBCBpCpbcmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc ::  de rang :  3 et 3 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HCBpCpbcm3 : rk(C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCBpCpbceq : rk(Oo :: C :: Bp :: Cp :: bc :: nil) = 3) by (apply LOoCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpCpbcmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoCBpCpbceq HOoCBpCpbcm3).
	assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: C :: Cp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: C :: Bp :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcmtmp;try rewrite HT2 in HOoCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil) (C :: Cp :: nil) 3 2 2 HOoCBpCpbcmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HCBpCpbcM : rk(C :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpCpbcm : rk(C :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HCBpCpbceq HCBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cbc requis par la preuve de (?)Cbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCbcm2 : rk(C :: bc :: nil) >= 2).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HCBpCpbceq : rk(C :: Bp :: Cp :: bc :: nil) = 3) by (apply LCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpCpbcmtmp : rk(C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HCBpCpbceq HCBpCpbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (C :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: Bp :: Cp :: bc :: nil) ((C :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpCpbcmtmp;try rewrite HT2 in HCBpCpbcmtmp.
	assert(HT := rule_2 (C :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HCBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}

assert(HCbcM : rk(C :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCbceq HCbcM2).
assert(HCbcm : rk(C :: bc ::  nil) >= 1) by (solve_hyps_min HCbceq HCbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACbc *)
(* dans constructLemma(), requis par LABCbc *)
(* dans la couche 0 *)
Lemma LOoABCApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbc requis par la preuve de (?)OoABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcM : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcm : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApbceq HOoABCApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoAp requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCbcM3 : rk(A :: B :: C :: bc :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: bc :: nil) ((A :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HAMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -1 et 5*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: Ap ::   de rang : 1 et 2 *)
assert(HABCbcm2 : rk(A :: B :: C :: bc :: nil) >= 2).
{
	assert(HOoApMtmp : rk(Oo :: Ap :: nil) <= 2) by (solve_hyps_max HOoApeq HOoApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: Ap :: nil) (A :: B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: Ap :: A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: A :: B :: C :: bc :: nil) ((Oo :: Ap :: nil) ++ (A :: B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: Ap :: nil) (A :: B :: C :: bc :: nil) (nil) 4 0 2 HOoABCApbcmtmp Hmtmp HOoApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCbcm3 : rk(A :: B :: C :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil) (A :: nil) 4 1 2 HOoABCApbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCbcM : rk(A :: B :: C :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCbcm : rk(A :: B :: C :: bc ::  nil) >= 1) by (solve_hyps_min HABCbceq HABCbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACbcm2 : rk(A :: C :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: bc :: nil) (A :: nil) 4 1 3 HOoABCApbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HACbcm3 : rk(A :: C :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HABCbceq : rk(A :: B :: C :: bc :: nil) = 3) by (apply LABCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCbcmtmp : rk(A :: B :: C :: bc :: nil) >= 3) by (solve_hyps_min HABCbceq HABCbcm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (A :: C :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: C :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: bc :: B :: C :: bc :: nil) ((A :: C :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCbcmtmp;try rewrite HT2 in HABCbcmtmp.
	assert(HT := rule_2 (A :: C :: bc :: nil) (B :: C :: bc :: nil) (C :: bc :: nil) 3 2 2 HABCbcmtmp HCbcmtmp HBCbcMtmp Hincl);apply HT.
}

assert(HACbcM : rk(A :: C :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACbceq HACbcM3).
assert(HACbcm : rk(A :: C :: bc ::  nil) >= 1) by (solve_hyps_min HACbceq HACbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpbc *)
(* dans constructLemma(), requis par LBCBpbc *)
(* dans la couche 0 *)
Lemma LOoBCBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbc requis par la preuve de (?)OoBCBpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoBCBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbc requis par la preuve de (?)OoBCBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcm3 : rk(Oo :: B :: C :: Bp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoBCBpbcM3 : rk(Oo :: B :: C :: Bp :: bc :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: nil) (Oo :: B :: Bp :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (B :: C :: bc :: nil) (B :: nil) 2 2 1 HOoBBpMtmp HBCbcMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBCBpbcM : rk(Oo :: B :: C :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcm : rk(Oo :: B :: C :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCBpbceq HOoBCBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Bp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCBpbc requis par la preuve de (?)BCBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbc requis par la preuve de (?)BCBpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)BCBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbc requis par la preuve de (?)BCBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcm2 : rk(B :: C :: Bp :: bc :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: nil) (nil) 4 0 2 HOoABCApBpbcmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCBpbcM3 : rk(B :: C :: Bp :: bc :: nil) <= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: nil) (Bp :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: B :: C :: bc :: nil) ((Bp :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HBpMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc ::  de rang :  3 et 3 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcm3 : rk(B :: C :: Bp :: bc :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbceq : rk(Oo :: B :: C :: Bp :: bc :: nil) = 3) by (apply LOoBCBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpbcmtmp : rk(Oo :: B :: C :: Bp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpbceq HOoBCBpbcm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcmtmp;try rewrite HT2 in HOoBCBpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HBCBpbcM : rk(B :: C :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpbcm : rk(B :: C :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HBCBpbceq HBCBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bpbc requis par la preuve de (?)Bpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc ::  de rang :  3 et 3 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcm2 : rk(Bp :: bc :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbceq : rk(B :: C :: Bp :: bc :: nil) = 3) by (apply LBCBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCBpbcmtmp : rk(B :: C :: Bp :: bc :: nil) >= 3) by (solve_hyps_min HBCBpbceq HBCBpbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: nil) (B :: C :: bc :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcmtmp;try rewrite HT2 in HBCBpbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: nil) (bc :: nil) 3 1 2 HBCBpbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HBpbcM : rk(Bp :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpbceq HBpbcM2).
assert(HBpbcm : rk(Bp :: bc ::  nil) >= 1) by (solve_hyps_min HBpbceq HBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpbc *)
(* dans la couche 0 *)
Lemma LOoBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpCpbc requis par la preuve de (?)OoBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpCpbc requis par la preuve de (?)OoBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpCpbc requis par la preuve de (?)OoBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBpCpbcM3 : rk(Oo :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: bc :: nil) (Oo :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: Cp :: bc :: nil) ((Oo :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HOoMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpCpbcm2 : rk(Oo :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: nil) (Oo :: Bp :: Cp :: bc :: nil) 2 2 HOoBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc ::  de rang :  3 et 3 	 AiB : Oo :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoBpCpbcm3 : rk(Oo :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCBpCpbceq : rk(Oo :: C :: Bp :: Cp :: bc :: nil) = 3) by (apply LOoCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpCpbcmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoCBpCpbceq HOoCBpCpbcm3).
	assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hincl : incl (Oo :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: nil) (Oo :: C :: Cp :: Oo :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: Bp :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcmtmp;try rewrite HT2 in HOoCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: Bp :: Cp :: bc :: nil) (Oo :: Cp :: nil) 3 2 2 HOoCBpCpbcmtmp HOoCpmtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HOoBpCpbcM : rk(Oo :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpCpbcm : rk(Oo :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBpCpbceq HOoBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpbc requis par la preuve de (?)OoBpbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpbc requis par la preuve de (?)OoBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpbc requis par la preuve de (?)OoBBpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpbc requis par la preuve de (?)OoBBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpbcm2 : rk(Oo :: B :: Bp :: bc :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApBpbceq HOoBCApBpbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (C :: Ap :: Oo :: B :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: bc :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpbcmtmp;try rewrite HT2 in HOoBCApBpbcmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: nil) (nil) 4 0 2 HOoBCApBpbcmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpbcM3 : rk(Oo :: B :: Bp :: bc :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: bc :: nil) (Oo :: B :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (bc :: nil) (nil) 2 1 0 HOoBBpMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpbc requis par la preuve de (?)OoBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: bc ::  de rang :  2 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpbcm2 : rk(Oo :: Bp :: bc :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpbcmtmp : rk(Oo :: B :: Bp :: bc :: nil) >= 2) by (solve_hyps_min HOoBBpbceq HOoBBpbcm2).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: bc :: nil) (Oo :: B :: Bp :: Oo :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpbcmtmp;try rewrite HT2 in HOoBBpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoBpbcm3 : rk(Oo :: Bp :: bc :: nil) >= 3).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HOoBpCpbceq : rk(Oo :: Bp :: Cp :: bc :: nil) = 3) by (apply LOoBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpCpbcmtmp : rk(Oo :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBpCpbceq HOoBpCpbcm3).
	assert(HBpbceq : rk(Bp :: bc :: nil) = 2) by (apply LBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpbcmtmp : rk(Bp :: bc :: nil) >= 2) by (solve_hyps_min HBpbceq HBpbcm2).
	assert(Hincl : incl (Bp :: bc :: nil) (list_inter (Oo :: Bp :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: Cp :: bc :: nil) (Oo :: Bp :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: bc :: Bp :: Cp :: bc :: nil) ((Oo :: Bp :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpCpbcmtmp;try rewrite HT2 in HOoBpCpbcmtmp.
	assert(HT := rule_2 (Oo :: Bp :: bc :: nil) (Bp :: Cp :: bc :: nil) (Bp :: bc :: nil) 3 2 2 HOoBpCpbcmtmp HBpbcmtmp HBpCpbcMtmp Hincl);apply HT.
}

assert(HOoBpbcM : rk(Oo :: Bp :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpbceq HOoBpbcM3).
assert(HOoBpbcm : rk(Oo :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBpbceq HOoBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) = 4) by (apply LOoABCApBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpbcM : rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpbcm : rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApBpbceq HOoBCApBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpbc *)
(* dans constructLemma(), requis par LBCApCpbc *)
(* dans constructLemma(), requis par LOoBCApCpbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbc requis par la preuve de (?)OoABCApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApCpbc requis par la preuve de (?)OoBCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApCpbcm4 : rk(Oo :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApCpbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApCpbcM : rk(Oo :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApCpbcm : rk(Oo :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApCpbceq HOoBCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpbcm3 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCApCpbcm4 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoBCApCpbceq : rk(Oo :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoBCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApCpbcmtmp : rk(Oo :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApCpbceq HOoBCApCpbcm4).
	assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApCpbcmtmp;try rewrite HT2 in HOoBCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (C :: Cp :: nil) 4 2 2 HOoBCApCpbcmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HBCApCpbcM : rk(B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpbcm : rk(B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpbceq HBCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpbc requis par la preuve de (?)OoCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpbcm3 : rk(Oo :: C :: Ap :: Cp :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpbcm2 : rk(Ap :: Cp :: bc :: nil) >= 2).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpbcmtmp : rk(Oo :: C :: Ap :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpbceq HOoCApCpbcm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpbcmtmp;try rewrite HT2 in HOoCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpbcm3 : rk(Ap :: Cp :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCApCpbceq : rk(B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LBCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApCpbcmtmp : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpbceq HBCApCpbcm4).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpbcmtmp;try rewrite HT2 in HBCApCpbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HApCpbcM : rk(Ap :: Cp :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpbceq HApCpbcM3).
assert(HApCpbcm : rk(Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HApCpbceq HApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACabbc *)
(* dans la couche 0 *)
Lemma LABCabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcm3 : rk(A :: B :: C :: ab :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCabbcM3 : rk(A :: B :: C :: ab :: bc :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: bc :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: C :: bc :: nil) (B :: nil) 2 2 1 HABabMtmp HBCbcMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCabbcM : rk(A :: B :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabbcm : rk(A :: B :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCabbceq HABCabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabbcm2 : rk(A :: C :: ab :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc ::  de rang :  3 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcm3 : rk(A :: C :: ab :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcmtmp : rk(A :: B :: C :: ab :: bc :: nil) >= 3) by (solve_hyps_min HABCabbceq HABCabbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcmtmp;try rewrite HT2 in HABCabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACabbcM3 : rk(A :: C :: ab :: bc :: nil) <= 3).
{
	assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcMtmp : rk(A :: B :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HABCabbceq HABCabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil) 3 3 HABCabbcMtmp Hcomp Hincl);apply HT.
}

assert(HACabbcM : rk(A :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabbcm : rk(A :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HACabbceq HACabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpabbc *)
(* dans la couche 0 *)
Lemma LApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoBCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpabbc requis par la preuve de (?)OoBCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpabbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabbcm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApBpCpabbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCApBpCpabbcm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCApBpCpabbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApBpCpabbceq HOoBCApBpCpabbcm4).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpabbcmtmp;try rewrite HT2 in HOoBCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Bp :: nil) 4 2 2 HOoBCApBpCpabbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpCpabbc requis par la preuve de (?)OoBApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpCpabbc requis par la preuve de (?)OoABApBpCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpCpabbc requis par la preuve de (?)OoABApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpCpabbcm2 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpCpabbcm3 : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpCpabbc requis par la preuve de (?)OoBApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpCpabbcm3 : rk(Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpCpabbcmtmp : rk(Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoABApBpCpabbceq HOoABApBpCpabbcm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpCpabbcmtmp;try rewrite HT2 in HOoABApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpCpabbcmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpCpabbcm2 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpCpabbcmtmp : rk(Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoBApBpCpabbceq HOoBApBpCpabbcm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Bp :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpCpabbcmtmp;try rewrite HT2 in HOoBApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) (Bp :: nil) 3 1 2 HOoBApBpCpabbcmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApBpCpabbcm3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApBpCpabbcmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoCApBpCpabbceq HOoCApBpCpabbcm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: C :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpabbcmtmp;try rewrite HT2 in HOoCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) (Cp :: nil) 4 1 2 HOoCApBpCpabbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApBpCpabbcM3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpCpbcMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApBpCpabbcM : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpabbcm : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApBpCpabbceq HApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabbceq HOoABApCpabbcm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbcmtmp;try rewrite HT2 in HOoABApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabbc requis par la preuve de (?)OoCApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabbc requis par la preuve de (?)OoABCApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpabbc requis par la preuve de (?)OoCApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpabbcm3 : rk(Oo :: C :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabbceq HOoABCApCpabbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabbcmtmp;try rewrite HT2 in HOoABCApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpabbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpabbcm2 : rk(Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpabbcmtmp : rk(Oo :: C :: Ap :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpabbceq HOoCApCpabbcm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ab :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpabbcmtmp;try rewrite HT2 in HOoCApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpabbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabbcm3 : rk(Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabbceq HABApCpabbcm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabbcmtmp;try rewrite HT2 in HABApCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabbcM3 : rk(Ap :: Cp :: ab :: bc :: nil) <= 3).
{
	assert(HApBpCpabbceq : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) = 3) by (apply LApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpCpabbcMtmp : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApBpCpabbceq HApBpCpabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) 3 3 HApBpCpabbcMtmp Hcomp Hincl);apply HT.
}

assert(HApCpabbcM : rk(Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabbcm : rk(Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabbceq HApCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabbc requis par la preuve de (?)OoABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabbceq HOoABApCpabbcm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbcmtmp;try rewrite HT2 in HOoABApCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabbcM : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabbcm : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabbceq HABApCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabbc requis par la preuve de (?)OoABCApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabbceq HOoABCApCpabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpCpabbc *)
(* dans constructLemma(), requis par LOoBCApBpCpabbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpabbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpabbc requis par la preuve de (?)OoBCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpabbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpabbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpCpabbcM : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpCpabbcm : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApBpCpabbceq HOoBCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpabbc requis par la preuve de (?)OoCApBpCpabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabbcm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpabbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApBpCpabbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCApBpCpabbcm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCApBpCpabbceq : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoBCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApBpCpabbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApBpCpabbceq HOoBCApBpCpabbcm4).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpabbcmtmp;try rewrite HT2 in HOoBCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: Bp :: nil) 4 2 2 HOoBCApBpCpabbcmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HOoCApBpCpabbcM : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpabbcm : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpabbceq HOoCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacbcm2 : rk(A :: C :: ac :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacbcmtmp;try rewrite HT2 in HOoABCApacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HACacbcM3 : rk(A :: C :: ac :: bc :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (bc :: nil) (nil) 2 1 0 HACacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacbcm3 : rk(A :: C :: ac :: bc :: nil) >= 3).
{
	assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil) 3 3 HACbcmtmp Hcomp Hincl);apply HT.
}

assert(HACacbcM : rk(A :: C :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacbcm : rk(A :: C :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACacbceq HACacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacbcM : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacbcm : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpacbc *)
(* dans constructLemma(), requis par LBCApCpacbc *)
(* dans constructLemma(), requis par LOoBCApCpacbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacbc requis par la preuve de (?)OoABCApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApCpacbc requis par la preuve de (?)OoBCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApCpacbcm4 : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApCpacbcmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApCpacbcM : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApCpacbcm : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApCpacbceq HOoBCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacbcm3 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCApCpacbcm4 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoBCApCpacbceq : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoBCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApCpacbcmtmp : rk(Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApCpacbceq HOoBCApCpacbcm4).
	assert(HCCpeq : rk(C :: Cp :: nil) = 2) by (apply LCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApCpacbcmtmp;try rewrite HT2 in HOoBCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (C :: Cp :: nil) 4 2 2 HOoBCApCpacbcmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HBCApCpacbcM : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpacbcm : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpacbc requis par la preuve de (?)OoCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacbcm3 : rk(Oo :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpacbcm2 : rk(Ap :: Cp :: ac :: bc :: nil) >= 2).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpacbcmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpacbceq HOoCApCpacbcm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacbcmtmp;try rewrite HT2 in HOoCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpacbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApCpacbcM3 : rk(Ap :: Cp :: ac :: bc :: nil) <= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Cp :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (bc :: nil) (nil) 2 1 0 HApCpacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpacbcm3 : rk(Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCApCpacbceq : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LBCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApCpacbcmtmp : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm4).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacbcmtmp;try rewrite HT2 in HBCApCpacbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpacbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HApCpacbcM : rk(Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacbcm : rk(Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpacbceq HApCpacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans constructLemma(), requis par LAabacbc *)
(* dans la couche 0 *)
Lemma LACabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACabacbcM3 : rk(A :: C :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HACabbceq : rk(A :: C :: ab :: bc :: nil) = 3) by (apply LACabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabbcMtmp : rk(A :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HACabbceq HACabbcM3).
	assert(HACacbceq : rk(A :: C :: ac :: bc :: nil) = 3) by (apply LACacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacbcMtmp : rk(A :: C :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACacbceq HACacbcM3).
	assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hincl : incl (A :: C :: bc :: nil) (list_inter (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil) ((A :: C :: ab :: bc :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil) (A :: C :: bc :: nil) 3 3 3 HACabbcMtmp HACacbcMtmp HACbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACabacbcM : rk(A :: C :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcm : rk(A :: C :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACabacbceq HACabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm3 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabacbcm2 : rk(A :: B :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (C :: Ap :: A :: B :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: ac :: bc :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ac :: bc ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabacbcm2 : rk(A :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabacbcmtmp : rk(A :: B :: ab :: ac :: bc :: nil) >= 2) by (solve_hyps_min HABabacbceq HABabacbcm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabacbcmtmp;try rewrite HT2 in HABabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil) (A :: ab :: nil) 2 2 2 HABabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAabacbcm3 : rk(A :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil) (A :: ac :: nil) 3 2 2 HACabacbcmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabacbcM3 : rk(A :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HACabacbceq : rk(A :: C :: ab :: ac :: bc :: nil) = 3) by (apply LACabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabacbcMtmp : rk(A :: C :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACabacbceq HACabacbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil) 3 3 HACabacbcMtmp Hcomp Hincl);apply HT.
}

assert(HAabacbcM : rk(A :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabacbcm : rk(A :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAabacbceq HAabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans la couche 0 *)
Lemma LApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabacbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabacbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabacbceq HOoABApCpabacbcm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabacbcmtmp;try rewrite HT2 in HOoABApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoABCApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpabacbc requis par la preuve de (?)OoCApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpabacbcm3 : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpabacbcmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpabacbcm2 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpabacbcmtmp : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoCApCpabacbceq HOoCApCpabacbcm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpabacbcmtmp;try rewrite HT2 in HOoCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (Cp :: nil) 3 1 2 HOoCApCpabacbcmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabacbcm3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabacbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApCpabacbcM3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HApCpabbceq : rk(Ap :: Cp :: ab :: bc :: nil) = 3) by (apply LApCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpabbcMtmp : rk(Ap :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApCpabbceq HApCpabbcM3).
	assert(HApCpacbceq : rk(Ap :: Cp :: ac :: bc :: nil) = 3) by (apply LApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpacbcMtmp : rk(Ap :: Cp :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpacbceq HApCpacbcM3).
	assert(HApCpbceq : rk(Ap :: Cp :: bc :: nil) = 3) by (apply LApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpbcmtmp : rk(Ap :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HApCpbceq HApCpbcm3).
	assert(Hincl : incl (Ap :: Cp :: bc :: nil) (list_inter (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ab :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: bc :: nil) 3 3 3 HApCpabbcMtmp HApCpacbcMtmp HApCpbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApCpabacbcM : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabacbcm : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabacbceq HApCpabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans constructLemma(), requis par LAApCpabacbc *)
(* dans la couche 0 *)
Lemma LABApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabacbc requis par la preuve de (?)OoABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabacbcm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacbcm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabacbcmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoABApCpabacbceq HOoABApCpabacbcm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabacbcmtmp;try rewrite HT2 in HOoABApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabacbcM : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabacbcm : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoABCApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpabacbcm3 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpabacbcm4 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApCpabacbcm2 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApCpabacbcmtmp : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApCpabacbceq HABCApCpabacbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (B :: C :: Ap :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpabacbcmtmp;try rewrite HT2 in HABCApCpabacbcmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (Ap :: nil) 4 1 3 HABCApCpabacbcmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpabacbcm3 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabMtmp : rk(B :: ab :: nil) <= 2) by (solve_hyps_max HBabeq HBabM2).
	assert(HABApCpabacbceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LABApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((B :: ab :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabacbcmtmp Habmtmp HBabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpabacbcm4 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabacbceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LABApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: nil) 4 2 2 HABApCpabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HAApCpabacbcM : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpabacbcm : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 3 HOoABCApabacbcmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcm2 : rk(ab :: ac :: bc :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: nil) (ac :: nil) 3 1 2 HACabacbcmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabacbcM2 : rk(ab :: ac :: bc :: nil) <= 2).
{
	assert(HAabacbceq : rk(A :: ab :: ac :: bc :: nil) = 3) by (apply LAabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabacbcMtmp : rk(A :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HAabacbceq HAabacbcM3).
	assert(HApCpabacbceq : rk(Ap :: Cp :: ab :: ac :: bc :: nil) = 3) by (apply LApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpabacbcMtmp : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpabacbceq HApCpabacbcM3).
	assert(HAApCpabacbceq : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LAApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpabacbcmtmp : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm4).
	assert(Hincl : incl (ab :: ac :: bc :: nil) (list_inter (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: ab :: ac :: bc :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpabacbcmtmp;try rewrite HT2 in HAApCpabacbcmtmp.
	assert(HT := rule_3 (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: ac :: bc :: nil) 3 3 4 HAabacbcMtmp HApCpabacbcMtmp HAApCpabacbcmtmp Hincl);apply HT.
}


assert(HabacbcM : rk(ab :: ac :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habacbceq HabacbcM3).
assert(Habacbcm : rk(ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min Habacbceq Habacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbc *)
(* dans la couche 0 *)
Lemma LOoABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm3 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApabacbcM : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcm : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApabacbceq HABCApabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApCpabacbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabacbc requis par la preuve de (?)OoABCApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabacbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabacbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpabacbc requis par la preuve de (?)ABCApCpabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpabacbcm3 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpabacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApCpabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApCpabacbcm4 : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpabacbceq HOoABCApCpabacbcm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacbcmtmp;try rewrite HT2 in HOoABCApCpabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApCpabacbcmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApCpabacbcM : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpabacbcm : rk(A :: B :: C :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApCpabacbceq HABCApCpabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoD *)
(* dans la couche 0 *)
Lemma LOoD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)OoD pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm3 : rk(A :: B :: C :: Ap :: D :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDmtmp : rk(A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HABCApDeq HABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: nil) (C :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDmtmp;try rewrite HT2 in HABCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: nil) (nil) 4 0 2 HABCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoD requis par la preuve de (?)OoD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HOoDm2 : rk(Oo :: D :: nil) >= 2).
{
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 3) by (solve_hyps_max HABDeq HABDM3).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HABDMtmp Hincl);apply HT.
}

assert(HOoDM : rk(Oo :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoDeq HOoDM2).
assert(HOoDm : rk(Oo :: D ::  nil) >= 1) by (solve_hyps_min HOoDeq HOoDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAD *)
(* dans la couche 0 *)
Lemma LAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBD requis par la preuve de (?)AD pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDm4 : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDm2 : rk(Oo :: B :: D :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDmtmp : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoBCApDeq HOoBCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: nil) (C :: Ap :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: D :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDmtmp;try rewrite HT2 in HOoBCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: D :: nil) (nil) 4 0 2 HOoBCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AD requis par la preuve de (?)AD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HADm2 : rk(A :: D :: nil) >= 2).
{
	assert(HOoBDMtmp : rk(Oo :: B :: D :: nil) <= 3) by (solve_hyps_max HOoBDeq HOoBDM3).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (A :: D :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: B :: D :: nil) ((A :: D :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (A :: D :: nil) (Oo :: B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HOoBDMtmp Hincl);apply HT.
}

assert(HADM : rk(A :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HADeq HADM2).
assert(HADm : rk(A :: D ::  nil) >= 1) by (solve_hyps_min HADeq HADm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAD *)
(* dans la couche 0 *)
Lemma LOoAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BD requis par la preuve de (?)OoAD pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoAD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDm2 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDmtmp;try rewrite HT2 in HOoABCApBpDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil) (nil) 4 0 2 HOoABCApBpDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDm3 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADm2 : rk(Oo :: A :: D :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDmtmp : rk(Oo :: A :: B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HOoABBpDeq HOoABBpDm3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: nil) (Oo :: B :: Bp :: Oo :: A :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: D :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDmtmp;try rewrite HT2 in HOoABBpDmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: D :: nil) (Oo :: nil) 3 1 2 HOoABBpDmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HOoADm3 : rk(Oo :: A :: D :: nil) >= 3).
{
	assert(HBDMtmp : rk(B :: D :: nil) <= 2) by (solve_hyps_max HBDeq HBDM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: A :: D :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: B :: D :: nil) ((Oo :: A :: D :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: A :: D :: nil) (B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HBDMtmp Hincl);apply HT.
}

assert(HOoADM : rk(Oo :: A :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoADeq HOoADM3).
assert(HOoADm : rk(Oo :: A :: D ::  nil) >= 1) by (solve_hyps_min HOoADeq HOoADm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BD requis par la preuve de (?)BD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: A :: D ::   de rang : 3 et 3 *)
assert(HBDm2 : rk(B :: D :: nil) >= 2).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADMtmp : rk(Oo :: A :: D :: nil) <= 3) by (solve_hyps_max HOoADeq HOoADM3).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: A :: D :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: B :: D :: nil) ((Oo :: A :: D :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (Oo :: A :: D :: nil) (B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HOoADMtmp Hincl); apply HT.
}

assert(HBDM : rk(B :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBDeq HBDM2).
assert(HBDm : rk(B :: D ::  nil) >= 1) by (solve_hyps_min HBDeq HBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDm4 : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDm2 : rk(Oo :: B :: D :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDmtmp : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoBCApDeq HOoBCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: nil) (C :: Ap :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: D :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDmtmp;try rewrite HT2 in HOoBCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: D :: nil) (nil) 4 0 2 HOoBCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoBDm3 : rk(Oo :: B :: D :: nil) >= 3).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (A :: D :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: B :: D :: nil) ((A :: D :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HADMtmp Hincl); apply HT.
}

assert(HOoBDM : rk(Oo :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBDeq HOoBDM3).
assert(HOoBDm : rk(Oo :: B :: D ::  nil) >= 1) by (solve_hyps_min HOoBDeq HOoBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm3 : rk(A :: B :: C :: Ap :: D :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDmtmp : rk(A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HABCApDeq HABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: nil) (C :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDmtmp;try rewrite HT2 in HABCApDmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: nil) (nil) 4 0 2 HABCApDmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HABDm3 : rk(A :: B :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HABDM : rk(A :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABDeq HABDM3).
assert(HABDm : rk(A :: B :: D ::  nil) >= 1) by (solve_hyps_min HABDeq HABDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD requis par la preuve de (?)CD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: A :: D ::   de rang : 3 et 3 *)
assert(HCDm2 : rk(C :: D :: nil) >= 2).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADMtmp : rk(Oo :: A :: D :: nil) <= 3) by (solve_hyps_max HOoADeq HOoADM3).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (Oo :: A :: D :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: C :: D :: nil) ((Oo :: A :: D :: nil) ++ (C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (Oo :: A :: D :: nil) (C :: D :: nil) (D :: nil) 4 1 3 HOoACDmtmp HDmtmp HOoADMtmp Hincl); apply HT.
}

assert(HCDM : rk(C :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCDeq HCDM2).
assert(HCDm : rk(C :: D ::  nil) >= 1) by (solve_hyps_min HCDeq HCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCDm2 : rk(Oo :: C :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApDmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoCDm3 : rk(Oo :: C :: D :: nil) >= 3).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (A :: D :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: C :: D :: nil) ((A :: D :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HADMtmp Hincl); apply HT.
}

assert(HOoCDM : rk(Oo :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCDeq HOoCDM3).
assert(HOoCDm : rk(Oo :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoCDeq HOoCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACDm2 : rk(A :: C :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: nil) (A :: nil) 4 1 3 HOoABCApDmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HACDm3 : rk(A :: C :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (Oo :: D :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: C :: D :: nil) ((Oo :: D :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HACDM : rk(A :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACDeq HACDM3).
assert(HACDm : rk(A :: C :: D ::  nil) >= 1) by (solve_hyps_min HACDeq HACDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCDm2 : rk(B :: C :: D :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: D :: nil) (nil) 4 0 2 HOoABCApDmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HBCDm3 : rk(B :: C :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: nil) (Oo :: D :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: B :: C :: D :: nil) ((Oo :: D :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCDmtmp;try rewrite HT2 in HOoBCDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (B :: C :: D :: nil) (D :: nil) 4 1 2 HOoBCDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HBCDM : rk(B :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCDeq HBCDM3).
assert(HBCDm : rk(B :: C :: D ::  nil) >= 1) by (solve_hyps_min HBCDeq HBCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCD requis par la preuve de (?)OoABCD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDm4 : rk(Oo :: A :: B :: C :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDM : rk(Oo :: A :: B :: C :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDm : rk(Oo :: A :: B :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoABCDeq HOoABCDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApD *)
(* dans la couche 0 *)
Lemma LOoABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDM : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDm : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApDeq HOoABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApD requis par la preuve de (?)OoBCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDm4 : rk(Oo :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApDM : rk(Oo :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDm : rk(Oo :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HOoBCApDeq HOoBCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm3 : rk(A :: B :: C :: Ap :: D :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApDM : rk(A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDm : rk(A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HABCApDeq HABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoDp requis par la preuve de (?)OoDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -1 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoDpm2 : rk(Oo :: Dp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Oo :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Oo :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Oo :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Oo :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Oo :: Dp :: nil) (nil) 4 0 2 HOoApBpDpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}

assert(HOoDpM : rk(Oo :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoDpeq HOoDpM2).
assert(HOoDpm : rk(Oo :: Dp ::  nil) >= 1) by (solve_hyps_min HOoDpeq HOoDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoADp *)
(* dans la couche 0 *)
Lemma LOoADDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADDp requis par la preuve de (?)OoADDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoADDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDDpm2 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpmtmp;try rewrite HT2 in HOoABCApBpDDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDDpm3 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADDp requis par la preuve de (?)OoADDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADDp requis par la preuve de (?)OoADDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoADDpM3 : rk(Oo :: A :: D :: Dp :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: Dp :: nil) (A :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Oo :: D :: Dp :: nil) ((A :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HAMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: Dp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADDpm2 : rk(Oo :: A :: D :: Dp :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDDpmtmp : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoABBpDDpeq HOoABBpDDpm3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDDpmtmp;try rewrite HT2 in HOoABBpDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: D :: Dp :: nil) (Oo :: nil) 3 1 2 HOoABBpDDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADDpm3 : rk(Oo :: A :: D :: Dp :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoADDpM : rk(Oo :: A :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADDpm : rk(Oo :: A :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoADDpeq HOoADDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoADp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADp requis par la preuve de (?)OoADp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoADp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDpm2 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDpm3 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADp requis par la preuve de (?)OoADp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: Dp ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADpm2 : rk(Oo :: A :: Dp :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDpmtmp : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDpmtmp;try rewrite HT2 in HOoABBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Dp :: nil) (Oo :: nil) 3 1 2 HOoABBpDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoADpm3 : rk(Oo :: A :: Dp :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoADDpeq : rk(Oo :: A :: D :: Dp :: nil) = 3) by (apply LOoADDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADDpmtmp : rk(Oo :: A :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoADDpeq HOoADDpm3).
	assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: A :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: Dp :: nil) (Oo :: A :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: A :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoADDpmtmp;try rewrite HT2 in HOoADDpmtmp.
	assert(HT := rule_2 (Oo :: A :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 3 2 2 HOoADDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HOoADpM : rk(Oo :: A :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoADpeq HOoADpM3).
assert(HOoADpm : rk(Oo :: A :: Dp ::  nil) >= 1) by (solve_hyps_min HOoADpeq HOoADpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBDp *)
(* dans la couche 0 *)
Lemma LOoBDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBDDp requis par la preuve de (?)OoBDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBDDp requis par la preuve de (?)OoBDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBDDp requis par la preuve de (?)OoBDDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBDDpM3 : rk(Oo :: B :: D :: Dp :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: Dp :: nil) (B :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: D :: Dp :: nil) ((B :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HBMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDDpm2 : rk(Oo :: B :: D :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDDpmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApDDpeq HOoBCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: nil) (C :: Ap :: Oo :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: D :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpmtmp;try rewrite HT2 in HOoBCApDDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: D :: Dp :: nil) (nil) 4 0 2 HOoBCApDDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBDDpm3 : rk(Oo :: B :: D :: Dp :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: D :: Dp :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBDDpM : rk(Oo :: B :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBDDpm : rk(Oo :: B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBDDpeq HOoBDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBDp requis par la preuve de (?)OoBDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDp requis par la preuve de (?)OoBDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoBCApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDp requis par la preuve de (?)OoBCApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpm4 : rk(Oo :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBDp requis par la preuve de (?)OoBDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBDpm2 : rk(Oo :: B :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApDpmtmp : rk(Oo :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApDpeq HOoBCApDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Dp :: nil) (C :: Ap :: Oo :: B :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDpmtmp;try rewrite HT2 in HOoBCApDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Dp :: nil) (nil) 4 0 2 HOoBCApDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoBDpm3 : rk(Oo :: B :: Dp :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBDDpeq : rk(Oo :: B :: D :: Dp :: nil) = 3) by (apply LOoBDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDDpmtmp : rk(Oo :: B :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoBDDpeq HOoBDDpm3).
	assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: B :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: Dp :: nil) (Oo :: B :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: B :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBDDpmtmp;try rewrite HT2 in HOoBDDpmtmp.
	assert(HT := rule_2 (Oo :: B :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 3 2 2 HOoBDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HOoBDpM : rk(Oo :: B :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBDpeq HOoBDpM3).
assert(HOoBDpm : rk(Oo :: B :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBDpeq HOoBDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABDp *)
(* dans la couche 0 *)
Lemma LOoABDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABCCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDDpm4 : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABDDpm2 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: D :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApDDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDDpm3 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDDpmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCCpDDpeq HOoABCCpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDDpmtmp;try rewrite HT2 in HOoABCCpDDpmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCCpDDpmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABDDpm4 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: Dp :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABDDpM : rk(Oo :: A :: B :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDDpm : rk(Oo :: A :: B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABDDpeq HOoABDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDp requis par la preuve de (?)OoABDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDp requis par la preuve de (?)OoABCCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDpm4 : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDp requis par la preuve de (?)OoABDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABDpm2 : rk(Oo :: A :: B :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Dp :: nil) (nil) 4 0 2 HOoABCApDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDpm3 : rk(Oo :: A :: B :: Dp :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDpmtmp : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCCpDpeq HOoABCCpDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: Dp :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDpmtmp;try rewrite HT2 in HOoABCCpDpmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCCpDpmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoABDpm4 : rk(Oo :: A :: B :: Dp :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoABDDpeq : rk(Oo :: A :: B :: D :: Dp :: nil) = 4) by (apply LOoABDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDDpmtmp : rk(Oo :: A :: B :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABDDpeq HOoABDDpm4).
	assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: A :: B :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: Dp :: nil) (Oo :: A :: B :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: A :: B :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDDpmtmp;try rewrite HT2 in HOoABDDpmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 4 2 2 HOoABDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HOoABDpM : rk(Oo :: A :: B :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDpm : rk(Oo :: A :: B :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABDpeq HOoABDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCDp *)
(* dans la couche 0 *)
Lemma LOoCDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCDDp requis par la preuve de (?)OoCDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCDDp requis par la preuve de (?)OoCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCDDp requis par la preuve de (?)OoCDDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoCDDpM3 : rk(Oo :: C :: D :: Dp :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: D :: Dp :: nil) (C :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: D :: Dp :: nil) ((C :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HCMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCDDpm2 : rk(Oo :: C :: D :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApDDpmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApDDpeq HOoBCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: nil) (B :: Ap :: Oo :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpmtmp;try rewrite HT2 in HOoBCApDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: D :: Dp :: nil) (nil) 4 0 2 HOoBCApDDpmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCDDpm3 : rk(Oo :: C :: D :: Dp :: nil) >= 3).
{
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: D :: nil) (Oo :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: D :: nil) (Oo :: C :: D :: Dp :: nil) 3 3 HOoCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoCDDpM : rk(Oo :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCDDpm : rk(Oo :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCDDpeq HOoCDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCDp requis par la preuve de (?)OoCDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoCDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCDp requis par la preuve de (?)OoCDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCDpm2 : rk(Oo :: C :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApDpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoCDpm3 : rk(Oo :: C :: Dp :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCDDpeq : rk(Oo :: C :: D :: Dp :: nil) = 3) by (apply LOoCDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDDpmtmp : rk(Oo :: C :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoCDDpeq HOoCDDpm3).
	assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: C :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: D :: Dp :: nil) (Oo :: C :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: C :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCDDpmtmp;try rewrite HT2 in HOoCDDpmtmp.
	assert(HT := rule_2 (Oo :: C :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 3 2 2 HOoCDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HOoCDpM : rk(Oo :: C :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCDpeq HOoCDpM3).
assert(HOoCDpm : rk(Oo :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCDpeq HOoCDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACDp *)
(* dans la couche 0 *)
Lemma LOoACDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoABCBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoA requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoACDDpm2 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 1) by (solve_hyps_min HOoAeq HOoAm1).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: C :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: D :: Dp :: nil) (Oo :: A :: nil) 4 1 3 HOoABCApDDpmtmp HOoAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACDDpm3 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpDDpmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDDpeq HOoABCBpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDDpmtmp;try rewrite HT2 in HOoABCBpDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCBpDDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACDDpm4 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: Dp :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACDDpM : rk(Oo :: A :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDDpm : rk(Oo :: A :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACDDpeq HOoACDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACDp requis par la preuve de (?)OoACDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDp requis par la preuve de (?)OoABCBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDpm4 : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoA requis par la preuve de (?)OoACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACDp requis par la preuve de (?)OoACDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoACDpm2 : rk(Oo :: A :: C :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOoAmtmp : rk(Oo :: A :: nil) >= 1) by (solve_hyps_min HOoAeq HOoAm1).
	assert(Hincl : incl (Oo :: A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: C :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: C :: Dp :: nil) (Oo :: A :: nil) 4 1 3 HOoABCApDpmtmp HOoAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACDpm3 : rk(Oo :: A :: C :: Dp :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpDpmtmp : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDpmtmp;try rewrite HT2 in HOoABCBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCBpDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoACDpm4 : rk(Oo :: A :: C :: Dp :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoACDDpeq : rk(Oo :: A :: C :: D :: Dp :: nil) = 4) by (apply LOoACDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACDDpmtmp : rk(Oo :: A :: C :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACDDpeq HOoACDDpm4).
	assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: A :: C :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: Dp :: nil) (Oo :: A :: C :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: A :: C :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDDpmtmp;try rewrite HT2 in HOoACDDpmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 4 2 2 HOoACDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HOoACDpM : rk(Oo :: A :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDpm : rk(Oo :: A :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACDpeq HOoACDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCDp *)
(* dans la couche 0 *)
Lemma LOoBCDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDDp requis par la preuve de (?)OoBCDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoBCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDDp requis par la preuve de (?)OoBCDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDDpm3 : rk(Oo :: B :: C :: D :: Dp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApDDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCDDpm4 : rk(Oo :: B :: C :: D :: Dp :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: D :: Dp :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCDDpM : rk(Oo :: B :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDDpm : rk(Oo :: B :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCDDpeq HOoBCDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDp requis par la preuve de (?)OoBCDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoBCDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDp requis par la preuve de (?)OoBCDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDpm3 : rk(Oo :: B :: C :: Dp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoBCDpm4 : rk(Oo :: B :: C :: Dp :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBCDDpeq : rk(Oo :: B :: C :: D :: Dp :: nil) = 4) by (apply LOoBCDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDDpmtmp : rk(Oo :: B :: C :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCDDpeq HOoBCDDpm4).
	assert(HOoDpeq : rk(Oo :: Dp :: nil) = 2) by (apply LOoDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDpmtmp : rk(Oo :: Dp :: nil) >= 2) by (solve_hyps_min HOoDpeq HOoDpm2).
	assert(Hincl : incl (Oo :: Dp :: nil) (list_inter (Oo :: B :: C :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: Dp :: nil) (Oo :: B :: C :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Dp :: Oo :: D :: Dp :: nil) ((Oo :: B :: C :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCDDpmtmp;try rewrite HT2 in HOoBCDDpmtmp.
	assert(HT := rule_2 (Oo :: B :: C :: Dp :: nil) (Oo :: D :: Dp :: nil) (Oo :: Dp :: nil) 4 2 2 HOoBCDDpmtmp HOoDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HOoBCDpM : rk(Oo :: B :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDpm : rk(Oo :: B :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCDpeq HOoBCDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDp requis par la preuve de (?)OoABCDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDpm4 : rk(Oo :: A :: B :: C :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDpM : rk(Oo :: A :: B :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDpm : rk(Oo :: A :: B :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCDpeq HOoABCDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApDp requis par la preuve de (?)ApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Dp ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HApDpm2 : rk(Ap :: Dp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HApBpDpmtmp : rk(Ap :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HApBpDpeq HApBpDpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Ap :: Bp :: nil) (Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Ap :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpDpmtmp;try rewrite HT2 in HApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Ap :: Dp :: nil) (Ap :: nil) 3 1 2 HApBpDpmtmp HApmtmp HApBpMtmp Hincl); apply HT.
}

assert(HApDpM : rk(Ap :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApDpeq HApDpM2).
assert(HApDpm : rk(Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HApDpeq HApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApDp requis par la preuve de (?)OoApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoABApDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoABApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDpm2 : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDpm3 : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApDp requis par la preuve de (?)OoApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApDpm2 : rk(Oo :: Ap :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDpmtmp : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApDpeq HOoABApDpm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDpmtmp;try rewrite HT2 in HOoABApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApDpmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -1 et -2*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Bp ::   de rang : 1 et 1 *)
assert(HOoApDpm3 : rk(Oo :: Ap :: Dp :: nil) >= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Bp :: Oo :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: Ap :: Dp :: nil) ((Bp :: nil) ++ (Oo :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_4 (Bp :: nil) (Oo :: Ap :: Dp :: nil) (nil) 4 0 1 HOoApBpDpmtmp Hmtmp HBpMtmp Hincl); apply HT.
}

assert(HOoApDpM : rk(Oo :: Ap :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApDpeq HOoApDpM3).
assert(HOoApDpm : rk(Oo :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoApDpeq HOoApDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApDp *)
(* dans la couche 0 *)
Lemma LOoABCApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDpM : rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpm : rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDp requis par la preuve de (?)OoAApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApDp requis par la preuve de (?)OoAApDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDp requis par la preuve de (?)OoAApDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApDpM3 : rk(Oo :: A :: Ap :: Dp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Dp :: nil) (nil) 2 1 0 HOoAApMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDpm2 : rk(Oo :: A :: Ap :: Dp :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoAApDpm3 : rk(Oo :: A :: Ap :: Dp :: nil) >= 3).
{
	assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	assert(HOoABCApDpeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) = 4) by (apply LOoABCApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOoADpeq : rk(Oo :: A :: Dp :: nil) = 3) by (apply LOoADp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADpmtmp : rk(Oo :: A :: Dp :: nil) >= 3) by (solve_hyps_min HOoADpeq HOoADpm3).
	assert(Hincl : incl (Oo :: A :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: A :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: A :: Ap :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: A :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: Ap :: Dp :: nil) (Oo :: A :: Dp :: nil) 4 3 4 HOoABCApDpmtmp HOoADpmtmp HOoABCDpMtmp Hincl); apply HT.
}

assert(HOoAApDpM : rk(Oo :: A :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDpm : rk(Oo :: A :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoAApDpeq HOoAApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDp requis par la preuve de (?)OoBCApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpm4 : rk(Oo :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) = 4) by (apply LOoABCApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApDpM : rk(Oo :: B :: C :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDpm : rk(Oo :: B :: C :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCApDpeq HOoBCApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpDp requis par la preuve de (?)BpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Dp ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBpDpm2 : rk(Bp :: Dp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HApBpDpmtmp : rk(Ap :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HApBpDpeq HApBpDpm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: nil) (Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Bp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpDpmtmp;try rewrite HT2 in HApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Bp :: Dp :: nil) (Bp :: nil) 3 1 2 HApBpDpmtmp HBpmtmp HApBpMtmp Hincl); apply HT.
}

assert(HBpDpM : rk(Bp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpDpeq HBpDpM2).
assert(HBpDpm : rk(Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HBpDpeq HBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpDp requis par la preuve de (?)OoBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpDp requis par la preuve de (?)OoBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpDpm2 : rk(Oo :: B :: Bp :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApBpDpeq HOoBCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpDpmtmp;try rewrite HT2 in HOoBCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoBCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpDpM3 : rk(Oo :: B :: Bp :: Dp :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Dp :: nil) (nil) 2 1 0 HOoBBpMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpDp requis par la preuve de (?)OoBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: Dp ::  de rang :  2 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpDpm2 : rk(Oo :: Bp :: Dp :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpDpmtmp : rk(Oo :: B :: Bp :: Dp :: nil) >= 2) by (solve_hyps_min HOoBBpDpeq HOoBBpDpm2).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpDpmtmp;try rewrite HT2 in HOoBBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: Dp :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpDpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpDpm3 : rk(Oo :: Bp :: Dp :: nil) >= 3).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HOoApBpDpmtmp : rk(Oo :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApBpDpeq HOoApBpDpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: nil) (Oo :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: Dp :: nil) (Ap :: Bp :: Oo :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Oo :: Bp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Oo :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApBpDpmtmp;try rewrite HT2 in HOoApBpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Oo :: Bp :: Dp :: nil) (Bp :: nil) 4 1 2 HOoApBpDpmtmp HBpmtmp HApBpMtmp Hincl); apply HT.
}

assert(HOoBpDpM : rk(Oo :: Bp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpDpeq HOoBpDpM3).
assert(HOoBpDpm : rk(Oo :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBpDpeq HOoBpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpDp *)
(* dans constructLemma(), requis par LOoABBpDp *)
(* dans la couche 0 *)
Lemma LOoABCBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDp requis par la preuve de (?)OoABCBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDpm4 : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDpM : rk(Oo :: A :: B :: C :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDpm : rk(Oo :: A :: B :: C :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDpm2 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDpm3 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: Dp ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoABBpDpm4 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	assert(HOoABCBpDpeq : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) = 4) by (apply LOoABCBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpDpmtmp : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm4).
	assert(HOoABDpeq : rk(Oo :: A :: B :: Dp :: nil) = 4) by (apply LOoABDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDpmtmp : rk(Oo :: A :: B :: Dp :: nil) >= 4) by (solve_hyps_min HOoABDpeq HOoABDpm4).
	assert(Hincl : incl (Oo :: A :: B :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: A :: B :: Bp :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDpmtmp;try rewrite HT2 in HOoABCBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: A :: B :: Dp :: nil) 4 4 4 HOoABCBpDpmtmp HOoABDpmtmp HOoABCDpMtmp Hincl); apply HT.
}

assert(HOoABBpDpM : rk(Oo :: A :: B :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpDpm : rk(Oo :: A :: B :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpDp *)
(* dans la couche 0 *)
Lemma LOoBBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDp requis par la preuve de (?)OoBBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpDpm2 : rk(Oo :: B :: Bp :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCApBpDpeq HOoBCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpDpmtmp;try rewrite HT2 in HOoBCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoBCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpDpM3 : rk(Oo :: B :: Bp :: Dp :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Dp :: nil) (nil) 2 1 0 HOoBBpMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: B :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoBBpDpm3 : rk(Oo :: B :: Bp :: Dp :: nil) >= 3).
{
	assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	assert(HOoABCBpDpeq : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) = 4) by (apply LOoABCBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpDpmtmp : rk(Oo :: A :: B :: C :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDpeq HOoABCBpDpm4).
	assert(HOoBDpeq : rk(Oo :: B :: Dp :: nil) = 3) by (apply LOoBDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDpmtmp : rk(Oo :: B :: Dp :: nil) >= 3) by (solve_hyps_min HOoBDpeq HOoBDpm3).
	assert(Hincl : incl (Oo :: B :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: B :: Bp :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDpmtmp;try rewrite HT2 in HOoABCBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil) (Oo :: B :: Dp :: nil) 4 3 4 HOoABCBpDpmtmp HOoBDpmtmp HOoABCDpMtmp Hincl); apply HT.
}

assert(HOoBBpDpM : rk(Oo :: B :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpDpm : rk(Oo :: B :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBBpDpeq HOoBBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDp requis par la preuve de (?)OoABpDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDp requis par la preuve de (?)OoABBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDpm2 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: Dp :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) (nil) 4 0 2 HOoABCApBpDpmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDpm3 : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: Dp :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDp requis par la preuve de (?)OoABpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpDpm3 : rk(Oo :: A :: Bp :: Dp :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDpmtmp : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDpmtmp;try rewrite HT2 in HOoABBpDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: Dp :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpDpmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpDpm4 : rk(Oo :: A :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoABBpDpeq : rk(Oo :: A :: B :: Bp :: Dp :: nil) = 4) by (apply LOoABBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpDpmtmp : rk(Oo :: A :: B :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABBpDpeq HOoABBpDpm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: A :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: Dp :: nil) (Oo :: A :: Bp :: Dp :: Oo :: B :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: Dp :: Oo :: B :: Bp :: Dp :: nil) ((Oo :: A :: Bp :: Dp :: nil) ++ (Oo :: B :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDpmtmp;try rewrite HT2 in HOoABBpDpmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: Dp :: nil) (Oo :: B :: Bp :: Dp :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoABBpDpmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl);apply HT.
}

assert(HOoABpDpM : rk(Oo :: A :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDpm : rk(Oo :: A :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABpDpeq HOoABpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpDp *)
(* dans la couche 0 *)
Lemma LOoABCApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDp requis par la preuve de (?)OoBCApBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDpm4 : rk(Oo :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) = 4) by (apply LOoABCApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpDpM : rk(Oo :: B :: C :: Ap :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpDpm : rk(Oo :: B :: C :: Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCApBpDpeq HOoBCApBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpDp requis par la preuve de (?)CpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -1 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCpDpm2 : rk(Cp :: Dp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HApBpCpDpmtmp : rk(Ap :: Bp :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) (Ap :: Bp :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpDpmtmp;try rewrite HT2 in HApBpCpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Cp :: Dp :: nil) (nil) 4 0 2 HApBpCpDpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}

assert(HCpDpM : rk(Cp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpDpeq HCpDpM2).
assert(HCpDpm : rk(Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HCpDpeq HCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpDp requis par la preuve de (?)OoCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpDp requis par la preuve de (?)OoCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpDpm2 : rk(Oo :: Cp :: Dp :: nil) >= 2).
{
	assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: Dp :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Ap :: Cp ::   de rang : 2 et 2 *)
assert(HOoCpDpm3 : rk(Oo :: Cp :: Dp :: nil) >= 3).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpMtmp : rk(Ap :: Cp :: nil) <= 2) by (solve_hyps_max HApCpeq HApCpM2).
	assert(HOoApCpDpmtmp : rk(Oo :: Ap :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoApCpDpeq HOoApCpDpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Ap :: Cp :: nil) (Oo :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: Dp :: nil) (Ap :: Cp :: Oo :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: Oo :: Cp :: Dp :: nil) ((Ap :: Cp :: nil) ++ (Oo :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpDpmtmp;try rewrite HT2 in HOoApCpDpmtmp.
	assert(HT := rule_4 (Ap :: Cp :: nil) (Oo :: Cp :: Dp :: nil) (Cp :: nil) 4 1 2 HOoApCpDpmtmp HCpmtmp HApCpMtmp Hincl); apply HT.
}

assert(HOoCpDpM : rk(Oo :: Cp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpDpeq HOoCpDpM3).
assert(HOoCpDpm : rk(Oo :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCpDpeq HOoCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCCpDp *)
(* dans la couche 0 *)
Lemma LOoABCCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDp requis par la preuve de (?)OoABCCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDpm4 : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpDpM : rk(Oo :: A :: B :: C :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDpm : rk(Oo :: A :: B :: C :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCCpDpeq HOoABCCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpDp requis par la preuve de (?)OoCCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpDp requis par la preuve de (?)OoCCpDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoCCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoABCApCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpDp requis par la preuve de (?)OoCCpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpDpm2 : rk(Oo :: C :: Cp :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDpeq HOoABCApCpDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDpmtmp;try rewrite HT2 in HOoABCApCpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoCCpDpM3 : rk(Oo :: C :: Cp :: Dp :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: Dp :: nil) (Oo :: C :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (Dp :: nil) (nil) 2 1 0 HOoCCpMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: C :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HOoCCpDpm3 : rk(Oo :: C :: Cp :: Dp :: nil) >= 3).
{
	assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	assert(HOoABCCpDpeq : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) = 4) by (apply LOoABCCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpDpmtmp : rk(Oo :: A :: B :: C :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCCpDpeq HOoABCCpDpm4).
	assert(HOoCDpeq : rk(Oo :: C :: Dp :: nil) = 3) by (apply LOoCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDpmtmp : rk(Oo :: C :: Dp :: nil) >= 3) by (solve_hyps_min HOoCDpeq HOoCDpm3).
	assert(Hincl : incl (Oo :: C :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (Oo :: C :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: Oo :: C :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: Oo :: C :: Cp :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (Oo :: C :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDpmtmp;try rewrite HT2 in HOoABCCpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (Oo :: C :: Cp :: Dp :: nil) (Oo :: C :: Dp :: nil) 4 3 4 HOoABCCpDpmtmp HOoCDpmtmp HOoABCDpMtmp Hincl); apply HT.
}

assert(HOoCCpDpM : rk(Oo :: C :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpDpm : rk(Oo :: C :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCCpDpeq HOoCCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoABCApCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpDpM : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDpm : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDpeq HOoABCApCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour DDp requis par la preuve de (?)DDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: D :: Dp ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: B :: D ::   de rang : 3 et 3 *)
assert(HDDpm2 : rk(D :: Dp :: nil) >= 2).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 3) by (solve_hyps_max HABDeq HABDM3).
	assert(HABDDpmtmp : rk(A :: B :: D :: Dp :: nil) >= 4) by (solve_hyps_min HABDDpeq HABDDpm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: B :: D :: nil) (D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: Dp :: nil) (A :: B :: D :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: D :: Dp :: nil) ((A :: B :: D :: nil) ++ (D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDDpmtmp;try rewrite HT2 in HABDDpmtmp.
	assert(HT := rule_4 (A :: B :: D :: nil) (D :: Dp :: nil) (D :: nil) 4 1 3 HABDDpmtmp HDmtmp HABDMtmp Hincl); apply HT.
}

assert(HDDpM : rk(D :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDDpeq HDDpM2).
assert(HDDpm : rk(D :: Dp ::  nil) >= 1) by (solve_hyps_min HDDpeq HDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApDDp *)
(* dans la couche 0 *)
Lemma LOoABCApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDp requis par la preuve de (?)OoBCApDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpeq : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) = 4) by (apply LOoABCApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApDDpmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApDDpM : rk(Oo :: B :: C :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDDpm : rk(Oo :: B :: C :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCApDDpeq HOoBCApDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoABCBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDDpM : rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDDpm : rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCBpDDpeq HOoABCBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABCCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDDpm4 : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpDDpM : rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDDpm : rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCCpDDpeq HOoABCCpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAad *)
(* dans constructLemma(), requis par LAApDpad *)
(* dans la couche 0 *)
Lemma LOoAApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDpad requis par la preuve de (?)OoAApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApDpad requis par la preuve de (?)OoAApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDpad requis par la preuve de (?)OoAApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoAApDpadM3 : rk(Oo :: A :: Ap :: Dp :: ad :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Ap :: Dp :: ad :: nil) (Ap :: nil) 2 2 1 HOoAApMtmp HApDpadMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDpadm2 : rk(Oo :: A :: Ap :: Dp :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDpadm3 : rk(Oo :: A :: Ap :: Dp :: ad :: nil) >= 3).
{
	assert(HOoADpeq : rk(Oo :: A :: Dp :: nil) = 3) by (apply LOoADp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADpmtmp : rk(Oo :: A :: Dp :: nil) >= 3) by (solve_hyps_min HOoADpeq HOoADpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Dp :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Dp :: nil) (Oo :: A :: Ap :: Dp :: ad :: nil) 3 3 HOoADpmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApDpadM : rk(Oo :: A :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDpadm : rk(Oo :: A :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApDpadeq HOoAApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)AApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpad requis par la preuve de (?)OoABCApDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDpadm3 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDpadm4 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApDpadM3 : rk(A :: Ap :: Dp :: ad :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Dp :: ad :: nil) ((A :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HAMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApDpadm2 : rk(A :: Ap :: Dp :: ad :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApDpadmtmp : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HABCApDpadeq HABCApDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Dp :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Dp :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDpadmtmp;try rewrite HT2 in HABCApDpadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil) (Ap :: nil) 4 1 3 HABCApDpadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Dp :: ad ::  de rang :  3 et 3 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HAApDpadm3 : rk(A :: Ap :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoAApDpadeq : rk(Oo :: A :: Ap :: Dp :: ad :: nil) = 3) by (apply LOoAApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpadmtmp : rk(Oo :: A :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoAApDpadeq HOoAApDpadm3).
	assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApDpadmtmp;try rewrite HT2 in HOoAApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil) (A :: Ap :: nil) 3 2 2 HOoAApDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HAApDpadM : rk(A :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDpadm : rk(A :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HAApDpadeq HAApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aad requis par la preuve de (?)Aad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAadm2 : rk(A :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HAApDpadeq : rk(A :: Ap :: Dp :: ad :: nil) = 3) by (apply LAApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDpadmtmp : rk(A :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HAApDpadeq HAApDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (A :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ad :: Ap :: Dp :: ad :: nil) ((A :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDpadmtmp;try rewrite HT2 in HAApDpadmtmp.
	assert(HT := rule_2 (A :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HAApDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HAadM : rk(A :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAadeq HAadM2).
assert(HAadm : rk(A :: ad ::  nil) >= 1) by (solve_hyps_min HAadeq HAadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAad *)
(* dans la couche 0 *)
Lemma LOoADad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDadm2 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) (nil) 4 0 2 HOoABCApBpDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDadm3 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADad requis par la preuve de (?)OoADad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoADadM3 : rk(Oo :: A :: D :: ad :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: ad :: nil) ((Oo :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HOoMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: ad ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoADadm2 : rk(Oo :: A :: D :: ad :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDadmtmp : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpDadeq HOoABBpDadm3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: D :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDadmtmp;try rewrite HT2 in HOoABBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: D :: ad :: nil) (Oo :: nil) 3 1 2 HOoABBpDadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADadm3 : rk(Oo :: A :: D :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoADadM : rk(Oo :: A :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADadm : rk(Oo :: A :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoADadeq HOoADadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAad requis par la preuve de (?)OoAad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoAad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoABCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAad requis par la preuve de (?)OoAad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: ad ::  de rang :  3 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoAadm2 : rk(Oo :: A :: ad :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpadeq HOoABBpadm3).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: ad :: nil) (Oo :: nil) 3 1 2 HOoABBpadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoAadm3 : rk(Oo :: A :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoADadeq : rk(Oo :: A :: D :: ad :: nil) = 3) by (apply LOoADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADadmtmp : rk(Oo :: A :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoADadeq HOoADadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: A :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: ad :: A :: D :: ad :: nil) ((Oo :: A :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoADadmtmp;try rewrite HT2 in HOoADadmtmp.
	assert(HT := rule_2 (Oo :: A :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HOoADadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoAadM : rk(Oo :: A :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAadeq HOoAadM3).
assert(HOoAadm : rk(Oo :: A :: ad ::  nil) >= 1) by (solve_hyps_min HOoAadeq HOoAadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBad *)
(* dans la couche 0 *)
Lemma LOoABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABDadm2 : rk(Oo :: A :: B :: D :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (C :: Ap :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: D :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil) (nil) 4 0 2 HOoABCApDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDadm3 : rk(Oo :: A :: B :: D :: ad :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDadmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDadmtmp;try rewrite HT2 in HOoABCCpDadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpDadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABDadm4 : rk(Oo :: A :: B :: D :: ad :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABDadM : rk(Oo :: A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDadm : rk(Oo :: A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABDadeq HOoABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApad requis par la preuve de (?)OoBad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoBCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApad requis par la preuve de (?)OoBCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApadm4 : rk(Oo :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBadm2 : rk(Oo :: B :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApadmtmp : rk(Oo :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApadeq HOoBCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: ad :: nil) (C :: Ap :: Oo :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApadmtmp;try rewrite HT2 in HOoBCApadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: ad :: nil) (nil) 4 0 2 HOoBCApadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoBadm3 : rk(Oo :: B :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: ad :: A :: D :: ad :: nil) ((Oo :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: B :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoABDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoBadM : rk(Oo :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBadeq HOoBadM3).
assert(HOoBadm : rk(Oo :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoBadeq HOoBadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABad *)
(* dans la couche 0 *)
Lemma LABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDadm3 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDadm4 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDad requis par la preuve de (?)ABDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDadM3 : rk(A :: B :: D :: ad :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (B :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: D :: ad :: nil) ((B :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HBMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDadm2 : rk(A :: B :: D :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDadmtmp : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApDadeq HABCApDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: ad :: nil) (C :: Ap :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDadmtmp;try rewrite HT2 in HABCApDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: ad :: nil) (nil) 4 0 2 HABCApDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadm3 : rk(A :: B :: D :: ad :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: ad :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABDadM : rk(A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDadm : rk(A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABDadeq HABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApadm3 : rk(A :: B :: C :: Ap :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApadm4 : rk(A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABadm2 : rk(A :: B :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApadmtmp : rk(A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HABCApadeq HABCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ad :: nil) (C :: Ap :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApadmtmp;try rewrite HT2 in HABCApadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ad :: nil) (nil) 4 0 2 HABCApadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABadm3 : rk(A :: B :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABDadeq : rk(A :: B :: D :: ad :: nil) = 3) by (apply LABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDadmtmp : rk(A :: B :: D :: ad :: nil) >= 3) by (solve_hyps_min HABDadeq HABDadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ad :: A :: D :: ad :: nil) ((A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDadmtmp;try rewrite HT2 in HABDadmtmp.
	assert(HT := rule_2 (A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HABadM : rk(A :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABadeq HABadM3).
assert(HABadm : rk(A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HABadeq HABadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABadm2 : rk(Oo :: A :: B :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (C :: Ap :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: ad :: nil) (nil) 4 0 2 HOoABCApadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABadm3 : rk(Oo :: A :: B :: ad :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoABadm4 : rk(Oo :: A :: B :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ad :: A :: D :: ad :: nil) ((Oo :: A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HOoABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoABadM : rk(Oo :: A :: B :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABadm : rk(Oo :: A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoABadeq HOoABadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACad *)
(* dans la couche 0 *)
Lemma LACDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDad requis par la preuve de (?)ACDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDad requis par la preuve de (?)ACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDad requis par la preuve de (?)ACDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDadM3 : rk(A :: C :: D :: ad :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: ad :: nil) (C :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: D :: ad :: nil) ((C :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HCMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACDadm2 : rk(A :: C :: D :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: ad :: nil) (A :: nil) 4 1 3 HOoABCApDadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDadm3 : rk(A :: C :: D :: ad :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: D :: ad :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACDadM : rk(A :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACDadm : rk(A :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HACDadeq HACDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACad requis par la preuve de (?)ACad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACad requis par la preuve de (?)ACad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACadm2 : rk(A :: C :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ad :: nil) (A :: nil) 4 1 3 HOoABCApadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HACadm3 : rk(A :: C :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACDadeq : rk(A :: C :: D :: ad :: nil) = 3) by (apply LACDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDadmtmp : rk(A :: C :: D :: ad :: nil) >= 3) by (solve_hyps_min HACDadeq HACDadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: ad :: nil) (A :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ad :: A :: D :: ad :: nil) ((A :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDadmtmp;try rewrite HT2 in HACDadmtmp.
	assert(HT := rule_2 (A :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HACDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HACadM : rk(A :: C :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACadeq HACadM3).
assert(HACadm : rk(A :: C :: ad ::  nil) >= 1) by (solve_hyps_min HACadeq HACadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCad *)
(* dans la couche 0 *)
Lemma LABCDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCDad requis par la preuve de (?)ABCDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ABCDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDad requis par la preuve de (?)ABCDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCDadm3 : rk(A :: B :: C :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: ad :: nil) (A :: nil) 4 1 2 HOoABCApDadmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDadm4 : rk(A :: B :: C :: D :: ad :: nil) >= 4).
{
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (A :: B :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: nil) (A :: B :: C :: D :: ad :: nil) 4 4 HABCDmtmp Hcomp Hincl);apply HT.
}

assert(HABCDadM : rk(A :: B :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCDadm : rk(A :: B :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCDadeq HABCDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCad requis par la preuve de (?)ABCad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ABCad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCad requis par la preuve de (?)ABCad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCadm3 : rk(A :: B :: C :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ad :: nil) (A :: nil) 4 1 2 HOoABCApadmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABCadm4 : rk(A :: B :: C :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABCDadeq : rk(A :: B :: C :: D :: ad :: nil) = 4) by (apply LABCDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCDadmtmp : rk(A :: B :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCDadeq HABCDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: B :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: ad :: nil) (A :: B :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: ad :: A :: D :: ad :: nil) ((A :: B :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDadmtmp;try rewrite HT2 in HABCDadmtmp.
	assert(HT := rule_2 (A :: B :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HABCDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HABCadM : rk(A :: B :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCadm : rk(A :: B :: C :: ad ::  nil) >= 1) by (solve_hyps_min HABCadeq HABCadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCad requis par la preuve de (?)OoABCad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCadm4 : rk(Oo :: A :: B :: C :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCadM : rk(Oo :: A :: B :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCadm : rk(Oo :: A :: B :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCadeq HOoABCadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApad *)
(* dans constructLemma(), requis par LAApDad *)
(* dans la couche 0 *)
Lemma LOoAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoAApDadM3 : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HOoAApMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDadm2 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDadm3 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApDadM : rk(Oo :: A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDadm : rk(Oo :: A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApDadeq HOoAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDad requis par la preuve de (?)AApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDadm3 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDadm4 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDad requis par la preuve de (?)AApDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApDadM3 : rk(A :: Ap :: D :: ad :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: D :: ad :: nil) ((Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HApMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApDadm2 : rk(A :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApDadmtmp : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApDadeq HABCApDadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: ad :: nil) (B :: C :: Ap :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: D :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDadmtmp;try rewrite HT2 in HABCApDadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: D :: ad :: nil) (Ap :: nil) 4 1 3 HABCApDadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: D :: ad ::  de rang :  3 et 3 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HAApDadm3 : rk(A :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDadmtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoAApDadeq HOoAApDadm3).
	assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApDadmtmp;try rewrite HT2 in HOoAApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 3 2 2 HOoAApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HAApDadM : rk(A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDadm : rk(A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAApDadeq HAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apad requis par la preuve de (?)Apad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HApadm2 : rk(Ap :: ad :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAApDadeq : rk(A :: Ap :: D :: ad :: nil) = 3) by (apply LAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDadmtmp : rk(A :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HAApDadeq HAApDadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Ap :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (Ap :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ad :: A :: D :: ad :: nil) ((Ap :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDadmtmp;try rewrite HT2 in HAApDadmtmp.
	assert(HT := rule_2 (Ap :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HAApDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HApadM : rk(Ap :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApadeq HApadM2).
assert(HApadm : rk(Ap :: ad ::  nil) >= 1) by (solve_hyps_min HApadeq HApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApad *)
(* dans la couche 0 *)
Lemma LOoApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApDpad requis par la preuve de (?)OoApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApDpad requis par la preuve de (?)OoApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApDpad requis par la preuve de (?)OoApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoApDpadM3 : rk(Oo :: Ap :: Dp :: ad :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Dp :: ad :: nil) (Oo :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Dp :: ad :: nil) ((Oo :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HOoMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApDpadm2 : rk(Oo :: Ap :: Dp :: ad :: nil) >= 2).
{
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: nil) (Oo :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: nil) (Oo :: Ap :: Dp :: ad :: nil) 2 2 HOoApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApDpadm3 : rk(Oo :: Ap :: Dp :: ad :: nil) >= 3).
{
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: Dp :: ad :: nil) 3 3 HOoApDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoApDpadM : rk(Oo :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApDpadm : rk(Oo :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoApDpadeq HOoApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApad requis par la preuve de (?)OoApad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm2 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApadm3 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApad requis par la preuve de (?)OoApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApadm2 : rk(Oo :: Ap :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadmtmp : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoABApadeq HOoABApadm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadmtmp;try rewrite HT2 in HOoABApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ad :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApadmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoApadm3 : rk(Oo :: Ap :: ad :: nil) >= 3).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HOoApDpadeq : rk(Oo :: Ap :: Dp :: ad :: nil) = 3) by (apply LOoApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpadmtmp : rk(Oo :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoApDpadeq HOoApDpadm3).
	assert(HApadeq : rk(Ap :: ad :: nil) = 2) by (apply LApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApadmtmp : rk(Ap :: ad :: nil) >= 2) by (solve_hyps_min HApadeq HApadm2).
	assert(Hincl : incl (Ap :: ad :: nil) (list_inter (Oo :: Ap :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Dp :: ad :: nil) (Oo :: Ap :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: ad :: Ap :: Dp :: ad :: nil) ((Oo :: Ap :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApDpadmtmp;try rewrite HT2 in HOoApDpadmtmp.
	assert(HT := rule_2 (Oo :: Ap :: ad :: nil) (Ap :: Dp :: ad :: nil) (Ap :: ad :: nil) 3 2 2 HOoApDpadmtmp HApadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HOoApadM : rk(Oo :: Ap :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApadeq HOoApadM3).
assert(HOoApadm : rk(Oo :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoApadeq HOoApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAApad *)
(* dans la couche 0 *)
Lemma LOoABCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApadM : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApadm : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApadeq HOoABCApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApad requis par la preuve de (?)OoAApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAApad requis par la preuve de (?)OoAApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApad requis par la preuve de (?)OoAApad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApadM3 : rk(Oo :: A :: Ap :: ad :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: ad :: nil) (Oo :: A :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (ad :: nil) (nil) 2 1 0 HOoAApMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApadm2 : rk(Oo :: A :: Ap :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoAApadm3 : rk(Oo :: A :: Ap :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HOoAadeq : rk(Oo :: A :: ad :: nil) = 3) by (apply LOoAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAadmtmp : rk(Oo :: A :: ad :: nil) >= 3) by (solve_hyps_min HOoAadeq HOoAadm3).
	assert(Hincl : incl (Oo :: A :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: Ap :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: Ap :: ad :: nil) (Oo :: A :: ad :: nil) 4 3 4 HOoABCApadmtmp HOoAadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoAApadM : rk(Oo :: A :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApadm : rk(Oo :: A :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApadeq HOoAApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApad requis par la preuve de (?)OoBCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApadm4 : rk(Oo :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApadM : rk(Oo :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApadm : rk(Oo :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoBCApadeq HOoBCApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApadm3 : rk(A :: B :: C :: Ap :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApadm4 : rk(A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApadM : rk(A :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApadm : rk(A :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HABCApadeq HABCApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpad *)
(* dans constructLemma(), requis par LABpDad *)
(* dans la couche 0 *)
Lemma LOoABpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDDpad requis par la preuve de (?)OoABBpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpad requis par la preuve de (?)OoABBpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpad requis par la preuve de (?)OoABCApBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDDpad requis par la preuve de (?)OoABBpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDDpadm2 : rk(Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpadeq HOoABCApBpDDpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpadmtmp;try rewrite HT2 in HOoABCApBpDDpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) (nil) 4 0 2 HOoABCApBpDDpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDDpadm3 : rk(Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: Dp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpDDpadm3 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDDpadmtmp : rk(Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpDDpadeq HOoABBpDDpadm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: Dp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: Dp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDDpadmtmp;try rewrite HT2 in HOoABBpDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpDDpadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpDDpadm4 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABpDpeq : rk(Oo :: A :: Bp :: Dp :: nil) = 4) by (apply LOoABpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpDpmtmp : rk(Oo :: A :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABpDpeq HOoABpDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABpDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABpDDpadM : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDDpadm : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpDad requis par la preuve de (?)ABpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpDad requis par la preuve de (?)ABpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpDad requis par la preuve de (?)ABpDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABpDadM3 : rk(A :: Bp :: D :: ad :: nil) <= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: D :: ad :: nil) (Bp :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: D :: ad :: nil) ((Bp :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HBpMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDadm2 : rk(A :: Bp :: D :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: D :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HABpDadm3 : rk(A :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoABpDDpadeq : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpDDpadmtmp : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: Dp :: nil) (A :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: A :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: A :: Bp :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (A :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDDpadmtmp;try rewrite HT2 in HOoABpDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (A :: Bp :: D :: ad :: nil) (D :: nil) 4 1 2 HOoABpDDpadmtmp HDmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HABpDadM : rk(A :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpDadm : rk(A :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABpDadeq HABpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bpad requis par la preuve de (?)Bpad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBpadm2 : rk(Bp :: ad :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABpDadeq : rk(A :: Bp :: D :: ad :: nil) = 3) by (apply LABpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpDadmtmp : rk(A :: Bp :: D :: ad :: nil) >= 3) by (solve_hyps_min HABpDadeq HABpDadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Bp :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: D :: ad :: nil) (Bp :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: ad :: A :: D :: ad :: nil) ((Bp :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpDadmtmp;try rewrite HT2 in HABpDadmtmp.
	assert(HT := rule_2 (Bp :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HABpDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HBpadM : rk(Bp :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpadeq HBpadM2).
assert(HBpadm : rk(Bp :: ad ::  nil) >= 1) by (solve_hyps_min HBpadeq HBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpad *)
(* dans la couche 0 *)
Lemma LOoABpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDad requis par la preuve de (?)OoABpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDad requis par la preuve de (?)OoABBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpDadm2 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: D :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) (nil) 4 0 2 HOoABCApBpDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpDadm3 : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDad requis par la preuve de (?)OoABpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: D :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpDadm3 : rk(Oo :: A :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpDadmtmp : rk(Oo :: A :: B :: Bp :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpDadeq HOoABBpDadm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: D :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDadmtmp;try rewrite HT2 in HOoABBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: D :: ad :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpDadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: D ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HOoABpDadm4 : rk(Oo :: A :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoABpDDpadeq : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpDDpadmtmp : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm4).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Oo :: A :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Oo :: A :: Bp :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Oo :: A :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDDpadmtmp;try rewrite HT2 in HOoABpDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: ad :: nil) (Oo :: D :: nil) 4 2 2 HOoABpDDpadmtmp HOoDmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HOoABpDadM : rk(Oo :: A :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDadm : rk(Oo :: A :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpDadeq HOoABpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpadm4 : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpadm2 : rk(Oo :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpadmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApBpadeq HOoBCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpadmtmp;try rewrite HT2 in HOoBCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoBCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpadM3 : rk(Oo :: B :: Bp :: ad :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (ad :: nil) (nil) 2 1 0 HOoBBpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: ad ::  de rang :  2 et 3 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpadm2 : rk(Oo :: Bp :: ad :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpadmtmp : rk(Oo :: B :: Bp :: ad :: nil) >= 2) by (solve_hyps_min HOoBBpadeq HOoBBpadm2).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpadmtmp;try rewrite HT2 in HOoBBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: ad :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoBpadm3 : rk(Oo :: Bp :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoABpDadeq : rk(Oo :: A :: Bp :: D :: ad :: nil) = 4) by (apply LOoABpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpDadmtmp : rk(Oo :: A :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDadeq HOoABpDadm4).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: Bp :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: ad :: nil) (Oo :: Bp :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: ad :: A :: D :: ad :: nil) ((Oo :: Bp :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDadmtmp;try rewrite HT2 in HOoABpDadmtmp.
	assert(HT := rule_2 (Oo :: Bp :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoABpDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoBpadM : rk(Oo :: Bp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpadeq HOoBpadM3).
assert(HOoBpadm : rk(Oo :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBpadeq HOoBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans constructLemma(), requis par LOoABBpad *)
(* dans la couche 0 *)
Lemma LOoABCBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoABCBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpadm4 : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpadM : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpadm : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoABCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoABBpadm4 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOoABadeq : rk(Oo :: A :: B :: ad :: nil) = 4) by (apply LOoABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABadmtmp : rk(Oo :: A :: B :: ad :: nil) >= 4) by (solve_hyps_min HOoABadeq HOoABadm4).
	assert(Hincl : incl (Oo :: A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: B :: ad :: nil) 4 4 4 HOoABCBpadmtmp HOoABadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoABBpadM : rk(Oo :: A :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpadm : rk(Oo :: A :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABBpadeq HOoABBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans la couche 0 *)
Lemma LOoBBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpadm4 : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpadm2 : rk(Oo :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpadmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApBpadeq HOoBCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpadmtmp;try rewrite HT2 in HOoBCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoBCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpadM3 : rk(Oo :: B :: Bp :: ad :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (ad :: nil) (nil) 2 1 0 HOoBBpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoBBpadm3 : rk(Oo :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOoBadeq : rk(Oo :: B :: ad :: nil) = 3) by (apply LOoBad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBadmtmp : rk(Oo :: B :: ad :: nil) >= 3) by (solve_hyps_min HOoBadeq HOoBadm3).
	assert(Hincl : incl (Oo :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: ad :: nil) 4 3 4 HOoABCBpadmtmp HOoBadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoBBpadM : rk(Oo :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpadm : rk(Oo :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBBpadeq HOoBBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((C :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (nil) 4 0 2 HOoABCApBpadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Bp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoABpadm3 : rk(Oo :: A :: Bp :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoABBpadeq HOoABBpadm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil) (Oo :: Bp :: nil) 3 2 2 HOoABBpadmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpadm4 : rk(Oo :: A :: Bp :: ad :: nil) >= 4).
{
	assert(HOoBBpadeq : rk(Oo :: B :: Bp :: ad :: nil) = 3) by (apply LOoBBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpadMtmp : rk(Oo :: B :: Bp :: ad :: nil) <= 3) by (solve_hyps_max HOoBBpadeq HOoBBpadM3).
	assert(HOoABBpadeq : rk(Oo :: A :: B :: Bp :: ad :: nil) = 4) by (apply LOoABBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABBpadeq HOoABBpadm4).
	assert(HOoBpadeq : rk(Oo :: Bp :: ad :: nil) = 3) by (apply LOoBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpadmtmp : rk(Oo :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoBpadeq HOoBpadm3).
	assert(Hincl : incl (Oo :: Bp :: ad :: nil) (list_inter (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: Bp :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: Bp :: ad :: nil) 4 3 3 HOoABBpadmtmp HOoBpadmtmp HOoBBpadMtmp Hincl);apply HT.
}

assert(HOoABpadM : rk(Oo :: A :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpadm : rk(Oo :: A :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpadeq HOoABpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApBpad *)
(* dans constructLemma(), requis par LAApBpDad *)
(* dans constructLemma(), requis par LOoAApBpDad *)
(* dans la couche 0 *)
Lemma LOoAApBpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpDDpad requis par la preuve de (?)OoAApBpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpDDpad requis par la preuve de (?)OoAApBpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpDDpad requis par la preuve de (?)OoAApBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpDDpadm2 : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDDpadm3 : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDDpadm4 : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABpDpeq : rk(Oo :: A :: Bp :: Dp :: nil) = 4) by (apply LOoABpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpDpmtmp : rk(Oo :: A :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABpDpeq HOoABpDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABpDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpDDpadM : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpDDpadm : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpDDpadeq HOoAApBpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpDadm2 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDadm3 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: D ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HOoAApBpDadm4 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoAApBpDDpadeq : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoAApBpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpDDpadmtmp : rk(Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpDDpadeq HOoAApBpDDpadm4).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: D :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Oo :: A :: Ap :: Bp :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Oo :: A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpDDpadmtmp;try rewrite HT2 in HOoAApBpDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) (Oo :: D :: nil) 4 2 2 HOoAApBpDDpadmtmp HOoDmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HOoAApBpDadM : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpDadm : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpabDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDad requis par la preuve de (?)ABApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDad requis par la preuve de (?)OoABApBpabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDad requis par la preuve de (?)OoABApBpabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpabDad requis par la preuve de (?)ABApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApBpabDadm3 : rk(A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabDadeq HOoABApBpabDadm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDadmtmp;try rewrite HT2 in HOoABApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApBpabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDad requis par la preuve de (?)OoABCApBpabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabDadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabDadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpabDad requis par la preuve de (?)AApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpabDadm2 : rk(A :: Ap :: Bp :: ab :: D :: ad :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpabDadmtmp : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpabDadeq HABCApBpabDadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ab :: D :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpabDadmtmp;try rewrite HT2 in HABCApBpabDadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpabDadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApBpabDadm3 : rk(A :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApBpabDadmtmp : rk(A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HABApBpabDadeq HABApBpabDadm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Bp :: ab :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpabDadmtmp;try rewrite HT2 in HABApBpabDadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: ab :: nil) 3 2 2 HABApBpabDadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpDadm3 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpDadm4 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpDad requis par la preuve de (?)AApBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpDadm2 : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpDadmtmp : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpDadeq HABCApBpDadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: D :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpDadmtmp;try rewrite HT2 in HABCApBpDadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpDadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: ab ::   de rang : 2 et 2 *)
assert(HAApBpDadm3 : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HAApBpabDadmtmp : rk(A :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HAApBpabDadeq HAApBpabDadm3).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: D :: ad :: nil) (Ap :: Bp :: ab :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: A :: Ap :: Bp :: D :: ad :: nil) ((Ap :: Bp :: ab :: nil) ++ (A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabDadmtmp;try rewrite HT2 in HAApBpabDadmtmp.
	assert(HT := rule_4 (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: D :: ad :: nil) (Ap :: Bp :: nil) 3 2 2 HAApBpabDadmtmp HApBpmtmp HApBpabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HAApBpDadm4 : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoAApBpDadeq : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoAApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpDadmtmp : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm4).
	assert(HAApeq : rk(A :: Ap :: nil) = 2) by (apply LAAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: Ap :: A :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpDadmtmp;try rewrite HT2 in HOoAApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoAApBpDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HAApBpDadM : rk(A :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpDadm : rk(A :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpDadeq HAApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApBpabadm3 : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)OoABCApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpabadm2 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpabadmtmp : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpabadeq HABCApBpabadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpabadmtmp;try rewrite HT2 in HABCApBpabadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpabadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApBpabadm3 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApBpabadmtmp : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HABApBpabadeq HABApBpabadm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpabadmtmp;try rewrite HT2 in HABApBpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (A :: ab :: nil) 3 2 2 HABApBpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpadm3 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpadm4 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpadm2 : rk(A :: Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpadmtmp : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpadeq HABCApBpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpadmtmp;try rewrite HT2 in HABCApBpadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : Ap :: Bp :: ab ::   de rang : 2 et 2 *)
assert(HAApBpadm3 : rk(A :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HAApBpabadmtmp : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAApBpabadeq HAApBpabadm3).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: ad :: nil) (Ap :: Bp :: ab :: A :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: A :: Ap :: Bp :: ad :: nil) ((Ap :: Bp :: ab :: nil) ++ (A :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabadmtmp;try rewrite HT2 in HAApBpabadmtmp.
	assert(HT := rule_4 (Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: ad :: nil) (Ap :: Bp :: nil) 3 2 2 HAApBpabadmtmp HApBpmtmp HApBpabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAApBpadm4 : rk(A :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAApBpDadeq : rk(A :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LAApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpDadmtmp : rk(A :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HAApBpDadeq HAApBpDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: Ap :: Bp :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: Bp :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: ad :: A :: D :: ad :: nil) ((A :: Ap :: Bp :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpDadmtmp;try rewrite HT2 in HAApBpDadmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HAApBpDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HAApBpadM : rk(A :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpadm : rk(A :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpadeq HAApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpadm2 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpadm3 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpadm4 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpadM : rk(Oo :: A :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpadm : rk(Oo :: A :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpadeq HOoAApBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpad *)
(* dans la couche 0 *)
Lemma LOoABCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpad requis par la preuve de (?)OoBCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpadm4 : rk(Oo :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoABCApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpadmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpadM : rk(Oo :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpadm : rk(Oo :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBCApBpadeq HOoBCApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpad requis par la preuve de (?)ABCApBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpadm3 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoABCApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpadm4 : rk(A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoABCApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApBpadM : rk(A :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpadm : rk(A :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpadeq HABCApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpadM : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpadm : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labad *)
(* dans constructLemma(), requis par LAabDad *)
(* dans la couche 0 *)
Lemma LABabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)OoABCApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadm2 : rk(A :: B :: ab :: D :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApabDadeq HABCApabDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadmtmp;try rewrite HT2 in HABCApabDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil) (nil) 4 0 2 HABCApabDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDadM3 : rk(A :: B :: ab :: D :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HABabMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadm3 : rk(A :: B :: ab :: D :: ad :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABabDadM : rk(A :: B :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDadm : rk(A :: B :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABabDadeq HABabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AabDad requis par la preuve de (?)AabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AabDad requis par la preuve de (?)AabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDad requis par la preuve de (?)AabDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAabDadM3 : rk(A :: ab :: D :: ad :: nil) <= 3).
{
	assert(HabMtmp : rk(ab :: nil) <= 1) by (solve_hyps_max Habeq HabM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: nil) (ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: A :: D :: ad :: nil) ((ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HabMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDadm2 : rk(A :: ab :: D :: ad :: nil) >= 2).
{
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: nil) (A :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ab :: nil) (A :: ab :: D :: ad :: nil) 2 2 HAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  3 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadm3 : rk(A :: ab :: D :: ad :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HABabDadeq HABabDadm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: nil) (A :: ab :: nil) 3 2 2 HABabDadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HAabDadM : rk(A :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDadm : rk(A :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAabDadeq HAabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour abad requis par la preuve de (?)abad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(Habadm2 : rk(ab :: ad :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAabDadeq : rk(A :: ab :: D :: ad :: nil) = 3) by (apply LAabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabDadmtmp : rk(A :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HAabDadeq HAabDadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (ab :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: nil) (ab :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: A :: D :: ad :: nil) ((ab :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAabDadmtmp;try rewrite HT2 in HAabDadmtmp.
	assert(HT := rule_2 (ab :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HAabDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HabadM : rk(ab :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max Habadeq HabadM2).
assert(Habadm : rk(ab :: ad ::  nil) >= 1) by (solve_hyps_min Habadeq Habadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabad *)
(* dans constructLemma(), requis par LAApBpabad *)
(* dans la couche 0 *)
Lemma LOoAApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpabadm2 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpabadm3 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoABpeq : rk(Oo :: A :: Bp :: nil) = 3) by (apply LOoABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpmtmp : rk(Oo :: A :: Bp :: nil) >= 3) by (solve_hyps_min HOoABpeq HOoABpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpabadm4 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpabadM : rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpabadm : rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpabadeq HOoAApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBpabad requis par la preuve de (?)ABApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApBpabadm3 : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)OoABCApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: C :: Ap ::   de rang : 3 et 3 *)
assert(HAApBpabadm2 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApMtmp : rk(B :: C :: Ap :: nil) <= 3) by (solve_hyps_max HBCApeq HBCApM3).
	assert(HABCApBpabadmtmp : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApBpabadeq HABCApBpabadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: A :: Ap :: Bp :: ab :: ad :: nil) ((B :: C :: Ap :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpabadmtmp;try rewrite HT2 in HABCApBpabadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (Ap :: nil) 4 1 3 HABCApBpabadmtmp HApmtmp HBCApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApBpabadm3 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApBpabadmtmp : rk(A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HABApBpabadeq HABApBpabadm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Bp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApBpabadmtmp;try rewrite HT2 in HABApBpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (A :: ab :: nil) 3 2 2 HABApBpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: Bp :: ad ::   de rang : 4 et 4 *)
assert(HAApBpabadm4 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoAApBpadeq : rk(Oo :: A :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpadMtmp : rk(Oo :: A :: Ap :: Bp :: ad :: nil) <= 4) by (solve_hyps_max HOoAApBpadeq HOoAApBpadM4).
	assert(HOoAApBpabadeq : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoAApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabadmtmp : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpabadeq HOoAApBpabadm4).
	assert(HAApBpadeq : rk(A :: Ap :: Bp :: ad :: nil) = 4) by (apply LAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpadmtmp : rk(A :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HAApBpadeq HAApBpadm4).
	assert(Hincl : incl (A :: Ap :: Bp :: ad :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ad :: A :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: Bp :: ad :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpabadmtmp;try rewrite HT2 in HOoAApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: Bp :: ad :: nil) 4 4 4 HOoAApBpabadmtmp HAApBpadmtmp HOoAApBpadMtmp Hincl); apply HT.
}

assert(HAApBpabadM : rk(A :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpabadm : rk(A :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpabadeq HAApBpabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabad *)
(* dans constructLemma(), requis par LApBpabad *)
(* dans constructLemma(), requis par LOoBApBpabad *)
(* dans constructLemma(), requis par LOoABApBpabad *)
(* dans la couche 0 *)
Lemma LOoABCApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabad requis par la preuve de (?)OoABCApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoABApBpabadm4 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCApBpabadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABCApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HOoABadeq : rk(Oo :: A :: B :: ad :: nil) = 4) by (apply LOoABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABadmtmp : rk(Oo :: A :: B :: ad :: nil) >= 4) by (solve_hyps_min HOoABadeq HOoABadm4).
	assert(Hincl : incl (Oo :: A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: ad :: nil) 4 4 4 HOoABCApBpabadmtmp HOoABadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoABApBpabadM : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpabadm : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabadm3 : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ad ::   de rang : 3 et 3 *)
assert(HOoBApBpabadm4 : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoAApadeq : rk(Oo :: A :: Ap :: ad :: nil) = 3) by (apply LOoAApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApadMtmp : rk(Oo :: A :: Ap :: ad :: nil) <= 3) by (solve_hyps_max HOoAApadeq HOoAApadM3).
	assert(HOoABApBpabadeq : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm4).
	assert(HOoApadeq : rk(Oo :: Ap :: ad :: nil) = 3) by (apply LOoApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApadmtmp : rk(Oo :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoApadeq HOoApadm3).
	assert(Hincl : incl (Oo :: Ap :: ad :: nil) (list_inter (Oo :: A :: Ap :: ad :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: ad :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ad :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: ad :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ad :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: Ap :: ad :: nil) 4 3 3 HOoABApBpabadmtmp HOoApadmtmp HOoAApadMtmp Hincl); apply HT.
}

assert(HOoBApBpabadM : rk(Oo :: B :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpabadm : rk(Oo :: B :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoBApBpabadeq HOoBApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)ApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabad requis par la preuve de (?)OoABApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabad requis par la preuve de (?)OoBApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabadm3 : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpabadeq HOoABApBpabadm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabadmtmp;try rewrite HT2 in HOoABApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabadmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: ad ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpabadm2 : rk(Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpabadmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoBApBpabadeq HOoBApBpabadm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Bp :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabadmtmp;try rewrite HT2 in HOoBApBpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: ad :: nil) (Bp :: nil) 3 1 2 HOoBApBpabadmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApBpabadM3 : rk(Ap :: Bp :: ab :: ad :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: ad :: nil) ((Ap :: Bp :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (ad :: nil) (nil) 2 1 0 HApBpabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Bp :: ad ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: ad ::   de rang : 3 et 3 *)
assert(HApBpabadm3 : rk(Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoBBpadeq : rk(Oo :: B :: Bp :: ad :: nil) = 3) by (apply LOoBBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpadMtmp : rk(Oo :: B :: Bp :: ad :: nil) <= 3) by (solve_hyps_max HOoBBpadeq HOoBBpadM3).
	assert(HOoBApBpabadeq : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoBApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApBpabadmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoBApBpabadeq HOoBApBpabadm4).
	assert(HBpadeq : rk(Bp :: ad :: nil) = 2) by (apply LBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpadmtmp : rk(Bp :: ad :: nil) >= 2) by (solve_hyps_min HBpadeq HBpadm2).
	assert(Hincl : incl (Bp :: ad :: nil) (list_inter (Oo :: B :: Bp :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: ad :: nil) (Oo :: B :: Bp :: ad :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: B :: Bp :: ad :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabadmtmp;try rewrite HT2 in HOoBApBpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil) (Bp :: ad :: nil) 4 2 3 HOoBApBpabadmtmp HBpadmtmp HOoBBpadMtmp Hincl); apply HT.
}

assert(HApBpabadM : rk(Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpabadm : rk(Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HApBpabadeq HApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Aabad requis par la preuve de (?)Aabad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabad requis par la preuve de (?)Aabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)OoABCApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabadm3 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabadm4 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabadm2 : rk(A :: B :: ab :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabadmtmp : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApabadeq HABCApabadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ad :: nil) (C :: Ap :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabadmtmp;try rewrite HT2 in HABCApabadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: ad :: nil) (nil) 4 0 2 HABCApabadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABabadM3 : rk(A :: B :: ab :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (ad :: nil) (nil) 2 1 0 HABabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Aabad requis par la preuve de (?)Aabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ad ::  de rang :  2 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabadm2 : rk(A :: ab :: ad :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabadmtmp : rk(A :: B :: ab :: ad :: nil) >= 2) by (solve_hyps_min HABabadeq HABabadm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: A :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadmtmp;try rewrite HT2 in HABabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ad :: nil) (A :: ab :: nil) 2 2 2 HABabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAabadm3 : rk(A :: ab :: ad :: nil) >= 3).
{
	assert(HApBpabadeq : rk(Ap :: Bp :: ab :: ad :: nil) = 3) by (apply LApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpabadMtmp : rk(Ap :: Bp :: ab :: ad :: nil) <= 3) by (solve_hyps_max HApBpabadeq HApBpabadM3).
	assert(HAApBpabadeq : rk(A :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LAApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpabadmtmp : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HAApBpabadeq HAApBpabadm4).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (A :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: ad :: nil) (A :: ab :: ad :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ad :: Ap :: Bp :: ab :: ad :: nil) ((A :: ab :: ad :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabadmtmp;try rewrite HT2 in HAApBpabadmtmp.
	assert(HT := rule_2 (A :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil) (ab :: ad :: nil) 4 2 3 HAApBpabadmtmp Habadmtmp HApBpabadMtmp Hincl);apply HT.
}

assert(HAabadM : rk(A :: ab :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAabadeq HAabadM3).
assert(HAabadm : rk(A :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HAabadeq HAabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABabad *)
(* dans la couche 0 *)
Lemma LOoABCabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabad requis par la preuve de (?)OoABCabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabadm4 : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabadM : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabadm : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCabadeq HOoABCabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)OoABCApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabadm3 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabadm4 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabadm2 : rk(A :: B :: ab :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabadmtmp : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HABCApabadeq HABCApabadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ad :: nil) (C :: Ap :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabadmtmp;try rewrite HT2 in HABCApabadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: ad :: nil) (nil) 4 0 2 HABCApabadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABabadM3 : rk(A :: B :: ab :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (ad :: nil) (nil) 2 1 0 HABabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HABabadm3 : rk(A :: B :: ab :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCabadeq : rk(Oo :: A :: B :: C :: ab :: ad :: nil) = 4) by (apply LOoABCabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabadmtmp : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCabadeq HOoABCabadm4).
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hincl : incl (A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: ad :: nil) (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabadmtmp;try rewrite HT2 in HOoABCabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil) (A :: B :: ad :: nil) 4 3 4 HOoABCabadmtmp HABadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HABabadM : rk(A :: B :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabadm : rk(A :: B :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABabadeq HABabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabad *)
(* dans la couche 0 *)
Lemma LOoABCApabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabad requis par la preuve de (?)OoABCApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabadM : rk(Oo :: A :: B :: C :: Ap :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabadm : rk(Oo :: A :: B :: C :: Ap :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabad requis par la preuve de (?)ABCApabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabadm3 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) = 4) by (apply LOoABCApabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabadm4 : rk(A :: B :: C :: Ap :: ab :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) = 4) by (apply LOoABCApabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabadeq HOoABCApabadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabadmtmp;try rewrite HT2 in HOoABCApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApabadM : rk(A :: B :: C :: Ap :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabadm : rk(A :: B :: C :: Ap :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABCApabadeq HABCApabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabad requis par la preuve de (?)ABCApBpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABCApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoABCApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabadeq HOoABCApBpabadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabadmtmp;try rewrite HT2 in HOoABCApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApBpabadM : rk(A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpabadm : rk(A :: B :: C :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpabadeq HABCApBpabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacad *)
(* dans constructLemma(), requis par LAacDad *)
(* dans la couche 0 *)
Lemma LACacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadm2 : rk(A :: C :: ac :: D :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadmtmp;try rewrite HT2 in HOoABCApacDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil) (A :: nil) 4 1 3 HOoABCApacDadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDadM3 : rk(A :: C :: ac :: D :: ad :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HACacMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadm3 : rk(A :: C :: ac :: D :: ad :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACacDadM : rk(A :: C :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDadm : rk(A :: C :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HACacDadeq HACacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AacDad requis par la preuve de (?)AacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AacDad requis par la preuve de (?)AacDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDad requis par la preuve de (?)AacDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAacDadM3 : rk(A :: ac :: D :: ad :: nil) <= 3).
{
	assert(HacMtmp : rk(ac :: nil) <= 1) by (solve_hyps_max Haceq HacM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: nil) (ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: A :: D :: ad :: nil) ((ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ac :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HacMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDadm2 : rk(A :: ac :: D :: ad :: nil) >= 2).
{
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: nil) (A :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ac :: nil) (A :: ac :: D :: ad :: nil) 2 2 HAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  3 et 3 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadm3 : rk(A :: ac :: D :: ad :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 3) by (solve_hyps_min HACacDadeq HACacDadm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: nil) (A :: ac :: nil) 3 2 2 HACacDadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

assert(HAacDadM : rk(A :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDadm : rk(A :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAacDadeq HAacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour acad requis par la preuve de (?)acad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(Hacadm2 : rk(ac :: ad :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAacDadeq : rk(A :: ac :: D :: ad :: nil) = 3) by (apply LAacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacDadmtmp : rk(A :: ac :: D :: ad :: nil) >= 3) by (solve_hyps_min HAacDadeq HAacDadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (ac :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: nil) (ac :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: ad :: A :: D :: ad :: nil) ((ac :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAacDadmtmp;try rewrite HT2 in HAacDadmtmp.
	assert(HT := rule_2 (ac :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HAacDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HacadM : rk(ac :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max Hacadeq HacadM2).
assert(Hacadm : rk(ac :: ad ::  nil) >= 1) by (solve_hyps_min Hacadeq Hacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACacad *)
(* dans la couche 0 *)
Lemma LOoABCacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCacad requis par la preuve de (?)OoABCacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCacadm4 : rk(Oo :: A :: B :: C :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCacadM : rk(Oo :: A :: B :: C :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCacadm : rk(Oo :: A :: B :: C :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCacadeq HOoABCacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)OoABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacadm2 : rk(A :: C :: ac :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadmtmp;try rewrite HT2 in HOoABCApacadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: ad :: nil) (A :: nil) 4 1 3 HOoABCApacadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HACacadM3 : rk(A :: C :: ac :: ad :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: ad :: nil) (A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (ad :: nil) (nil) 2 1 0 HACacMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: C :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HACacadm3 : rk(A :: C :: ac :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCacadeq : rk(Oo :: A :: B :: C :: ac :: ad :: nil) = 4) by (apply LOoABCacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCacadmtmp : rk(Oo :: A :: B :: C :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCacadeq HOoABCacadm4).
	assert(HACadeq : rk(A :: C :: ad :: nil) = 3) by (apply LACad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACadmtmp : rk(A :: C :: ad :: nil) >= 3) by (solve_hyps_min HACadeq HACadm3).
	assert(Hincl : incl (A :: C :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: C :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: ad :: nil) (Oo :: A :: B :: C :: ad :: A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: C :: ac :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: C :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacadmtmp;try rewrite HT2 in HOoABCacadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: C :: ac :: ad :: nil) (A :: C :: ad :: nil) 4 3 4 HOoABCacadmtmp HACadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HACacadM : rk(A :: C :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacadm : rk(A :: C :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HACacadeq HACacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)OoABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacadM : rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacadm : rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDad *)
(* dans constructLemma(), requis par LApDDpad *)
(* dans la couche 0 *)
Lemma LOoApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpad requis par la preuve de (?)OoABApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpad requis par la preuve de (?)OoABApDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApDDpadm2 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpadmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoABApDDpadeq HOoABApDDpadm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: D :: Dp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadmtmp;try rewrite HT2 in HOoABApDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApDDpadmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApDDpadm3 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: Dp :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil) 3 3 HOoApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoApDDpadM3 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: Dp :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (Ap :: Dp :: ad :: nil) (Dp :: nil) 2 2 1 HOoDDpMtmp HApDpadMtmp HDpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoApDDpadM : rk(Oo :: Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApDDpadm : rk(Oo :: Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoApDDpadeq HOoApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HApDDpadM3 : rk(Ap :: D :: Dp :: ad :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: Dp :: ad :: nil) ((D :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HDMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDDpadm2 : rk(Ap :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: Ap :: D :: Dp :: ad ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HApDDpadm3 : rk(Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoApDDpadeq : rk(Oo :: Ap :: D :: Dp :: ad :: nil) = 3) by (apply LOoApDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDDpadmtmp : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoApDDpadeq HOoApDDpadm3).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: D :: Dp :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApDDpadmtmp;try rewrite HT2 in HOoApDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil) (D :: Dp :: nil) 3 2 2 HOoApDDpadmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HApDDpadM : rk(Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDDpadm : rk(Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HApDDpadeq HApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dad requis par la preuve de (?)Dad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDadm2 : rk(D :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HApDDpadeq : rk(Ap :: D :: Dp :: ad :: nil) = 3) by (apply LApDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDDpadmtmp : rk(Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HApDDpadeq HApDDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (D :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: ad :: Ap :: Dp :: ad :: nil) ((D :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApDDpadmtmp;try rewrite HT2 in HApDDpadmtmp.
	assert(HT := rule_2 (D :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HApDDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HDadM : rk(D :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDadeq HDadM2).
assert(HDadm : rk(D :: ad ::  nil) >= 1) by (solve_hyps_min HDadeq HDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDad *)
(* dans la couche 0 *)
Lemma LOoABCApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDadM : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDadm : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDad requis par la preuve de (?)ABCApDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDadm3 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadeq : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) = 4) by (apply LOoABCApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDadm4 : rk(A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDadeq : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) = 4) by (apply LOoABCApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApDadM : rk(A :: B :: C :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDadm : rk(A :: B :: C :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApDadeq HABCApDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApBpDad *)
(* dans la couche 0 *)
Lemma LOoABCApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDad requis par la preuve de (?)OoABCApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpDad requis par la preuve de (?)ABCApBpDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpDadm3 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoABCApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpDadm4 : rk(A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoABCApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpDadeq HOoABCApBpDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDadmtmp;try rewrite HT2 in HOoABCApBpDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApBpDadM : rk(A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpDadm : rk(A :: B :: C :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpDadeq HABCApBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpDadM : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDadm : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)OoABCApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadm2 : rk(A :: B :: ab :: D :: ad :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApabDadeq HABCApabDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadmtmp;try rewrite HT2 in HABCApabDadmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil) (nil) 4 0 2 HABCApabDadmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDadM3 : rk(A :: B :: ab :: D :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HABabMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  2 et 3 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadm2 : rk(B :: ab :: D :: ad :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 2) by (solve_hyps_min HABabDadeq HABabDadm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: nil) (B :: ab :: nil) 2 2 2 HABabDadmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadm3 : rk(B :: ab :: D :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HABabDadeq HABabDadm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: nil) (D :: ad :: nil) 3 2 2 HABabDadmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBabDadM3 : rk(B :: ab :: D :: ad :: nil) <= 3).
{
	assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDadMtmp : rk(A :: B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HABabDadeq HABabDadM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: ab :: D :: ad :: nil) (A :: B :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: ab :: D :: ad :: nil) (A :: B :: ab :: D :: ad :: nil) 3 3 HABabDadMtmp Hcomp Hincl);apply HT.
}

assert(HBabDadM : rk(B :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBabDadm : rk(B :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HBabDadeq HBabDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDad *)
(* dans la couche 0 *)
Lemma LOoABCApabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDad requis par la preuve de (?)OoABCApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabDadM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDadm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDad requis par la preuve de (?)ABCApabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApabDadeq HOoABCApabDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadmtmp;try rewrite HT2 in HOoABCApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApabDadM : rk(A :: B :: C :: Ap :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDadm : rk(A :: B :: C :: Ap :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApabDadeq HABCApabDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApBpabDad *)
(* dans la couche 0 *)
Lemma LOoABCApBpabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDad requis par la preuve de (?)OoABCApBpabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabDadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpabDad requis par la preuve de (?)ABCApBpabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabDadm3 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApBpabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApBpabDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApBpabDadm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpabDadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) = 4) by (apply LOoABCApBpabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDadeq HOoABCApBpabDadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDadmtmp;try rewrite HT2 in HOoABCApBpabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: D :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApBpabDadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApBpabDadM : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpabDadm : rk(A :: B :: C :: Ap :: Bp :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApBpabDadeq HABCApBpabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadm2 : rk(A :: C :: ac :: D :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadmtmp;try rewrite HT2 in HOoABCApacDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil) (A :: nil) 4 1 3 HOoABCApacDadmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDadM3 : rk(A :: C :: ac :: D :: ad :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HACacMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  2 et 3 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadm2 : rk(C :: ac :: D :: ad :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 2) by (solve_hyps_min HACacDadeq HACacDadm2).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: nil) (C :: ac :: nil) 2 2 2 HACacDadmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadm3 : rk(C :: ac :: D :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 3) by (solve_hyps_min HACacDadeq HACacDadm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: nil) (D :: ad :: nil) 3 2 2 HACacDadmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCacDadM3 : rk(C :: ac :: D :: ad :: nil) <= 3).
{
	assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDadMtmp : rk(A :: C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HACacDadeq HACacDadM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: ac :: D :: ad :: nil) (A :: C :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: ac :: D :: ad :: nil) (A :: C :: ac :: D :: ad :: nil) 3 3 HACacDadMtmp Hcomp Hincl);apply HT.
}

assert(HCacDadM : rk(C :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCacDadm : rk(C :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HCacDadeq HCacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDadM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDadm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDpad *)
(* dans la couche 0 *)
Lemma LOoABCApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpad requis par la preuve de (?)OoABCApDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDpadM : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpadm : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDpad requis par la preuve de (?)ABCApDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDpadm3 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpadeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) = 4) by (apply LOoABCApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDpadm4 : rk(A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDpadeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) = 4) by (apply LOoABCApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDpadeq HOoABCApDpadm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: Dp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadmtmp;try rewrite HT2 in HOoABCApDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: ad :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDpadmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApDpadM : rk(A :: B :: C :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDpadm : rk(A :: B :: C :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HABCApDpadeq HABCApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpad requis par la preuve de (?)OoABCApBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpadeq HOoABCApBpDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDbd *)
(* dans constructLemma(), requis par LBpDDpbd *)
(* dans la couche 0 *)
Lemma LOoBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpDDpbd requis par la preuve de (?)OoBBpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbd requis par la preuve de (?)OoBCApBpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbd requis par la preuve de (?)OoABCApBpDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDDpbd requis par la preuve de (?)OoBCApBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDDpbdm4 : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdeq HOoABCApBpDDpbdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdmtmp;try rewrite HT2 in HOoABCApBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDDpbdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDDpbd requis par la preuve de (?)OoBBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpDDpbdm2 : rk(Oo :: B :: Bp :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpDDpbdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApBpDDpbdeq HOoBCApBpDDpbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (C :: Ap :: Oo :: B :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: D :: Dp :: bd :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpDDpbdmtmp;try rewrite HT2 in HOoBCApBpDDpbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: bd :: nil) (nil) 4 0 2 HOoBCApBpDDpbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpDDpbd requis par la preuve de (?)OoBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: D :: Dp :: bd ::  de rang :  2 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpDDpbdm2 : rk(Oo :: Bp :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpDDpbdmtmp : rk(Oo :: B :: Bp :: D :: Dp :: bd :: nil) >= 2) by (solve_hyps_min HOoBBpDDpbdeq HOoBBpDDpbdm2).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: D :: Dp :: bd :: nil) (Oo :: B :: Bp :: Oo :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: D :: Dp :: bd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpDDpbdmtmp;try rewrite HT2 in HOoBBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpDDpbdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpDDpbdm3 : rk(Oo :: Bp :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: Dp :: nil) (Oo :: Bp :: D :: Dp :: bd :: nil) 3 3 HOoBpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoBpDDpbdM3 : rk(Oo :: Bp :: D :: Dp :: bd :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Bp :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (Bp :: Dp :: bd :: nil) (Dp :: nil) 2 2 1 HOoDDpMtmp HBpDpbdMtmp HDpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBpDDpbdM : rk(Oo :: Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBpDDpbdm : rk(Oo :: Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBpDDpbdeq HOoBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBpDDpbdM3 : rk(Bp :: D :: Dp :: bd :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: Dp :: bd :: nil) ((D :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Bp :: Dp :: bd :: nil) (nil) 1 2 0 HDMtmp HBpDpbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDDpbdm2 : rk(Bp :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: Bp :: D :: Dp :: bd ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBpDDpbdm3 : rk(Bp :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBpDDpbdeq : rk(Oo :: Bp :: D :: Dp :: bd :: nil) = 3) by (apply LOoBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDDpbdmtmp : rk(Oo :: Bp :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoBpDDpbdeq HOoBpDDpbdm3).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Bp :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpDDpbdmtmp;try rewrite HT2 in HOoBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 3 2 2 HOoBpDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBpDDpbdM : rk(Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpDDpbdm : rk(Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dbd requis par la preuve de (?)Dbd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDbdm2 : rk(D :: bd :: nil) >= 2).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBpDDpbdeq : rk(Bp :: D :: Dp :: bd :: nil) = 3) by (apply LBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDDpbdmtmp : rk(Bp :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (D :: bd :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: bd :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: bd :: Bp :: Dp :: bd :: nil) ((D :: bd :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpDDpbdmtmp;try rewrite HT2 in HBpDDpbdmtmp.
	assert(HT := rule_2 (D :: bd :: nil) (Bp :: Dp :: bd :: nil) (bd :: nil) 3 1 2 HBpDDpbdmtmp Hbdmtmp HBpDpbdMtmp Hincl);apply HT.
}

assert(HDbdM : rk(D :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDbdeq HDbdM2).
assert(HDbdm : rk(D :: bd ::  nil) >= 1) by (solve_hyps_min HDbdeq HDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADbd *)
(* dans la couche 0 *)
Lemma LABDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoABCApDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDbdm3 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDbdm4 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDbdM3 : rk(A :: B :: D :: bd :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: bd :: nil) ((A :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HAMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABDbdm2 : rk(A :: B :: D :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApDbdmtmp : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HABCApDbdeq HABCApDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: bd :: nil) (C :: Ap :: A :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: D :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDbdmtmp;try rewrite HT2 in HABCApDbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: D :: bd :: nil) (nil) 4 0 2 HABCApDbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDbdm3 : rk(A :: B :: D :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABDbdM : rk(A :: B :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDbdm : rk(A :: B :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABDbdeq HABDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDbd requis par la preuve de (?)ADbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDbd requis par la preuve de (?)OoABCDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDbdm4 : rk(Oo :: A :: B :: C :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADbdm2 : rk(A :: D :: bd :: nil) >= 2).
{
	assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDbdmtmp : rk(Oo :: A :: B :: C :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCDbdeq HOoABCDbdm4).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: bd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: bd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDbdmtmp;try rewrite HT2 in HOoABCDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: bd :: nil) (A :: D :: nil) 4 2 4 HOoABCDbdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HADbdm3 : rk(A :: D :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HABDbdeq : rk(A :: B :: D :: bd :: nil) = 3) by (apply LABDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDbdmtmp : rk(A :: B :: D :: bd :: nil) >= 3) by (solve_hyps_min HABDbdeq HABDbdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (A :: D :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: D :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: bd :: B :: D :: bd :: nil) ((A :: D :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDbdmtmp;try rewrite HT2 in HABDbdmtmp.
	assert(HT := rule_2 (A :: D :: bd :: nil) (B :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HABDbdmtmp HDbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HADbdM : rk(A :: D :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADbdeq HADbdM3).
assert(HADbdm : rk(A :: D :: bd ::  nil) >= 1) by (solve_hyps_min HADbdeq HADbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDbd requis par la preuve de (?)OoABCDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDbdm4 : rk(Oo :: A :: B :: C :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDbdM : rk(Oo :: A :: B :: C :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDbdm : rk(Oo :: A :: B :: C :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCDbdeq HOoABCDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDbd *)
(* dans la couche 0 *)
Lemma LOoABCApDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoABCApDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDbdM : rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDbdm : rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDbd requis par la preuve de (?)ABCApDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDbdm3 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDbdeq : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) = 4) by (apply LOoABCApDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApDbdm4 : rk(A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDbdeq : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) = 4) by (apply LOoABCApDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApDbdM : rk(A :: B :: C :: Ap :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDbdm : rk(A :: B :: C :: Ap :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABCApDbdeq HABCApDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabDbd *)
(* dans la couche 0 *)
Lemma LABabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)OoABCApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDbdeq HABCApabDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDbdmtmp;try rewrite HT2 in HABCApabDbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (nil) 4 0 2 HABCApabDbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDbdm3 : rk(A :: B :: ab :: D :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABabDbdM : rk(A :: B :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDbdm : rk(A :: B :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABabDbdeq HABabDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)OoABCApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDbdeq HABCApabDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDbdmtmp;try rewrite HT2 in HABCApabDbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (nil) 4 0 2 HABCApabDbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: bd ::  de rang :  2 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDbdm2 : rk(A :: ab :: D :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDbdmtmp : rk(A :: B :: ab :: D :: bd :: nil) >= 2) by (solve_hyps_min HABabDbdeq HABabDbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDbdmtmp;try rewrite HT2 in HABabDbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDbdm3 : rk(A :: ab :: D :: bd :: nil) >= 3).
{
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: ab :: D :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDbdM3 : rk(A :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABabDbdMtmp Hcomp Hincl);apply HT.
}

assert(HAabDbdM : rk(A :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDbdm : rk(A :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HAabDbdeq HAabDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDbd *)
(* dans la couche 0 *)
Lemma LOoABCApabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDbd requis par la preuve de (?)OoABCApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabDbdM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDbdm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDbd requis par la preuve de (?)ABCApabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) = 4) by (apply LOoABCApabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) = 4) by (apply LOoABCApabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDbdeq HOoABCApabDbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDbdmtmp;try rewrite HT2 in HOoABCApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApabDbdM : rk(A :: B :: C :: Ap :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDbdm : rk(A :: B :: C :: Ap :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABCApabDbdeq HABCApabDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbcDbd *)
(* dans la couche 0 *)
Lemma LBCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdm3 : rk(B :: C :: bc :: D :: bd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCbcDbdM : rk(B :: C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdm : rk(B :: C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  2 et 3 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdm2 : rk(C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 2) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdm3 : rk(C :: bc :: D :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 3) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCbcDbdM3 : rk(C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdMtmp : rk(B :: C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HBCbcDbdeq HBCbcDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCbcDbdMtmp Hcomp Hincl);apply HT.
}

assert(HCbcDbdM : rk(C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdm : rk(C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HCbcDbdeq HCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpbd *)
(* dans constructLemma(), requis par LBApDDpbd *)
(* dans constructLemma(), requis par LOoBApDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpbdm4 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApDDpbdM : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApDDpbdm : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApDDpbdm3 : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApDDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApDDpbdm4 : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApDDpbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApDDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoBApDDpbdM : rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApDDpbdm : rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApDDpbdeq HOoBApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApDDpbdm2 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm3).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApDDpbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HBApDDpbdm3 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApDDpbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm4).
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoABApDDpbdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApDDpbdm4 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApDDpbdeq : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoBApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApDDpbdmtmp : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApDDpbdeq HOoBApDDpbdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApDDpbdmtmp;try rewrite HT2 in HOoBApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBApDDpbdM : rk(B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpbdm : rk(B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpbdm2 : rk(Ap :: Dp :: bd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: bd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpbdm3 : rk(Ap :: Dp :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApDDpbdeq : rk(B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LBApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApDDpbdmtmp : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpbdmtmp;try rewrite HT2 in HBApDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HApDpbdM : rk(Ap :: Dp :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpbdeq HApDpbdM3).
assert(HApDpbdm : rk(Ap :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApDpbdeq HApDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApabDpbd *)
(* dans constructLemma(), requis par LApBpabDpbd *)
(* dans constructLemma(), requis par LOoBApBpabDpbd *)
(* dans la couche 0 *)
Lemma LOoABApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDpbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm4 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABDpeq : rk(Oo :: A :: B :: Dp :: nil) = 4) by (apply LOoABDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDpmtmp : rk(Oo :: A :: B :: Dp :: nil) >= 4) by (solve_hyps_min HOoABDpeq HOoABDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: Dp :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: Dp :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 4 4 HOoABDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApBpabDpbdM : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpabDpbdm : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDpbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabDpbdm3 : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDpbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpbdmtmp;try rewrite HT2 in HOoABApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApBpabDpbdm4 : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApBpabDpbdeq : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoABApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApBpabDpbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpbdmtmp;try rewrite HT2 in HOoABApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApBpabDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoBApBpabDpbdM : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpabDpbdm : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApBpabDpbdeq HOoBApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpbd requis par la preuve de (?)OoABApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDpbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApBpabDpbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpabDpbd requis par la preuve de (?)OoBApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApBpabDpbdm3 : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDpbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDpbdeq HOoABApBpabDpbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpbdmtmp;try rewrite HT2 in HOoABApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApBpabDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HApBpabDpbdm2 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBApBpabDpbdmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoBApBpabDpbdeq HOoBApBpabDpbdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Bp :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: B :: Bp :: nil) ++ (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabDpbdmtmp;try rewrite HT2 in HOoBApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) (Bp :: nil) 3 1 2 HOoBApBpabDpbdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApBpabDpbdM3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpDpbdMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HApBpabDpbdm3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBApBpabDpbdeq : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoBApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApBpabDpbdmtmp : rk(Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApBpabDpbdeq HOoBApBpabDpbdm4).
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: B :: Bp :: Dp :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpabDpbdmtmp;try rewrite HT2 in HOoBApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) (Bp :: Dp :: nil) 4 2 3 HOoBApBpabDpbdmtmp HBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

assert(HApBpabDpbdM : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpabDpbdm : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApBpabDpbdeq HApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpbdm2 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm3 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm4 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApabDDpbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpbdeq HOoBApabDDpbdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpbdmtmp;try rewrite HT2 in HOoBApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDpbd requis par la preuve de (?)OoABApabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDpbd requis par la preuve de (?)OoABApabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDpbdm3 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDpbdeq HOoABApabDpbdm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDpbdmtmp;try rewrite HT2 in HOoABApabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDpbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpbdm2 : rk(Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpbdeq HABApabDpbdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpbdmtmp;try rewrite HT2 in HABApabDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDpbdm3 : rk(Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApabDDpbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpbdeq HBApabDDpbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: D :: bd :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpbdmtmp;try rewrite HT2 in HBApabDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: Dp :: bd :: nil) (bd :: nil) 4 1 2 HBApabDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApabDpbdM3 : rk(Ap :: ab :: Dp :: bd :: nil) <= 3).
{
	assert(HApBpabDpbdeq : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) = 3) by (apply LApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpabDpbdMtmp : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApBpabDpbdeq HApBpabDpbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HApBpabDpbdMtmp Hcomp Hincl);apply HT.
}

assert(HApabDpbdM : rk(Ap :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpbdm : rk(Ap :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpbdeq HApabDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpDDpbd *)
(* dans la couche 0 *)
Lemma LOoABCApBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbd requis par la preuve de (?)OoABCApBpDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpbdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpbdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpbdeq HOoABCApBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpDDpbd requis par la preuve de (?)OoBCApBpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpDDpbdm4 : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) = 4) by (apply LOoABCApBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdeq HOoABCApBpDDpbdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdmtmp;try rewrite HT2 in HOoABCApBpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpDDpbdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpDDpbdM : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpDDpbdm : rk(Oo :: B :: C :: Ap :: Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApBpDDpbdeq HOoBCApBpDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApabDDpbd *)
(* dans constructLemma(), requis par LOoBApabDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApabDDpbdM : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabDDpbdm : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpbd requis par la preuve de (?)OoBApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApabDDpbdeq : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoBApabDDpbdM : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApabDDpbdm : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApabDDpbdeq HOoBApabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpbdm2 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm3).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm3 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm4 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApabDDpbdeq : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LOoBApabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabDDpbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpbdeq HOoBApabDDpbdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpbdmtmp;try rewrite HT2 in HOoBApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBApabDDpbdM : rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApabDDpbdm : rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBApabDDpbdeq HBApabDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LabDadbd *)
(* dans constructLemma(), requis par LAabDadbd *)
(* dans la couche 0 *)
Lemma LADadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDadbd requis par la preuve de (?)ADadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadbd requis par la preuve de (?)OoABCDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDadbdm4 : rk(Oo :: A :: B :: C :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADadbdm2 : rk(A :: D :: ad :: bd :: nil) >= 2).
{
	assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDadbdmtmp : rk(Oo :: A :: B :: C :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCDadbdeq HOoABCDadbdm4).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: ad :: bd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: ad :: bd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDadbdmtmp;try rewrite HT2 in HOoABCDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: bd :: nil) (A :: D :: nil) 4 2 4 HOoABCDadbdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HADadbdM3 : rk(A :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (bd :: nil) (nil) 2 1 0 HADadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadbdm3 : rk(A :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}

assert(HADadbdM : rk(A :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadbdm : rk(A :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HADadbdeq HADadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadbdm2 : rk(A :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDadbdm3 : rk(A :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAabDadbdM3 : rk(A :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HAabDbdeq : rk(A :: ab :: D :: bd :: nil) = 3) by (apply LAabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabDbdMtmp : rk(A :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HAabDbdeq HAabDbdM3).
	assert(HADadbdeq : rk(A :: D :: ad :: bd :: nil) = 3) by (apply LADadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadbdMtmp : rk(A :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HADadbdeq HADadbdM3).
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hincl : incl (A :: D :: bd :: nil) (list_inter (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil) ((A :: ab :: D :: bd :: nil) ++ (A :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) (A :: D :: bd :: nil) 3 3 3 HAabDbdMtmp HADadbdMtmp HADbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAabDadbdM : rk(A :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDadbdm : rk(A :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAabDadbdeq HAabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abDadbd requis par la preuve de (?)abDadbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BabDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadbdm2 : rk(A :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abDadbd requis par la preuve de (?)abDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HabDadbdm2 : rk(ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAabDadbdmtmp : rk(A :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HAabDadbdeq HAabDadbdm2).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAabDadbdmtmp;try rewrite HT2 in HAabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 2 2 2 HAabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HabDadbdm3 : rk(ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBabDadbdmtmp : rk(B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HBabDadbdeq HBabDadbdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: D :: bd :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: ab :: D :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBabDadbdmtmp;try rewrite HT2 in HBabDadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (ab :: D :: ad :: bd :: nil) (D :: bd :: nil) 3 2 2 HBabDadbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HabDadbdM3 : rk(ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HAabDadbdeq : rk(A :: ab :: D :: ad :: bd :: nil) = 3) by (apply LAabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabDadbdMtmp : rk(A :: ab :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HAabDadbdeq HAabDadbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (ab :: D :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (ab :: D :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HAabDadbdMtmp Hcomp Hincl);apply HT.
}

assert(HabDadbdM : rk(ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HabDadbdm : rk(ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HabDadbdeq HabDadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LApabDpadbd *)
(* dans constructLemma(), requis par LApDpadbd *)
(* dans constructLemma(), requis par LBApDDpadbd *)
(* dans constructLemma(), requis par LOoBApDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadbdm4 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApDDpadbdM : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApDDpadbdm : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApDDpadbdm3 : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApDDpadbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApDDpadbdm4 : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApDDpadbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApDDpadbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoBApDDpadbdM : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApDDpadbdm : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApDDpadbdeq HOoBApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApDDpadbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApDDpadbdm2 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm3).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApDDpadbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HBApDDpadbdm3 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApDDpadbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm4).
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoABApDDpadbdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApDDpadbdm4 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApDDpadbdeq : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApDDpadbdmtmp : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApDDpadbdeq HOoBApDDpadbdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApDDpadbdmtmp;try rewrite HT2 in HOoBApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBApDDpadbdM : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpadbdm : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpadbdm2 : rk(Ap :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApDpadbdM3 : rk(Ap :: Dp :: ad :: bd :: nil) <= 3).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: bd :: nil) ((Ap :: Dp :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (bd :: nil) (nil) 2 1 0 HApDpadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpadbdm3 : rk(Ap :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApDDpadbdeq : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LBApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApDDpadbdmtmp : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpadbdmtmp;try rewrite HT2 in HBApDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HApDpadbdM : rk(Ap :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadbdm : rk(Ap :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApDpadbdeq HApDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpadbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpadbdm2 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpadbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm3 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm4 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApabDDpadbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpadbdeq HOoBApabDDpadbdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpadbdmtmp;try rewrite HT2 in HOoBApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDpadbd requis par la preuve de (?)OoABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDpadbd requis par la preuve de (?)OoABApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDpadbdm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDpadbdeq HOoABApabDpadbdm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDpadbdmtmp;try rewrite HT2 in HOoABApabDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpadbdm2 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpadbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDpadbdm3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApabDDpadbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpadbdmtmp;try rewrite HT2 in HBApabDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (bd :: nil) 4 1 2 HBApabDDpadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApabDpadbdM3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3).
{
	assert(HApabDpbdeq : rk(Ap :: ab :: Dp :: bd :: nil) = 3) by (apply LApabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDpbdMtmp : rk(Ap :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApabDpbdeq HApabDpbdM3).
	assert(HApDpadbdeq : rk(Ap :: Dp :: ad :: bd :: nil) = 3) by (apply LApDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpadbdMtmp : rk(Ap :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApDpadbdeq HApDpadbdM3).
	assert(HApDpbdeq : rk(Ap :: Dp :: bd :: nil) = 3) by (apply LApDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpbdmtmp : rk(Ap :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HApDpbdeq HApDpbdm3).
	assert(Hincl : incl (Ap :: Dp :: bd :: nil) (list_inter (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: Dp :: ad :: bd :: nil) (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil) ((Ap :: ab :: Dp :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: bd :: nil) 3 3 3 HApabDpbdMtmp HApDpadbdMtmp HApDpbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApabDpadbdM : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpadbdm : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpadbdeq HApabDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LApabDDpadbd *)
(* dans constructLemma(), requis par LBApabDDpadbd *)
(* dans constructLemma(), requis par LOoBApabDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApabDDpadbdM : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabDDpadbdm : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApabDDpadbd requis par la preuve de (?)OoBApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm3 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HOoBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoBApabDDpadbdm4 : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoABApabDDpadbdeq : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoABApabDDpadbdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoBApabDDpadbdM : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApabDDpadbdm : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApabDDpadbdeq HOoBApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HBApabDDpadbdm2 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: nil) 3 2 3 HOoABApabDDpadbdmtmp HBApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm3 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm4 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApabDDpadbdeq : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabDDpadbdmtmp : rk(Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApabDDpadbdeq HOoBApabDDpadbdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApabDDpadbdmtmp;try rewrite HT2 in HOoBApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApabDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBApabDDpadbdM : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApabDDpadbdm : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApabDDpadbd requis par la preuve de (?)OoApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApabDDpadbd requis par la preuve de (?)OoApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApabDDpadbdm2 : rk(Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApabDDpadbdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApabDDpadbdm3 : rk(Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoApabeq : rk(Oo :: Ap :: ab :: nil) = 3) by (apply LOoApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApabmtmp : rk(Oo :: Ap :: ab :: nil) >= 3) by (solve_hyps_min HOoApabeq HOoApabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: ab :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: ab :: nil) (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HOoApabmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm3).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: Ap :: nil) 3 3 3 HOoABApabDDpadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDDpadbd requis par la preuve de (?)ApabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDDpadbdm2 : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (ab :: nil) 3 1 2 HABApabDDpadbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HApabDDpadbdm3 : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoApabDDpadbdmtmp : rk(Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoApabDDpadbdeq HOoApabDDpadbdm3).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApabDDpadbdmtmp;try rewrite HT2 in HOoApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 3 2 2 HOoApabDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDDpadbdm4 : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApabDDpadbdeq : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LBApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApabDDpadbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm4).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpadbdmtmp;try rewrite HT2 in HBApabDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (D :: bd :: nil) 4 2 2 HBApabDDpadbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HApabDDpadbdM : rk(Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDDpadbdm : rk(Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApabDDpadbdeq HApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BabDadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(Habadbdm2 : rk(ab :: ad :: bd :: nil) >= 2).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBabDadbdmtmp : rk(B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HBabDadbdeq HBabDadbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: D :: bd :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: ab :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBabDadbdmtmp;try rewrite HT2 in HBabDadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (ab :: ad :: bd :: nil) (bd :: nil) 3 1 2 HBabDadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabadbdM2 : rk(ab :: ad :: bd :: nil) <= 2).
{
	assert(HabDadbdeq : rk(ab :: D :: ad :: bd :: nil) = 3) by (apply LabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabDadbdMtmp : rk(ab :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HabDadbdeq HabDadbdM3).
	assert(HApabDpadbdeq : rk(Ap :: ab :: Dp :: ad :: bd :: nil) = 3) by (apply LApabDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDpadbdMtmp : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApabDpadbdeq HApabDpadbdM3).
	assert(HApabDDpadbdeq : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDDpadbdmtmp : rk(Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HApabDDpadbdeq HApabDDpadbdm4).
	assert(Hincl : incl (ab :: ad :: bd :: nil) (list_inter (ab :: D :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: D :: Dp :: ad :: bd :: nil) (ab :: D :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: D :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil) ((ab :: D :: ad :: bd :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApabDDpadbdmtmp;try rewrite HT2 in HApabDDpadbdmtmp.
	assert(HT := rule_3 (ab :: D :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: ad :: bd :: nil) 3 3 4 HabDadbdMtmp HApabDpadbdMtmp HApabDDpadbdmtmp Hincl);apply HT.
}


assert(HabadbdM : rk(ab :: ad :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habadbdeq HabadbdM3).
assert(Habadbdm : rk(ab :: ad :: bd ::  nil) >= 1) by (solve_hyps_min Habadbdeq Habadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadbd requis par la preuve de (?)OoABCDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDadbdm4 : rk(Oo :: A :: B :: C :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDadbdM : rk(Oo :: A :: B :: C :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDadbdm : rk(Oo :: A :: B :: C :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCDadbdeq HOoABCDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBabDadbdM : rk(B :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBabDadbdm : rk(B :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBabDadbdeq HBabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HABCApabDadbdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((C :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdmtmp;try rewrite HT2 in HABCApabDadbdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (nil) 4 0 2 HABCApabDadbdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABabDadbdM : rk(A :: B :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDadbdm : rk(A :: B :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABabDadbdeq HABabDadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDadbd *)
(* dans la couche 0 *)
Lemma LOoABCApabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbd requis par la preuve de (?)OoABCApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabDadbdM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDadbdm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbd requis par la preuve de (?)ABCApabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 5 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdm3 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) = 4) by (apply LOoABCApabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: Ap :: nil) 4 1 2 HOoABCApabDadbdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: B :: Ap ::  de rang :  3 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCApabDadbdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabDadbdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) = 4) by (apply LOoABCApabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdeq HOoABCApabDadbdm4).
	assert(HABApeq : rk(A :: B :: Ap :: nil) = 3) by (apply LABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hincl : incl (A :: B :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdmtmp;try rewrite HT2 in HOoABCApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: nil) (A :: B :: Ap :: nil) 4 3 3 HOoABCApabDadbdmtmp HABApmtmp HOoABApMtmp Hincl); apply HT.
}

assert(HABCApabDadbdM : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDadbdm : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABCApabDadbdeq HABCApabDadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDcd *)
(* dans constructLemma(), requis par LCpDDpcd *)
(* dans la couche 0 *)
Lemma LOoCpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCpDDpcd requis par la preuve de (?)OoCpDDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCpDDpcd requis par la preuve de (?)OoCpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCpDDpcd requis par la preuve de (?)OoCpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpDDpcdm2 : rk(Oo :: Cp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoCpeq : rk(Oo :: Cp :: nil) = 2) by (apply LOoCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpmtmp : rk(Oo :: Cp :: nil) >= 2) by (solve_hyps_min HOoCpeq HOoCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil) 2 2 HOoCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCpDDpcdm3 : rk(Oo :: Cp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoCpDpeq : rk(Oo :: Cp :: Dp :: nil) = 3) by (apply LOoCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpDpmtmp : rk(Oo :: Cp :: Dp :: nil) >= 3) by (solve_hyps_min HOoCpDpeq HOoCpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Cp :: Dp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Cp :: Dp :: nil) (Oo :: Cp :: D :: Dp :: cd :: nil) 3 3 HOoCpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoCpDDpcdM3 : rk(Oo :: Cp :: D :: Dp :: cd :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Cp :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Cp :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (Cp :: Dp :: cd :: nil) (Dp :: nil) 2 2 1 HOoDDpMtmp HCpDpcdMtmp HDpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoCpDDpcdM : rk(Oo :: Cp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCpDDpcdm : rk(Oo :: Cp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCpDDpcdeq HOoCpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCpDDpcdM3 : rk(Cp :: D :: Dp :: cd :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: Dp :: cd :: nil) ((D :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Cp :: Dp :: cd :: nil) (nil) 1 2 0 HDMtmp HCpDpcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCpDDpcdm2 : rk(Cp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Cp :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Cp :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil) 2 2 HCpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: Cp :: D :: Dp :: cd ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCpDDpcdm3 : rk(Cp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCpDDpcdeq : rk(Oo :: Cp :: D :: Dp :: cd :: nil) = 3) by (apply LOoCpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpDDpcdmtmp : rk(Oo :: Cp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoCpDDpcdeq HOoCpDDpcdm3).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Cp :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: Cp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Cp :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Cp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCpDDpcdmtmp;try rewrite HT2 in HOoCpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 3 2 2 HOoCpDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCpDDpcdM : rk(Cp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCpDDpcdm : rk(Cp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dcd requis par la preuve de (?)Dcd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDcdm2 : rk(D :: cd :: nil) >= 2).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpDDpcdeq : rk(Cp :: D :: Dp :: cd :: nil) = 3) by (apply LCpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDDpcdmtmp : rk(Cp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (D :: cd :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: cd :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: cd :: Cp :: Dp :: cd :: nil) ((D :: cd :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCpDDpcdmtmp;try rewrite HT2 in HCpDDpcdmtmp.
	assert(HT := rule_2 (D :: cd :: nil) (Cp :: Dp :: cd :: nil) (cd :: nil) 3 1 2 HCpDDpcdmtmp Hcdmtmp HCpDpcdMtmp Hincl);apply HT.
}

assert(HDcdM : rk(D :: cd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDcdeq HDcdM2).
assert(HDcdm : rk(D :: cd ::  nil) >= 1) by (solve_hyps_min HDcdeq HDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADcd *)
(* dans la couche 0 *)
Lemma LACDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)ACDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDcdM3 : rk(A :: C :: D :: cd :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: cd :: nil) ((A :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HAMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACDcdm2 : rk(A :: C :: D :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: D :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: D :: cd :: nil) (A :: nil) 4 1 3 HOoABCApDcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDcdm3 : rk(A :: C :: D :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACDcdM : rk(A :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACDcdm : rk(A :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACDcdeq HACDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDcd requis par la preuve de (?)ADcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDcd requis par la preuve de (?)OoABCDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDcdm4 : rk(Oo :: A :: B :: C :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADcdm2 : rk(A :: D :: cd :: nil) >= 2).
{
	assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDcdmtmp : rk(Oo :: A :: B :: C :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCDcdeq HOoABCDcdm4).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: cd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: cd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDcdmtmp;try rewrite HT2 in HOoABCDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: cd :: nil) (A :: D :: nil) 4 2 4 HOoABCDcdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HADcdm3 : rk(A :: D :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HACDcdeq : rk(A :: C :: D :: cd :: nil) = 3) by (apply LACDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDcdmtmp : rk(A :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HACDcdeq HACDcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (A :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: cd :: C :: D :: cd :: nil) ((A :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDcdmtmp;try rewrite HT2 in HACDcdmtmp.
	assert(HT := rule_2 (A :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HACDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}

assert(HADcdM : rk(A :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADcdeq HADcdM3).
assert(HADcdm : rk(A :: D :: cd ::  nil) >= 1) by (solve_hyps_min HADcdeq HADcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBDcd *)
(* dans la couche 0 *)
Lemma LBCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)BCDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDcdM3 : rk(B :: C :: D :: cd :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: D :: cd :: nil) ((B :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HBMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCDcdm2 : rk(B :: C :: D :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: D :: cd :: nil) (nil) 4 0 2 HOoABCApDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDcdm3 : rk(B :: C :: D :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCDcdM : rk(B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCDcdm : rk(B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCDcdeq HBCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDcdm2 : rk(B :: D :: cd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBDcdm3 : rk(B :: D :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HBCDcdeq : rk(B :: C :: D :: cd :: nil) = 3) by (apply LBCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDcdmtmp : rk(B :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HBCDcdeq HBCDcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (B :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: cd :: C :: D :: cd :: nil) ((B :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDcdmtmp;try rewrite HT2 in HBCDcdmtmp.
	assert(HT := rule_2 (B :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HBCDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}

assert(HBDcdM : rk(B :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBDcdeq HBDcdM3).
assert(HBDcdm : rk(B :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBDcdeq HBDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDcd requis par la preuve de (?)OoABCDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDcdm4 : rk(Oo :: A :: B :: C :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDcdM : rk(Oo :: A :: B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDcdm : rk(Oo :: A :: B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCDcdeq HOoABCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDcdM : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDcdm : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAacDcd *)
(* dans la couche 0 *)
Lemma LACacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDcdm3 : rk(A :: C :: ac :: D :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACacDcdM : rk(A :: C :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDcdm : rk(A :: C :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACacDcdeq HACacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: cd ::  de rang :  2 et 3 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDcdm2 : rk(A :: ac :: D :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDcdmtmp : rk(A :: C :: ac :: D :: cd :: nil) >= 2) by (solve_hyps_min HACacDcdeq HACacDcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDcdmtmp;try rewrite HT2 in HACacDcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDcdm3 : rk(A :: ac :: D :: cd :: nil) >= 3).
{
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: ac :: D :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDcdM3 : rk(A :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACacDcdMtmp Hcomp Hincl);apply HT.
}

assert(HAacDcdM : rk(A :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDcdm : rk(A :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HAacDcdeq HAacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbcDcd *)
(* dans la couche 0 *)
Lemma LBCbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDcdm3 : rk(B :: C :: bc :: D :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCbcDcdM : rk(B :: C :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDcdm : rk(B :: C :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: cd ::  de rang :  2 et 3 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDcdm2 : rk(B :: bc :: D :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDcdmtmp : rk(B :: C :: bc :: D :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDcdmtmp;try rewrite HT2 in HBCbcDcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdm3 : rk(B :: bc :: D :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdM3 : rk(B :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCbcDcdMtmp Hcomp Hincl);apply HT.
}

assert(HBbcDcdM : rk(B :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDcdm : rk(B :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDcdeq HBbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpcd *)
(* dans constructLemma(), requis par LCApDDpcd *)
(* dans constructLemma(), requis par LOoCApDDpcd *)
(* dans la couche 0 *)
Lemma LOoACApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpcdm2 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApDDpcdm3 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpcdm4 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApDDpcdM : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApDDpcdm : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApDDpcdm3 : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApDDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApDDpcdm4 : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApDDpcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpcdmtmp;try rewrite HT2 in HOoACApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApDDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoCApDDpcdM : rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApDDpcdm : rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApDDpcdeq HOoCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApDDpcdm2 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApDDpcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HCApDDpcdm3 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApDDpcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm4).
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpcdmtmp;try rewrite HT2 in HOoACApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoACApDDpcdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApDDpcdm4 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApDDpcdeq : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApDDpcdmtmp : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApDDpcdeq HOoCApDDpcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApDDpcdmtmp;try rewrite HT2 in HOoCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCApDDpcdM : rk(C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpcdm : rk(C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpcdm2 : rk(Ap :: Dp :: cd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: cd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpcdm3 : rk(Ap :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApDDpcdeq : rk(C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApDDpcdmtmp : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpcdmtmp;try rewrite HT2 in HCApDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HApDpcdM : rk(Ap :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpcdeq HApDpcdM3).
assert(HApDpcdm : rk(Ap :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApDpcdeq HApDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpDpcd *)
(* dans constructLemma(), requis par LCBpDDpcd *)
(* dans constructLemma(), requis par LOoCBpDDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpDDpcdm4 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpDDpcdM : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpDDpcdm : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpDDpcd requis par la preuve de (?)OoCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpDDpcdm2 : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpDDpcdm3 : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpDDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpDDpcdm4 : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpDDpcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpDDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

assert(HOoCBpDDpcdM : rk(Oo :: C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpDDpcdm : rk(Oo :: C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpDDpcdeq HOoCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpDDpcdm2 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HCBpDDpcdm3 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpDDpcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm4).
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (Bp :: Dp :: nil) 4 2 3 HOoBCBpDDpcdmtmp HBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpDDpcdm4 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpDDpcdeq : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpDDpcdmtmp : rk(Oo :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpDDpcdeq HOoCBpDDpcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpDDpcdmtmp;try rewrite HT2 in HOoCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCBpDDpcdM : rk(C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpDDpcdm : rk(C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCBpDDpcdeq HCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDpcd requis par la preuve de (?)BpDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpDpcd requis par la preuve de (?)BpDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDpcdm2 : rk(Bp :: Dp :: cd :: nil) >= 2).
{
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: Dp :: cd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpDpcdm3 : rk(Bp :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpDDpcdeq : rk(C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpDDpcdmtmp : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCBpDDpcdeq HCBpDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: D :: Dp :: cd :: nil) (C :: D :: cd :: Bp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpDDpcdmtmp;try rewrite HT2 in HCBpDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCBpDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HBpDpcdM : rk(Bp :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpDpcdeq HBpDpcdM3).
assert(HBpDpcdm : rk(Bp :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpDpcdeq HBpDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApacDpcd *)
(* dans constructLemma(), requis par LApCpacDpcd *)
(* dans constructLemma(), requis par LOoCApCpacDpcd *)
(* dans la couche 0 *)
Lemma LOoACApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCpacDpcd requis par la preuve de (?)OoACApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApCpacDpcdm2 : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApCpacDpcdm3 : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpcdmtmp;try rewrite HT2 in HOoABCApCpacDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApCpacDpcdm4 : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoACDpeq : rk(Oo :: A :: C :: Dp :: nil) = 4) by (apply LOoACDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACDpmtmp : rk(Oo :: A :: C :: Dp :: nil) >= 4) by (solve_hyps_min HOoACDpeq HOoACDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: Dp :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: Dp :: nil) (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoACDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApCpacDpcdM : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApCpacDpcdm : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApCpacDpcdeq HOoACApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacDpcdm3 : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpcdmtmp;try rewrite HT2 in HOoABCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApCpacDpcdm4 : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApCpacDpcdeq : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) = 4) by (apply LOoACApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpacDpcdmtmp : rk(Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApCpacDpcdeq HOoACApCpacDpcdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApCpacDpcdmtmp;try rewrite HT2 in HOoACApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApCpacDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoCApCpacDpcdM : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpacDpcdm : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApCpacDpcdeq HOoCApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpacDpcd requis par la preuve de (?)OoCApCpacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApCpacDpcdm3 : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpcdmtmp;try rewrite HT2 in HOoABCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApCpacDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HApCpacDpcdm2 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCApCpacDpcdmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoCApCpacDpcdeq HOoCApCpacDpcdm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: C :: Cp :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacDpcdmtmp;try rewrite HT2 in HOoCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) (Cp :: nil) 3 1 2 HOoCApCpacDpcdmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApCpacDpcdM3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil) ((Ap :: Cp :: ac :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil) (Cp :: nil) 2 2 1 HApCpacMtmp HCpDpcdMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Cp :: Dp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp :: Dp ::   de rang : 3 et 3 *)
assert(HApCpacDpcdm3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HOoCCpDpeq : rk(Oo :: C :: Cp :: Dp :: nil) = 3) by (apply LOoCCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDpMtmp : rk(Oo :: C :: Cp :: Dp :: nil) <= 3) by (solve_hyps_max HOoCCpDpeq HOoCCpDpM3).
	assert(HOoCApCpacDpcdeq : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) = 4) by (apply LOoCApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApCpacDpcdmtmp : rk(Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApCpacDpcdeq HOoCApCpacDpcdm4).
	assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hincl : incl (Cp :: Dp :: nil) (list_inter (Oo :: C :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: C :: Cp :: Dp :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Dp :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: C :: Cp :: Dp :: nil) ++ (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpacDpcdmtmp;try rewrite HT2 in HOoCApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) (Cp :: Dp :: nil) 4 2 3 HOoCApCpacDpcdmtmp HCpDpmtmp HOoCCpDpMtmp Hincl); apply HT.
}

assert(HApCpacDpcdM : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacDpcdm : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApCpacDpcdeq HApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApacDDpcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpcdmtmp;try rewrite HT2 in HOoACApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpcdm2 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm3 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm4 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApacDDpcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpcdeq HOoCApacDDpcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpcdmtmp;try rewrite HT2 in HOoCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDpcdm2 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpcdmtmp;try rewrite HT2 in HOoABCApacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDpcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpcdm3 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpcdm2 : rk(Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpcdeq HACApacDpcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpcdmtmp;try rewrite HT2 in HACApacDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDpcdm3 : rk(Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApacDDpcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpcdeq HCApacDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: D :: cd :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpcdmtmp;try rewrite HT2 in HCApacDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCApacDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApacDpcdM3 : rk(Ap :: ac :: Dp :: cd :: nil) <= 3).
{
	assert(HApCpacDpcdeq : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) = 3) by (apply LApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpacDpcdMtmp : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApCpacDpcdeq HApCpacDpcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) 3 3 HApCpacDpcdMtmp Hcomp Hincl);apply HT.
}

assert(HApacDpcdM : rk(Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpcdm : rk(Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpcdeq HApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpcd requis par la preuve de (?)OoABCApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacDpcdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacDpcdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacDpcdeq HOoABCApCpacDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpbcDpcd *)
(* dans constructLemma(), requis par LBpCpbcDpcd *)
(* dans constructLemma(), requis par LOoCBpCpbcDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpCpbcDpcdm4 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDpeq : rk(Oo :: B :: C :: Dp :: nil) = 4) by (apply LOoBCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDpmtmp : rk(Oo :: B :: C :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCDpeq HOoBCDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: Dp :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: Dp :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoBCDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpCpbcDpcdM : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpCpbcDpcdm : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcDpcdm2 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpCpbcDpcdm3 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcDpcdmtmp;try rewrite HT2 in HOoBCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpCpbcDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcDpcdm4 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpCpbcDpcdeq : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) = 4) by (apply LOoBCBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpCpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcDpcdmtmp;try rewrite HT2 in HOoBCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpCpbcDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

assert(HOoCBpCpbcDpcdM : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpCpbcDpcdm : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpCpbcDpcdeq HOoCBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbcDpcd requis par la preuve de (?)OoBCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpCpbcDpcd requis par la preuve de (?)OoCBpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpCpbcDpcdm2 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpbcDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpCpbcDpcdm3 : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbcDpcdeq HOoBCBpCpbcDpcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcDpcdmtmp;try rewrite HT2 in HOoBCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpCpbcDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBpCpbcDpcdm2 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoCBpCpbcDpcdmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoCBpCpbcDpcdeq HOoCBpCpbcDpcdm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: C :: Cp :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcDpcdmtmp;try rewrite HT2 in HOoCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) (Cp :: nil) 3 1 2 HOoCBpCpbcDpcdmtmp HCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBpCpbcDpcdM3 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) <= 3).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Bp :: Cp :: bc :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: Cp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: bc :: Cp :: Dp :: cd :: nil) ((Bp :: Cp :: bc :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: Cp :: bc :: nil) (Cp :: Dp :: cd :: nil) (Cp :: nil) 2 2 1 HBpCpbcMtmp HCpDpcdMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Cp :: Dp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp :: Dp ::   de rang : 3 et 3 *)
assert(HBpCpbcDpcdm3 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoCCpDpeq : rk(Oo :: C :: Cp :: Dp :: nil) = 3) by (apply LOoCCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDpMtmp : rk(Oo :: C :: Cp :: Dp :: nil) <= 3) by (solve_hyps_max HOoCCpDpeq HOoCCpDpM3).
	assert(HOoCBpCpbcDpcdeq : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) = 4) by (apply LOoCBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpCpbcDpcdmtmp : rk(Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpCpbcDpcdeq HOoCBpCpbcDpcdm4).
	assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hincl : incl (Cp :: Dp :: nil) (list_inter (Oo :: C :: Cp :: Dp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: C :: Cp :: Dp :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Dp :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: C :: Cp :: Dp :: nil) ++ (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpCpbcDpcdmtmp;try rewrite HT2 in HOoCBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: Dp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) (Cp :: Dp :: nil) 4 2 3 HOoCBpCpbcDpcdmtmp HCpDpmtmp HOoCCpDpMtmp Hincl); apply HT.
}

assert(HBpCpbcDpcdM : rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpCpbcDpcdm : rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpCpbcDpcdeq HBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm2 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm3 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm4 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpbcDDpcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpcdeq HOoCBpbcDDpcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpcdmtmp;try rewrite HT2 in HOoCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoBCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoABCApBpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDpcd requis par la preuve de (?)OoBCBpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDpcdm2 : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDpcdm3 : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDpcdeq HOoBCBpbcDpcdm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDpcdmtmp;try rewrite HT2 in HOoBCBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDpcdm2 : rk(Bp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDpcdmtmp : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDpcdeq HBCBpbcDpcdm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: Dp :: cd :: nil) (B :: C :: bc :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDpcdmtmp;try rewrite HT2 in HBCBpbcDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: Dp :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDpcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDpcdm3 : rk(Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpbcDDpcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpcdeq HCBpbcDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: D :: cd :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpcdmtmp;try rewrite HT2 in HCBpbcDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCBpbcDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpbcDpcdM3 : rk(Bp :: bc :: Dp :: cd :: nil) <= 3).
{
	assert(HBpCpbcDpcdeq : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) = 3) by (apply LBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpCpbcDpcdMtmp : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HBpCpbcDpcdeq HBpCpbcDpcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Bp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) 3 3 HBpCpbcDpcdMtmp Hcomp Hincl);apply HT.
}

assert(HBpbcDpcdM : rk(Bp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDpcdm : rk(Bp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDpcdeq HBpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoABCApBpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpbcDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpbcDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApacDDpcd *)
(* dans constructLemma(), requis par LOoCApacDDpcd *)
(* dans la couche 0 *)
Lemma LOoACApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApacDDpcdM : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApacDDpcdm : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpcd requis par la preuve de (?)OoCApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApacDDpcdeq : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApacDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApacDDpcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpcdmtmp;try rewrite HT2 in HOoACApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoCApacDDpcdM : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApacDDpcdm : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApacDDpcdeq HOoCApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpcdm2 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm3 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm4 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApacDDpcdeq : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) = 4) by (apply LOoCApacDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApacDDpcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpcdeq HOoCApacDDpcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpcdmtmp;try rewrite HT2 in HOoCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCApacDDpcdM : rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApacDDpcdm : rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCApacDDpcdeq HCApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDDpcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDDpcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpbcDDpcd *)
(* dans constructLemma(), requis par LOoCBpbcDDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpbcDDpcdM : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcDDpcdm : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpcd requis par la preuve de (?)OoCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpbcDDpcdeq : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

assert(HOoCBpbcDDpcdM : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpbcDDpcdm : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpbcDDpcdeq HOoCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm2 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm3 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm4 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpbcDDpcdeq : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoCBpbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpbcDDpcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpcdeq HOoCBpbcDDpcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpcdmtmp;try rewrite HT2 in HOoCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCBpbcDDpcdM : rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpbcDDpcdm : rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCBpbcDDpcdeq HCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LacDadcd *)
(* dans constructLemma(), requis par LAacDadcd *)
(* dans la couche 0 *)
Lemma LADadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCDadcd requis par la preuve de (?)ADadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadcd requis par la preuve de (?)OoABCDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDadcdm4 : rk(Oo :: A :: B :: C :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: D ::   de rang : 4 et 4 *)
assert(HADadcdm2 : rk(A :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABCDeq : rk(Oo :: A :: B :: C :: D :: nil) = 4) by (apply LOoABCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDMtmp : rk(Oo :: A :: B :: C :: D :: nil) <= 4) by (solve_hyps_max HOoABCDeq HOoABCDM4).
	assert(HOoABCDadcdmtmp : rk(Oo :: A :: B :: C :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCDadcdeq HOoABCDadcdm4).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: ad :: cd :: nil) (Oo :: A :: B :: C :: D :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: D :: A :: D :: ad :: cd :: nil) ((Oo :: A :: B :: C :: D :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDadcdmtmp;try rewrite HT2 in HOoABCDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: D :: nil) (A :: D :: ad :: cd :: nil) (A :: D :: nil) 4 2 4 HOoABCDadcdmtmp HADmtmp HOoABCDMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HADadcdM3 : rk(A :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (cd :: nil) (nil) 2 1 0 HADadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadcdm3 : rk(A :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}

assert(HADadcdM : rk(A :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadcdm : rk(A :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HADadcdeq HADadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadcdm2 : rk(A :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDadcdm3 : rk(A :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAacDadcdM3 : rk(A :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HAacDcdeq : rk(A :: ac :: D :: cd :: nil) = 3) by (apply LAacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacDcdMtmp : rk(A :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HAacDcdeq HAacDcdM3).
	assert(HADadcdeq : rk(A :: D :: ad :: cd :: nil) = 3) by (apply LADadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadcdMtmp : rk(A :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HADadcdeq HADadcdM3).
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hincl : incl (A :: D :: cd :: nil) (list_inter (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil) ((A :: ac :: D :: cd :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) (A :: D :: cd :: nil) 3 3 3 HAacDcdMtmp HADadcdMtmp HADcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAacDadcdM : rk(A :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDadcdm : rk(A :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAacDadcdeq HAacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour acDadcd requis par la preuve de (?)acDadcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CacDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour acDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadcdm2 : rk(A :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour acDadcd requis par la preuve de (?)acDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HacDadcdm2 : rk(ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAacDadcdmtmp : rk(A :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HAacDadcdeq HAacDadcdm2).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAacDadcdmtmp;try rewrite HT2 in HAacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 2 2 2 HAacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HacDadcdm3 : rk(ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCacDadcdmtmp : rk(C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HCacDadcdeq HCacDadcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: D :: cd :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ac :: D :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCacDadcdmtmp;try rewrite HT2 in HCacDadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ac :: D :: ad :: cd :: nil) (D :: cd :: nil) 3 2 2 HCacDadcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HacDadcdM3 : rk(ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HAacDadcdeq : rk(A :: ac :: D :: ad :: cd :: nil) = 3) by (apply LAacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacDadcdMtmp : rk(A :: ac :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HAacDadcdeq HAacDadcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (ac :: D :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (ac :: D :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HAacDadcdMtmp Hcomp Hincl);apply HT.
}

assert(HacDadcdM : rk(ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HacDadcdm : rk(ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HacDadcdeq HacDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LApacDpadcd *)
(* dans constructLemma(), requis par LApDpadcd *)
(* dans constructLemma(), requis par LCApDDpadcd *)
(* dans constructLemma(), requis par LOoCApDDpadcd *)
(* dans la couche 0 *)
Lemma LOoACApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpadcdm2 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApDDpadcdm3 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpadcdm4 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApDDpadcdM : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApDDpadcdm : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApDDpadcdm3 : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApDDpadcdm4 : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApDDpadcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpadcdmtmp;try rewrite HT2 in HOoACApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApDDpadcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoCApDDpadcdM : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApDDpadcdm : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApDDpadcdeq HOoCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApDDpadcdm2 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApDDpadcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HCApDDpadcdm3 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApDDpadcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm4).
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpadcdmtmp;try rewrite HT2 in HOoACApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: Dp :: nil) 4 2 3 HOoACApDDpadcdmtmp HApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApDDpadcdm4 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApDDpadcdeq : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApDDpadcdmtmp : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApDDpadcdeq HOoCApDDpadcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApDDpadcdmtmp;try rewrite HT2 in HOoCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCApDDpadcdM : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpadcdm : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpadcdm2 : rk(Ap :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApDpadcdM3 : rk(Ap :: Dp :: ad :: cd :: nil) <= 3).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: cd :: nil) ((Ap :: Dp :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (cd :: nil) (nil) 2 1 0 HApDpadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpadcdm3 : rk(Ap :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApDDpadcdeq : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApDDpadcdmtmp : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpadcdmtmp;try rewrite HT2 in HCApDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HApDpadcdM : rk(Ap :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadcdm : rk(Ap :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApDpadcdeq HApDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpadcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApacDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpadcdmtmp;try rewrite HT2 in HOoACApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpadcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpadcdm2 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm3 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm4 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApacDDpadcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpadcdeq HOoCApacDDpadcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpadcdmtmp;try rewrite HT2 in HOoCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDpadcdm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpadcdm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpadcdm2 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDpadcdm3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApacDDpadcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpadcdmtmp;try rewrite HT2 in HCApacDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCApacDDpadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApacDpadcdM3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3).
{
	assert(HApacDpcdeq : rk(Ap :: ac :: Dp :: cd :: nil) = 3) by (apply LApacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDpcdMtmp : rk(Ap :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApacDpcdeq HApacDpcdM3).
	assert(HApDpadcdeq : rk(Ap :: Dp :: ad :: cd :: nil) = 3) by (apply LApDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpadcdMtmp : rk(Ap :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApDpadcdeq HApDpadcdM3).
	assert(HApDpcdeq : rk(Ap :: Dp :: cd :: nil) = 3) by (apply LApDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpcdmtmp : rk(Ap :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HApDpcdeq HApDpcdm3).
	assert(Hincl : incl (Ap :: Dp :: cd :: nil) (list_inter (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil) ((Ap :: ac :: Dp :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: cd :: nil) 3 3 3 HApacDpcdMtmp HApDpadcdMtmp HApDpcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApacDpadcdM : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpadcdm : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpadcdeq HApacDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LApacDDpadcd *)
(* dans constructLemma(), requis par LCApacDDpadcd *)
(* dans constructLemma(), requis par LOoCApacDDpadcd *)
(* dans la couche 0 *)
Lemma LOoACApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpadcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApacDDpadcdM : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApacDDpadcdm : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApacDDpadcd requis par la preuve de (?)OoCApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm3 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 4 2 3 HOoABCApacDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Dp ::   de rang : 3 et 3 *)
assert(HOoCApacDDpadcdm4 : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApDpeq : rk(Oo :: A :: Ap :: Dp :: nil) = 3) by (apply LOoAApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDpMtmp : rk(Oo :: A :: Ap :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDpeq HOoAApDpM3).
	assert(HOoACApacDDpadcdeq : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApacDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm4).
	assert(HOoApDpeq : rk(Oo :: Ap :: Dp :: nil) = 3) by (apply LOoApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDpmtmp : rk(Oo :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoApDpeq HOoApDpm3).
	assert(Hincl : incl (Oo :: Ap :: Dp :: nil) (list_inter (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Dp :: Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Dp :: nil) ++ (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpadcdmtmp;try rewrite HT2 in HOoACApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Dp :: nil) (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Dp :: nil) 4 3 3 HOoACApacDDpadcdmtmp HOoApDpmtmp HOoAApDpMtmp Hincl); apply HT.
}

assert(HOoCApacDDpadcdM : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApacDDpadcdm : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApacDDpadcdeq HOoCApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HCApacDDpadcdm2 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm3 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm4 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApacDDpadcdeq : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoCApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApacDDpadcdmtmp : rk(Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApacDDpadcdeq HOoCApacDDpadcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApacDDpadcdmtmp;try rewrite HT2 in HOoCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApacDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCApacDDpadcdM : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApacDDpadcdm : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApacDDpadcd requis par la preuve de (?)OoApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacDDpadcd requis par la preuve de (?)OoApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacDDpadcd requis par la preuve de (?)OoABApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacDDpadcd requis par la preuve de (?)OoABApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpadcdm2 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoAApmtmp : rk(Oo :: A :: Ap :: nil) >= 2) by (solve_hyps_min HOoAApeq HOoAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HOoAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacDDpadcdm3 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoBApeq : rk(Oo :: B :: Ap :: nil) = 3) by (apply LOoBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApmtmp : rk(Oo :: B :: Ap :: nil) >= 3) by (solve_hyps_min HOoBApeq HOoBApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HOoBApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApacDDpadcd requis par la preuve de (?)OoApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoApacDDpadcdm2 : rk(Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacDDpadcdmtmp : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApacDDpadcdeq HOoABApacDDpadcdm3).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacDDpadcdmtmp;try rewrite HT2 in HOoABApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: nil) 3 2 3 HOoABApacDDpadcdmtmp HOoApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApacDDpadcdm3 : rk(Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoApaceq : rk(Oo :: Ap :: ac :: nil) = 3) by (apply LOoApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApacmtmp : rk(Oo :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoApaceq HOoApacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Ap :: ac :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Ap :: ac :: nil) (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HOoApacmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AAp requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  1 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 1) by (solve_hyps_min HAApeq HAApm1).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 1 3 HOoABCApacDDpadcdmtmp HAApmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACApeq : rk(A :: C :: Ap :: nil) = 3) by (apply LACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 3 3 HACApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDDpadcd requis par la preuve de (?)ApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDDpadcdm2 : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACApacDDpadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HApacDDpadcdm3 : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoApacDDpadcdmtmp : rk(Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoApacDDpadcdeq HOoApacDDpadcdm3).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApacDDpadcdmtmp;try rewrite HT2 in HOoApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 3 2 2 HOoApacDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDDpadcdm4 : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApacDDpadcdeq : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LCApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApacDDpadcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm4).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpadcdmtmp;try rewrite HT2 in HCApacDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (D :: cd :: nil) 4 2 2 HCApacDDpadcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HApacDDpadcdM : rk(Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDDpadcdm : rk(Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApacDDpadcdeq HApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: ad :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CacDadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Hacadcdm2 : rk(ac :: ad :: cd :: nil) >= 2).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCacDadcdmtmp : rk(C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HCacDadcdeq HCacDadcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: D :: cd :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ac :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCacDadcdmtmp;try rewrite HT2 in HCacDadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ac :: ad :: cd :: nil) (cd :: nil) 3 1 2 HCacDadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HacadcdM2 : rk(ac :: ad :: cd :: nil) <= 2).
{
	assert(HacDadcdeq : rk(ac :: D :: ad :: cd :: nil) = 3) by (apply LacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HacDadcdMtmp : rk(ac :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HacDadcdeq HacDadcdM3).
	assert(HApacDpadcdeq : rk(Ap :: ac :: Dp :: ad :: cd :: nil) = 3) by (apply LApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDpadcdMtmp : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApacDpadcdeq HApacDpadcdM3).
	assert(HApacDDpadcdeq : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDDpadcdmtmp : rk(Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HApacDDpadcdeq HApacDDpadcdm4).
	assert(Hincl : incl (ac :: ad :: cd :: nil) (list_inter (ac :: D :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: D :: Dp :: ad :: cd :: nil) (ac :: D :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: D :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil) ((ac :: D :: ad :: cd :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApacDDpadcdmtmp;try rewrite HT2 in HApacDDpadcdmtmp.
	assert(HT := rule_3 (ac :: D :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: ad :: cd :: nil) 3 3 4 HacDadcdMtmp HApacDpadcdMtmp HApacDDpadcdmtmp Hincl);apply HT.
}


assert(HacadcdM : rk(ac :: ad :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hacadcdeq HacadcdM3).
assert(Hacadcdm : rk(ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Hacadcdeq Hacadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbcadcd *)
(* dans constructLemma(), requis par LACabacbcadcd *)
(* dans la couche 0 *)
Lemma LABCabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCabacbcadcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HABCadeq : rk(A :: B :: C :: ad :: nil) = 4) by (apply LABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCadmtmp : rk(A :: B :: C :: ad :: nil) >= 4) by (solve_hyps_min HABCadeq HABCadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HABCadmtmp Hcomp Hincl);apply HT.
}

assert(HABCabacbcadcdM : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabacbcadcdm : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm4 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabacbcadcdeq : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LABCabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabacbcadcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HACabacbcadcdM : rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcadcdm : rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadcdm2 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadcdmtmp;try rewrite HT2 in HACabacbcadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -2*)
assert(HabacbcadcdM3 : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3).
{
	assert(Habacbceq : rk(ab :: ac :: bc :: nil) = 2) by (apply Labacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabacbcMtmp : rk(ab :: ac :: bc :: nil) <= 2) by (solve_hyps_max Habacbceq HabacbcM2).
	assert(Hacadcdeq : rk(ac :: ad :: cd :: nil) = 2) by (apply Lacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HacadcdMtmp : rk(ac :: ad :: cd :: nil) <= 2) by (solve_hyps_max Hacadcdeq HacadcdM2).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ac :: bc :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ac :: bc :: ac :: ad :: cd :: nil) ((ab :: ac :: bc :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil) (ac :: nil) 2 2 1 HabacbcMtmp HacadcdMtmp Hacmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : ac :: ad ::  de rang :  2 et 2 	 A : A :: C :: ac :: ad ::   de rang : 3 et 3 *)
assert(Habacbcadcdm3 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HACacadeq : rk(A :: C :: ac :: ad :: nil) = 3) by (apply LACacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacadMtmp : rk(A :: C :: ac :: ad :: nil) <= 3) by (solve_hyps_max HACacadeq HACacadM3).
	assert(HACabacbcadcdeq : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LACabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabacbcadcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm4).
	assert(Hacadeq : rk(ac :: ad :: nil) = 2) by (apply Lacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Hacadmtmp : rk(ac :: ad :: nil) >= 2) by (solve_hyps_min Hacadeq Hacadm2).
	assert(Hincl : incl (ac :: ad :: nil) (list_inter (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: C :: ac :: ad :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadcdmtmp;try rewrite HT2 in HACabacbcadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ac :: ad :: nil) 4 2 3 HACabacbcadcdmtmp Hacadmtmp HACacadMtmp Hincl); apply HT.
}

assert(HabacbcadcdM : rk(ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadcdm : rk(ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadcdeq Habacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcadcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDadcd requis par la preuve de (?)OoABCDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDadcdm4 : rk(Oo :: A :: B :: C :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDadcdM : rk(Oo :: A :: B :: C :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDadcdm : rk(Oo :: A :: B :: C :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCDadcdeq HOoABCDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HCacDadcdM : rk(C :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCacDadcdm : rk(C :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCacDadcdeq HCacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (A :: nil) 4 1 3 HOoABCApacDadcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACacDadcdM : rk(A :: C :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDadcdm : rk(A :: C :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACacDadcdeq HACacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LbcDbdcd *)
(* dans constructLemma(), requis par LBbcDbdcd *)
(* dans la couche 0 *)
Lemma LBDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm2 : rk(B :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: bd :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBDbdcdM3 : rk(B :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: D :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: D :: bd :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBDbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm3 : rk(B :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

assert(HBDbdcdM : rk(B :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBDbdcdm : rk(B :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBDbdcdeq HBDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDbdcdm2 : rk(B :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDbdcdm3 : rk(B :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBbcDbdcdM3 : rk(B :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBbcDcdeq : rk(B :: bc :: D :: cd :: nil) = 3) by (apply LBbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcDcdMtmp : rk(B :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBbcDcdeq HBbcDcdM3).
	assert(HBDbdcdeq : rk(B :: D :: bd :: cd :: nil) = 3) by (apply LBDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDbdcdMtmp : rk(B :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBDbdcdeq HBDbdcdM3).
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hincl : incl (B :: D :: cd :: nil) (list_inter (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil) ((B :: bc :: D :: cd :: nil) ++ (B :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) (B :: D :: cd :: nil) 3 3 3 HBbcDcdMtmp HBDbdcdMtmp HBDcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBbcDbdcdM : rk(B :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDbdcdm : rk(B :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDbdcdeq HBbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour bcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CbcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour bcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDbdcdm2 : rk(B :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour bcDbdcd requis par la preuve de (?)bcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HbcDbdcdm2 : rk(bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBbcDbdcdmtmp : rk(B :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBbcDbdcdeq HBbcDbdcdm2).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBbcDbdcdmtmp;try rewrite HT2 in HBbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 2 2 2 HBbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HbcDbdcdm3 : rk(bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCbcDbdcdmtmp : rk(C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: D :: cd :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: bc :: D :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCbcDbdcdmtmp;try rewrite HT2 in HCbcDbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (bc :: D :: bd :: cd :: nil) (D :: cd :: nil) 3 2 2 HCbcDbdcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HbcDbdcdM3 : rk(bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBbcDbdcdeq : rk(B :: bc :: D :: bd :: cd :: nil) = 3) by (apply LBbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcDbdcdMtmp : rk(B :: bc :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBbcDbdcdeq HBbcDbdcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (bc :: D :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (bc :: D :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBbcDbdcdMtmp Hcomp Hincl);apply HT.
}

assert(HbcDbdcdM : rk(bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HbcDbdcdm : rk(bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HbcDbdcdeq HbcDbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBpbcDpbdcd *)
(* dans constructLemma(), requis par LBpDpbdcd *)
(* dans constructLemma(), requis par LCBpDDpbdcd *)
(* dans constructLemma(), requis par LOoCBpDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoBCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpDDpbdcdM : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpDDpbdcdm : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpDDpbdcd requis par la preuve de (?)OoCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpDDpbdcdm2 : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDDpbdcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpDDpbdcdm3 : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpDDpbdcdm4 : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpDDpbdcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpDDpbdcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

assert(HOoCBpDDpbdcdM : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpDDpbdcdm : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpDDpbdcdeq HOoCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpDDpbdcdm2 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HCBpDDpbdcdm3 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpDDpbdcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm4).
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (Bp :: Dp :: nil) 4 2 3 HOoBCBpDDpbdcdmtmp HBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpDDpbdcdm4 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpDDpbdcdeq : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpDDpbdcdmtmp : rk(Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpDDpbdcdeq HOoCBpDDpbdcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpDDpbdcdmtmp;try rewrite HT2 in HOoCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCBpDDpbdcdM : rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpDDpbdcdm : rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCBpDDpbdcdeq HCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDpbdcdm2 : rk(Bp :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: Dp :: bd :: cd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBpDpbdcdM3 : rk(Bp :: Dp :: bd :: cd :: nil) <= 3).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: Dp :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: Dp :: bd :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Dp :: bd :: cd :: nil) ((Bp :: Dp :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: Dp :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBpDpbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpDpbdcdm3 : rk(Bp :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpDDpbdcdeq : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpDDpbdcdmtmp : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpDDpbdcdeq HCBpDDpbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpDDpbdcdmtmp;try rewrite HT2 in HCBpDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCBpDDpbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HBpDpbdcdM : rk(Bp :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpDpbdcdm : rk(Bp :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpDpbdcdeq HBpDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: Dp :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpbdcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpbdcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm2 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm3 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm4 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpbcDDpbdcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpbdcdeq HOoCBpbcDDpbdcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoABCApBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm2 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm3 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDpbdcdeq HOoBCBpbcDpbdcdm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDpbdcdm2 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDpbdcdmtmp : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDpbdcdeq HBCBpbcDpbdcdm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: C :: bc :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDpbdcdmtmp;try rewrite HT2 in HBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDpbdcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDpbdcdm3 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpbcDDpbdcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpbdcdmtmp;try rewrite HT2 in HCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCBpbcDDpbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBpbcDpbdcdM3 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) <= 3).
{
	assert(HBpbcDpcdeq : rk(Bp :: bc :: Dp :: cd :: nil) = 3) by (apply LBpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpbcDpcdMtmp : rk(Bp :: bc :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HBpbcDpcdeq HBpbcDpcdM3).
	assert(HBpDpbdcdeq : rk(Bp :: Dp :: bd :: cd :: nil) = 3) by (apply LBpDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpbdcdMtmp : rk(Bp :: Dp :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBpDpbdcdeq HBpDpbdcdM3).
	assert(HBpDpcdeq : rk(Bp :: Dp :: cd :: nil) = 3) by (apply LBpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpcdmtmp : rk(Bp :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBpDpcdeq HBpDpcdm3).
	assert(Hincl : incl (Bp :: Dp :: cd :: nil) (list_inter (Bp :: bc :: Dp :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: bc :: Dp :: bd :: cd :: nil) (Bp :: bc :: Dp :: cd :: Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: bc :: Dp :: cd :: Bp :: Dp :: bd :: cd :: nil) ((Bp :: bc :: Dp :: cd :: nil) ++ (Bp :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: bc :: Dp :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil) (Bp :: Dp :: cd :: nil) 3 3 3 HBpbcDpcdMtmp HBpDpbdcdMtmp HBpDpcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBpbcDpbdcdM : rk(Bp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDpbdcdm : rk(Bp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDpbdcdeq HBpbcDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBpbcDDpbdcd *)
(* dans constructLemma(), requis par LCBpbcDDpbdcd *)
(* dans constructLemma(), requis par LOoCBpbcDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoBCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpbcDDpbdcdM : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcDDpbdcdm : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpbcDDpbdcd requis par la preuve de (?)OoCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm2 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoCBpbcDDpbdcdm3 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Bp :: Dp ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HOoCBpbcDDpbdcdm4 : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBBpDpeq : rk(Oo :: B :: Bp :: Dp :: nil) = 3) by (apply LOoBBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDpMtmp : rk(Oo :: B :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDpeq HOoBBpDpM3).
	assert(HOoBCBpbcDDpbdcdeq : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm4).
	assert(HOoBpDpeq : rk(Oo :: Bp :: Dp :: nil) = 3) by (apply LOoBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpDpmtmp : rk(Oo :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HOoBpDpeq HOoBpDpm3).
	assert(Hincl : incl (Oo :: Bp :: Dp :: nil) (list_inter (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Dp :: Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: Dp :: nil) ++ (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: Dp :: nil) (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: Dp :: nil) 4 3 3 HOoBCBpbcDDpbdcdmtmp HOoBpDpmtmp HOoBBpDpMtmp Hincl); apply HT.
}

assert(HOoCBpbcDDpbdcdM : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpbcDDpbdcdm : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoCBpbcDDpbdcdeq HOoCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm2 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm3 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm4 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCBpbcDDpbdcdeq : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpbcDDpbdcdmtmp : rk(Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoCBpbcDDpbdcdeq HOoCBpbcDDpbdcdm4).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCBpbcDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCBpbcDDpbdcdM : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpbcDDpbdcdm : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBpbcDDpbdcd requis par la preuve de (?)OoBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpbcDDpbdcd requis par la preuve de (?)OoBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApBpbcDDpbdcd requis par la preuve de (?)OoBBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCApBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbcDDpbdcd requis par la preuve de (?)OoBCApBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcDDpbdcdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpbcDDpbdcd requis par la preuve de (?)OoBBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : C :: Ap ::   de rang : 2 et 2 *)
assert(HOoBBpbcDDpbdcdm2 : rk(Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApMtmp : rk(C :: Ap :: nil) <= 2) by (solve_hyps_max HCApeq HCApM2).
	assert(HOoBCApBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApBpbcDDpbdcdeq HOoBCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: Ap :: Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((C :: Ap :: nil) ++ (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (C :: Ap :: nil) (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoBCApBpbcDDpbdcdmtmp Hmtmp HCApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBpbcDDpbdcd requis par la preuve de (?)OoBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  2 et 4 	 AiB : Oo :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoBpbcDDpbdcdm2 : rk(Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBBpbcDDpbdcdmtmp : rk(Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2) by (solve_hyps_min HOoBBpbcDDpbdcdeq HOoBBpbcDDpbdcdm2).
	assert(HOoBpeq : rk(Oo :: Bp :: nil) = 2) by (apply LOoBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpmtmp : rk(Oo :: Bp :: nil) >= 2) by (solve_hyps_min HOoBpeq HOoBpm2).
	assert(Hincl : incl (Oo :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Bp :: nil) 2 2 2 HOoBBpbcDDpbdcdmtmp HOoBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBpbcDDpbdcdm3 : rk(Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBpbceq : rk(Oo :: Bp :: bc :: nil) = 3) by (apply LOoBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpbcmtmp : rk(Oo :: Bp :: bc :: nil) >= 3) by (solve_hyps_min HOoBpbceq HOoBpbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: Bp :: bc :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: Bp :: bc :: nil) (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 3 3 HOoBpbcmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBBpeq : rk(B :: Bp :: nil) = 2) by (apply LBBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDDpbdcd requis par la preuve de (?)BpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDDpbdcdm2 : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDDpbdcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBpbcDDpbdcdm3 : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBpbcDDpbdcdmtmp : rk(Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBpbcDDpbdcdeq HOoBpbcDDpbdcdm3).
	assert(HDDpeq : rk(D :: Dp :: nil) = 2) by (apply LDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: D :: Dp :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: Dp :: nil) 3 2 2 HOoBpbcDDpbdcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: cd ::  de rang :  2 et 2 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDDpbdcdm4 : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpbcDDpbdcdeq : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpbcDDpbdcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm4).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpbdcdmtmp;try rewrite HT2 in HCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (D :: cd :: nil) 4 2 2 HCBpbcDDpbdcdmtmp HDcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HBpbcDDpbdcdM : rk(Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDDpbdcdm : rk(Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDDpbdcdeq HBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bc :: bd :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CbcDbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Hbcbdcdm2 : rk(bc :: bd :: cd :: nil) >= 2).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCbcDbdcdmtmp : rk(C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: D :: cd :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: bc :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCbcDbdcdmtmp;try rewrite HT2 in HCbcDbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (bc :: bd :: cd :: nil) (cd :: nil) 3 1 2 HCbcDbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HbcbdcdM2 : rk(bc :: bd :: cd :: nil) <= 2).
{
	assert(HbcDbdcdeq : rk(bc :: D :: bd :: cd :: nil) = 3) by (apply LbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HbcDbdcdMtmp : rk(bc :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HbcDbdcdeq HbcDbdcdM3).
	assert(HBpbcDpbdcdeq : rk(Bp :: bc :: Dp :: bd :: cd :: nil) = 3) by (apply LBpbcDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpbcDpbdcdMtmp : rk(Bp :: bc :: Dp :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBpbcDpbdcdeq HBpbcDpbdcdM3).
	assert(HBpbcDDpbdcdeq : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpbcDDpbdcdmtmp : rk(Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBpbcDDpbdcdeq HBpbcDDpbdcdm4).
	assert(Hincl : incl (bc :: bd :: cd :: nil) (list_inter (bc :: D :: bd :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: bc :: D :: Dp :: bd :: cd :: nil) (bc :: D :: bd :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (bc :: D :: bd :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil) ((bc :: D :: bd :: cd :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpbcDDpbdcdmtmp;try rewrite HT2 in HBpbcDDpbdcdmtmp.
	assert(HT := rule_3 (bc :: D :: bd :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (bc :: bd :: cd :: nil) 3 3 4 HbcDbdcdMtmp HBpbcDpbdcdMtmp HBpbcDDpbdcdmtmp Hincl);apply HT.
}


assert(HbcbdcdM : rk(bc :: bd :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hbcbdcdeq HbcbdcdM3).
assert(Hbcbdcdm : rk(bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Hbcbdcdeq Hbcbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HCbcDbdcdM : rk(C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdcdm : rk(C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBCbcDbdcdM : rk(B :: C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdcdm : rk(B :: C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDbdcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoABCApBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApBpbcDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoABCApBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbcDDpbdcd requis par la preuve de (?)OoBCApBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoABCApBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOoApeq : rk(Oo :: Ap :: nil) = 2) by (apply LOoAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApmtmp : rk(Oo :: Ap :: nil) >= 2) by (solve_hyps_min HOoApeq HOoApm2).
	assert(Hincl : incl (Oo :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: Ap :: nil) 4 2 2 HOoABCApBpbcDDpbdcdmtmp HOoApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCApBpbcDDpbdcdM : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpbcDDpbdcdm : rk(Oo :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApBpbcDDpbdcdeq HOoBCApBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)OoABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCabacbcDadbdcd *)
(* dans constructLemma(), requis par LBCabacbcDadbdcd *)
(* dans la couche 0 *)
Lemma LABCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCabacbcDadbdcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HABCDmtmp Hcomp Hincl);apply HT.
}

assert(HABCabacbcDadbdcdM : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabacbcDadbdcdm : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm2 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabacbcDadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm3 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm4 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABCabacbcDadbdcdeq : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LABCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HABCabacbcDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

assert(HBCabacbcDadbdcdM : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCabacbcDadbdcdm : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCabacbcDadbdcdeq HBCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcDadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcDadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm2 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabacbcDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm3 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcDadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcDadbdcdeq HACabacbcDadbdcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcDadbdcdmtmp;try rewrite HT2 in HACabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (C :: ac :: nil) 3 2 2 HACabacbcDadbdcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm4 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCabacbcDadbdcdeq : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LBCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCabacbcDadbdcdmtmp : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCabacbcDadbdcdeq HBCabacbcDadbdcdm4).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabacbcDadbdcdmtmp;try rewrite HT2 in HBCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: bd :: nil) 4 2 2 HBCabacbcDadbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HCabacbcDadbdcdM : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCabacbcDadbdcdm : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCabacbcDadbdcdeq HCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcDadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcDadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(Oo :: A :: Ap ::  nil) = 2 -> rk(A :: B :: C :: Ap ::  nil) = 4 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: C :: Bp ::  nil) = 4 -> rk(Oo :: C :: Cp ::  nil) = 2 ->
rk(A :: B :: C :: Cp ::  nil) = 4 -> rk(Oo :: Ap :: Bp :: Cp ::  nil) = 4 -> rk(A :: B :: ab ::  nil) = 2 ->
rk(Ap :: Bp :: ab ::  nil) = 2 -> rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 ->
rk(B :: C :: bc ::  nil) = 2 -> rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 ->
rk(Oo :: A :: C :: D ::  nil) = 4 -> rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 ->
rk(Ap :: Bp :: Dp ::  nil) = 3 -> rk(Oo :: Ap :: Bp :: Dp ::  nil) = 4 -> rk(Ap :: Cp :: Dp ::  nil) = 3 ->
rk(Oo :: Ap :: Cp :: Dp ::  nil) = 4 -> rk(Bp :: Cp :: Dp ::  nil) = 3 -> rk(Oo :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: B :: D :: Dp ::  nil) = 4 ->
rk(A :: C :: D :: Dp ::  nil) = 4 -> rk(B :: C :: D :: Dp ::  nil) = 4 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HOoAApeq HABCApeq HOoBBpeq HABCBpeq HOoCCpeq HABCCpeq HOoApBpCpeq HABabeq HApBpabeq
HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HApBpDpeq HOoApBpDpeq
HApCpDpeq HOoApCpDpeq HBpCpDpeq HOoBpCpDpeq HApBpCpDpeq HOoDDpeq HABDDpeq HACDDpeq HBCDDpeq HADadeq
HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq .

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HACabacbcadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApabacbcadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 3 HOoABCApabacbcadbdcdmtmp HAmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadbdcdeq HABCabacbcadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadbdcdmtmp;try rewrite HT2 in HABCabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadbdcdm2 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadbdcdeq HACabacbcadbdcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadbdcdmtmp;try rewrite HT2 in HACabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadbdcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Habacbcadbdcdm3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCabacbcDadbdcdeq : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCabacbcDadbdcdmtmp : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCabacbcDadbdcdeq HCabacbcDadbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (C :: D :: cd :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCabacbcDadbdcdmtmp;try rewrite HT2 in HCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCabacbcDadbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HabacbcadbdcdM3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) <= 3).
{
	assert(Habadbdeq : rk(ab :: ad :: bd :: nil) = 2) by (apply Labadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabadbdMtmp : rk(ab :: ad :: bd :: nil) <= 2) by (solve_hyps_max Habadbdeq HabadbdM2).
	assert(Habacbcadcdeq : rk(ab :: ac :: bc :: ad :: cd :: nil) = 3) by (apply Labacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabacbcadcdMtmp : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3) by (solve_hyps_max Habacbcadcdeq HabacbcadcdM3).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil) ((ab :: ad :: bd :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ad :: nil) 2 3 2 HabadbdMtmp HabacbcadcdMtmp Habadmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HabacbcadbdcdM : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadbdcdm : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadbdcdeq Habacbcadbdcdm1).
intuition.
Qed.

