Load "preamble3D.v".


(* dans la couche 0 *)
Lemma LAB : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AB requis par la preuve de (?)AB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HABm2 : rk(A :: B :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: nil) (A :: B :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A :: Ap :: nil) ((A :: B :: nil) ++ (A :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApmtmp;try rewrite HT2 in HABApmtmp.
	assert(HT := rule_2 (A :: B :: nil) (A :: Ap :: nil) (A :: nil) 3 1 2 HABApmtmp HAmtmp HAApMtmp Hincl);apply HT.
}

assert(HABM : rk(A :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABeq HABM2).
assert(HABm : rk(A :: B ::  nil) >= 1) by (solve_hyps_min HABeq HABm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAC : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AC requis par la preuve de (?)AC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HACm2 : rk(A :: C :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: nil) (A :: C :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A :: Ap :: nil) ((A :: C :: nil) ++ (A :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApmtmp;try rewrite HT2 in HACApmtmp.
	assert(HT := rule_2 (A :: C :: nil) (A :: Ap :: nil) (A :: nil) 3 1 2 HACApmtmp HAmtmp HAApMtmp Hincl);apply HT.
}

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBC : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC requis par la preuve de (?)BC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HBCm2 : rk(B :: C :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 3) by (solve_hyps_min HBCBpeq HBCBpm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: nil) (B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: nil) (B :: C :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: B :: Bp :: nil) ((B :: C :: nil) ++ (B :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpmtmp;try rewrite HT2 in HBCBpmtmp.
	assert(HT := rule_2 (B :: C :: nil) (B :: Bp :: nil) (B :: nil) 3 1 2 HBCBpmtmp HBmtmp HBBpMtmp Hincl);apply HT.
}

assert(HBCM : rk(B :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCeq HBCM2).
assert(HBCm : rk(B :: C ::  nil) >= 1) by (solve_hyps_min HBCeq HBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)BAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HBApm2 : rk(B :: Ap :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (B :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: nil) (A :: Ap :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: Ap :: nil) ((A :: Ap :: nil) ++ (B :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApmtmp;try rewrite HT2 in HABApmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (B :: Ap :: nil) (Ap :: nil) 3 1 2 HABApmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HBApM : rk(B :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBApeq HBApM2).
assert(HBApm : rk(B :: Ap ::  nil) >= 1) by (solve_hyps_min HBApeq HBApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (B :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: Ap :: nil) ((B :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HBMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACAp *)
(* dans la couche 0 *)
Lemma LOoABCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApm4 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApM : rk(Oo :: A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApm : rk(Oo :: A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABCApeq HOoABCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

assert(HOoACApM : rk(Oo :: A :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApm : rk(Oo :: A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoACApeq HOoACApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Ap :: nil) (A :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: nil) (A :: Ap :: A :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: A :: Bp :: nil) ((A :: Ap :: nil) ++ (A :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpmtmp;try rewrite HT2 in HAApBpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (A :: Bp :: nil) (A :: nil) 3 1 2 HAApBpmtmp HAmtmp HAApMtmp Hincl); apply HT.
}

assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCBp *)
(* dans la couche 0 *)
Lemma LOoABCApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)OoABCApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpM : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpm : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBCBpM3 : rk(Oo :: B :: C :: Bp :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: nil) (C :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Bp :: nil) ((C :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HCMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpm2 : rk(Oo :: B :: C :: Bp :: nil) >= 2).
{
	assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Bp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpm3 : rk(Oo :: B :: C :: Bp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil) (Oo :: nil) 4 1 2 HOoABCApBpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCBpM : rk(Oo :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpm : rk(Oo :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBCBpeq HOoBCBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApBp requis par la preuve de (?)ApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HApBpm2 : rk(Ap :: Bp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: nil) (A :: Ap :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Ap :: Bp :: nil) ((A :: Ap :: nil) ++ (Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpmtmp;try rewrite HT2 in HAApBpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Ap :: Bp :: nil) (Ap :: nil) 3 1 2 HAApBpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApBp *)
(* dans la couche 0 *)
Lemma LOoABApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpm2 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABApBpM3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoBBpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpm3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApBpM : rk(Oo :: A :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpm : rk(Oo :: A :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABApBpeq HOoABApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBp requis par la preuve de (?)ABApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApBp requis par la preuve de (?)ABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBp requis par la preuve de (?)ABApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApBpm2 : rk(A :: B :: Ap :: Bp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Bp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApBpm3 : rk(A :: B :: Ap :: Bp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApBpM3 : rk(A :: B :: Ap :: Bp :: nil) <= 3).
{
	assert(HOoABApBpeq : rk(Oo :: A :: B :: Ap :: Bp :: nil) = 3) by (apply LOoABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApBpMtmp : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoABApBpeq HOoABApBpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HOoABApBpMtmp Hcomp Hincl);apply HT.
}

assert(HABApBpM : rk(A :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApBpm : rk(A :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HABApBpeq HABApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ACp requis par la preuve de (?)ACp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Cp ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HACpm2 : rk(A :: Cp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Ap :: nil) (A :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: nil) (A :: Ap :: A :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: A :: Cp :: nil) ((A :: Ap :: nil) ++ (A :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpmtmp;try rewrite HT2 in HAApCpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (A :: Cp :: nil) (A :: nil) 3 1 2 HAApCpmtmp HAmtmp HAApMtmp Hincl); apply HT.
}

assert(HACpM : rk(A :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACpeq HACpM2).
assert(HACpm : rk(A :: Cp ::  nil) >= 1) by (solve_hyps_min HACpeq HACpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BCp requis par la preuve de (?)BCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: Bp :: Cp ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HBCpm2 : rk(B :: Cp :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: nil) (B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: nil) (B :: Bp :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: B :: Cp :: nil) ((B :: Bp :: nil) ++ (B :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpmtmp;try rewrite HT2 in HBBpCpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (B :: Cp :: nil) (B :: nil) 3 1 2 HBBpCpmtmp HBmtmp HBBpMtmp Hincl); apply HT.
}

assert(HBCpM : rk(B :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCpeq HBCpM2).
assert(HBCpm : rk(B :: Cp ::  nil) >= 1) by (solve_hyps_min HBCpeq HBCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans la couche 0 *)
Lemma LOoABCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCp requis par la preuve de (?)OoABCCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpm4 : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpM : rk(Oo :: A :: B :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpm : rk(Oo :: A :: B :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCCpeq HOoABCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpm2 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpm3 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApCpeq HOoABApCpm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpmtmp;try rewrite HT2 in HOoABApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: nil) (A :: B :: nil) 3 2 3 HOoABApCpmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HABCpm3 : rk(A :: B :: Cp :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 4) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpmtmp : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCCpeq HOoABCCpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: nil) (A :: B :: Cp :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: Oo :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpmtmp;try rewrite HT2 in HOoABCCpmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil) (Cp :: nil) 4 1 2 HOoABCCpmtmp HCpmtmp HOoCCpMtmp Hincl);apply HT.
}

assert(HABCpM : rk(A :: B :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCpeq HABCpM3).
assert(HABCpm : rk(A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HABCpeq HABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApCp requis par la preuve de (?)ApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Cp ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HApCpm2 : rk(Ap :: Cp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: nil) (A :: Ap :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Ap :: Cp :: nil) ((A :: Ap :: nil) ++ (Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpmtmp;try rewrite HT2 in HAApCpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Ap :: Cp :: nil) (Ap :: nil) 3 1 2 HAApCpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HApCpM : rk(Ap :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApCpeq HApCpM2).
assert(HApCpm : rk(Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HApCpeq HApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApCp *)
(* dans la couche 0 *)
Lemma LOoABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCp requis par la preuve de (?)OoABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpM : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpm : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApCp *)
(* dans la couche 0 *)
Lemma LOoACApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApCpm2 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoACApCpM3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: C :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoCCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApCpm3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (Ap :: nil) 4 1 2 HOoABCApCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

assert(HOoACApCpM : rk(Oo :: A :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApCpm : rk(Oo :: A :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApCpeq HOoACApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApCp requis par la preuve de (?)BApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApCp requis par la preuve de (?)BApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApCpm2 : rk(B :: Ap :: Cp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: Cp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApCpm3 : rk(B :: Ap :: Cp :: nil) >= 3).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: Cp :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_2 (B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (Ap :: Cp :: nil) 4 2 3 HOoABCApCpmtmp HApCpmtmp HOoACApCpMtmp Hincl);apply HT.
}

assert(HBApCpM : rk(B :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApCpeq HBApCpM3).
assert(HBApCpm : rk(B :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HBApCpeq HBApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpm2 : rk(A :: B :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpm3 : rk(A :: B :: Ap :: Cp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HABApCpm4 : rk(A :: B :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (A :: Ap :: Cp :: nil) 4 3 3 HOoABCApCpmtmp HAApCpmtmp HOoACApCpMtmp Hincl);apply HT.
}

assert(HABApCpM : rk(A :: B :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpm : rk(A :: B :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABApCpeq HABApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpm2 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApCpm2 : rk(A :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApCpm3 : rk(A :: C :: Ap :: Cp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApCpmtmp : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABCApCpeq HABCApCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpmtmp;try rewrite HT2 in HABCApCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Cp :: nil) (Ap :: nil) 4 1 2 HABCApCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApCpM3 : rk(A :: C :: Ap :: Cp :: nil) <= 3).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) 3 3 HOoACApCpMtmp Hcomp Hincl);apply HT.
}

assert(HACApCpM : rk(A :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApCpm : rk(A :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HACApCpeq HACApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpm2 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpM : rk(A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpm : rk(A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABCApCpeq HABCApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAab *)
(* dans la couche 0 *)
Lemma LAApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBpab requis par la preuve de (?)AApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBpab requis par la preuve de (?)AApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpab requis par la preuve de (?)AApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApBpabM3 : rk(A :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: ab :: nil) ((A :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HAMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpabm2 : rk(A :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpabm3 : rk(A :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ab :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

assert(HAApBpabM : rk(A :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpabm : rk(A :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HAApBpabeq HAApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aab requis par la preuve de (?)Aab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAabm2 : rk(A :: ab :: nil) >= 2).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HAApBpabeq : rk(A :: Ap :: Bp :: ab :: nil) = 3) by (apply LAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpabmtmp : rk(A :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HAApBpabeq HAApBpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: nil) (A :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: Ap :: Bp :: ab :: nil) ((A :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabmtmp;try rewrite HT2 in HAApBpabmtmp.
	assert(HT := rule_2 (A :: ab :: nil) (Ap :: Bp :: ab :: nil) (ab :: nil) 3 1 2 HAApBpabmtmp Habmtmp HApBpabMtmp Hincl);apply HT.
}

assert(HAabM : rk(A :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAabeq HAabM2).
assert(HAabm : rk(A :: ab ::  nil) >= 1) by (solve_hyps_min HAabeq HAabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAab *)
(* dans constructLemma(), requis par LOoABab *)
(* dans la couche 0 *)
Lemma LOoABCCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpab requis par la preuve de (?)OoABCCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpabm4 : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpabM : rk(Oo :: A :: B :: C :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpabm : rk(Oo :: A :: B :: C :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCCpabeq HOoABCCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ab ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABabm3 : rk(Oo :: A :: B :: ab :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpabeq : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) = 4) by (apply LOoABCCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpabmtmp : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCCpabeq HOoABCCpabm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ab :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ab :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpabmtmp;try rewrite HT2 in HOoABCCpabmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: nil) (Oo :: nil) 4 1 2 HOoABCCpabmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HOoABabM : rk(Oo :: A :: B :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABabm : rk(Oo :: A :: B :: ab ::  nil) >= 1) by (solve_hyps_min HOoABabeq HOoABabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAab requis par la preuve de (?)OoAab pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpab requis par la preuve de (?)OoAab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpab requis par la preuve de (?)OoABCBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpabm4 : rk(Oo :: A :: B :: C :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAab requis par la preuve de (?)OoAab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoAabm2 : rk(Oo :: A :: ab :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpabmtmp : rk(Oo :: A :: B :: C :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCBpabeq HOoABCBpabm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ab :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: ab :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpabmtmp;try rewrite HT2 in HOoABCBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ab :: nil) (Oo :: nil) 4 1 3 HOoABCBpabmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoAabm3 : rk(Oo :: A :: ab :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabeq : rk(Oo :: A :: B :: ab :: nil) = 3) by (apply LOoABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoABabeq HOoABabm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (Oo :: A :: ab :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: ab :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: ab :: A :: B :: ab :: nil) ((Oo :: A :: ab :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: ab :: nil) (A :: B :: ab :: nil) (A :: ab :: nil) 3 2 2 HOoABabmtmp HAabmtmp HABabMtmp Hincl);apply HT.
}

assert(HOoAabM : rk(Oo :: A :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAabeq HOoAabM3).
assert(HOoAabm : rk(Oo :: A :: ab ::  nil) >= 1) by (solve_hyps_min HOoAabeq HOoAabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBab *)
(* dans la couche 0 *)
Lemma LBApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBApBpabM3 : rk(B :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Bp :: ab :: nil) ((B :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HBMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApBpabm2 : rk(B :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBApBpabm3 : rk(B :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HBApBpmtmp : rk(B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HBApBpeq HBApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil) 3 3 HBApBpmtmp Hcomp Hincl);apply HT.
}

assert(HBApBpabM : rk(B :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpabm : rk(B :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HBApBpabeq HBApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bab requis par la preuve de (?)Bab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBabm2 : rk(B :: ab :: nil) >= 2).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBApBpabeq : rk(B :: Ap :: Bp :: ab :: nil) = 3) by (apply LBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApBpabmtmp : rk(B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HBApBpabeq HBApBpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (B :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: Ap :: Bp :: ab :: nil) ((B :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpabmtmp;try rewrite HT2 in HBApBpabmtmp.
	assert(HT := rule_2 (B :: ab :: nil) (Ap :: Bp :: ab :: nil) (ab :: nil) 3 1 2 HBApBpabmtmp Habmtmp HApBpabMtmp Hincl);apply HT.
}

assert(HBabM : rk(B :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBabeq HBabM2).
assert(HBabm : rk(B :: ab ::  nil) >= 1) by (solve_hyps_min HBabeq HBabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBab requis par la preuve de (?)OoBab pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApab requis par la preuve de (?)OoBab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApab requis par la preuve de (?)OoABCApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBab requis par la preuve de (?)OoBab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBabm2 : rk(Oo :: B :: ab :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApabmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApabeq HOoABCApabm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: ab :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabmtmp;try rewrite HT2 in HOoABCApabmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ab :: nil) (Oo :: nil) 4 1 3 HOoABCApabmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoBabm3 : rk(Oo :: B :: ab :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabeq : rk(Oo :: A :: B :: ab :: nil) = 3) by (apply LOoABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoABabeq HOoABabm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (Oo :: B :: ab :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: B :: ab :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: ab :: A :: B :: ab :: nil) ((Oo :: B :: ab :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: B :: ab :: nil) (A :: B :: ab :: nil) (B :: ab :: nil) 3 2 2 HOoABabmtmp HBabmtmp HABabMtmp Hincl);apply HT.
}

assert(HOoBabM : rk(Oo :: B :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBabeq HOoBabM3).
assert(HOoBabm : rk(Oo :: B :: ab ::  nil) >= 1) by (solve_hyps_min HOoBabeq HOoBabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApab requis par la preuve de (?)OoAApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApab requis par la preuve de (?)OoAApab pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApab requis par la preuve de (?)OoAApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApabm2 : rk(Oo :: A :: Ap :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApabM3 : rk(Oo :: A :: Ap :: ab :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HabMtmp : rk(ab :: nil) <= 1) by (solve_hyps_max Habeq HabM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (ab :: nil) (nil) 2 1 0 HOoAApMtmp HabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApabm3 : rk(Oo :: A :: Ap :: ab :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Ap :: ab :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApabM : rk(Oo :: A :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApabm : rk(Oo :: A :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoAApabeq HOoAApabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApab *)
(* dans la couche 0 *)
Lemma LOoABApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabm2 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABApabM3 : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: nil) (Oo :: A :: Ap :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil) (A :: nil) 2 2 1 HOoAApMtmp HABabMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabm3 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApabM : rk(Oo :: A :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabm : rk(Oo :: A :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoABApabeq HOoABApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApab requis par la preuve de (?)OoBApab pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApab requis par la preuve de (?)OoBApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApab requis par la preuve de (?)OoBApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApabm2 : rk(Oo :: B :: Ap :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApabm3 : rk(Oo :: B :: Ap :: ab :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Ap :: ab :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApabM3 : rk(Oo :: B :: Ap :: ab :: nil) <= 3).
{
	assert(HOoABApabeq : rk(Oo :: A :: B :: Ap :: ab :: nil) = 3) by (apply LOoABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabMtmp : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoABApabeq HOoABApabM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: ab :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: Ap :: ab :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 3 3 HOoABApabMtmp Hcomp Hincl);apply HT.
}

assert(HOoBApabM : rk(Oo :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApabm : rk(Oo :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoBApabeq HOoBApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApab requis par la preuve de (?)OoABCApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabM : rk(Oo :: A :: B :: C :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabm : rk(Oo :: A :: B :: C :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApabeq HOoABCApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpab requis par la preuve de (?)OoABCBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpabm4 : rk(Oo :: A :: B :: C :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpabM : rk(Oo :: A :: B :: C :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpabm : rk(Oo :: A :: B :: C :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCBpabeq HOoABCBpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpab *)
(* dans la couche 0 *)
Lemma LABCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Cp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCpab requis par la preuve de (?)ABCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpab requis par la preuve de (?)ABCpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)ABCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpab requis par la preuve de (?)ABCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCpabm2 : rk(A :: B :: Cp :: ab :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: nil) (Oo :: A :: B :: Ap :: A :: B :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Cp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabmtmp;try rewrite HT2 in HOoABApCpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: ab :: nil) (A :: B :: nil) 3 2 3 HOoABApCpabmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCpabM3 : rk(A :: B :: Cp :: ab :: nil) <= 3).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: ab :: nil) (Cp :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: ab :: nil) ((Cp :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HCpMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpabm3 : rk(A :: B :: Cp :: ab :: nil) >= 3).
{
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: Cp :: ab :: nil) 3 3 HABCpmtmp Hcomp Hincl);apply HT.
}

assert(HABCpabM : rk(A :: B :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpabm : rk(A :: B :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HABCpabeq HABCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cpab requis par la preuve de (?)Cpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Cp :: ab ::  de rang :  3 et 3 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCpabm2 : rk(Cp :: ab :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCpabeq : rk(A :: B :: Cp :: ab :: nil) = 3) by (apply LABCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpabmtmp : rk(A :: B :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HABCpabeq HABCpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: ab :: nil) (A :: B :: ab :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Cp :: ab :: nil) ((A :: B :: ab :: nil) ++ (Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCpabmtmp;try rewrite HT2 in HABCpabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Cp :: ab :: nil) (ab :: nil) 3 1 2 HABCpabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

assert(HCpabM : rk(Cp :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpabeq HCpabM2).
assert(HCpabm : rk(Cp :: ab ::  nil) >= 1) by (solve_hyps_min HCpabeq HCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAac *)
(* dans la couche 0 *)
Lemma LAApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApCpacM3 : rk(A :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Cp :: ac :: nil) ((A :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HAMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpacm2 : rk(A :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpacm3 : rk(A :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ac :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

assert(HAApCpacM : rk(A :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpacm : rk(A :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HAApCpaceq HAApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aac requis par la preuve de (?)Aac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAacm2 : rk(A :: ac :: nil) >= 2).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HAApCpaceq : rk(A :: Ap :: Cp :: ac :: nil) = 3) by (apply LAApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpacmtmp : rk(A :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HAApCpaceq HAApCpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: Ap :: Cp :: ac :: nil) ((A :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpacmtmp;try rewrite HT2 in HAApCpacmtmp.
	assert(HT := rule_2 (A :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HAApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HAacM : rk(A :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAaceq HAacM2).
assert(HAacm : rk(A :: ac ::  nil) >= 1) by (solve_hyps_min HAaceq HAacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAac *)
(* dans constructLemma(), requis par LOoACac *)
(* dans la couche 0 *)
Lemma LOoABCBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpac requis par la preuve de (?)OoABCBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpacm4 : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpacM : rk(Oo :: A :: B :: C :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpacm : rk(Oo :: A :: B :: C :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACac requis par la preuve de (?)OoACac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACac requis par la preuve de (?)OoACac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACac requis par la preuve de (?)OoACac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoACacM3 : rk(Oo :: A :: C :: ac :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: ac :: nil) (Oo :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: ac :: nil) ((Oo :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HOoMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACacm2 : rk(Oo :: A :: C :: ac :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: ac :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACacm3 : rk(Oo :: A :: C :: ac :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpaceq : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) = 4) by (apply LOoABCBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpacmtmp : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ac :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: ac :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpacmtmp;try rewrite HT2 in HOoABCBpacmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ac :: nil) (Oo :: nil) 4 1 2 HOoABCBpacmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HOoACacM : rk(Oo :: A :: C :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACacm : rk(Oo :: A :: C :: ac ::  nil) >= 1) by (solve_hyps_min HOoACaceq HOoACacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAac requis par la preuve de (?)OoAac pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAac requis par la preuve de (?)OoAac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoAacm2 : rk(Oo :: A :: ac :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpaceq : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) = 4) by (apply LOoABCBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpacmtmp : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ac :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: ac :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpacmtmp;try rewrite HT2 in HOoABCBpacmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ac :: nil) (Oo :: nil) 4 1 3 HOoABCBpacmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoAacm3 : rk(Oo :: A :: ac :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACaceq : rk(Oo :: A :: C :: ac :: nil) = 3) by (apply LOoACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACacmtmp : rk(Oo :: A :: C :: ac :: nil) >= 3) by (solve_hyps_min HOoACaceq HOoACacm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (Oo :: A :: ac :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: ac :: nil) (Oo :: A :: ac :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: ac :: A :: C :: ac :: nil) ((Oo :: A :: ac :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACacmtmp;try rewrite HT2 in HOoACacmtmp.
	assert(HT := rule_2 (Oo :: A :: ac :: nil) (A :: C :: ac :: nil) (A :: ac :: nil) 3 2 2 HOoACacmtmp HAacmtmp HACacMtmp Hincl);apply HT.
}

assert(HOoAacM : rk(Oo :: A :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAaceq HOoAacM3).
assert(HOoAacm : rk(Oo :: A :: ac ::  nil) >= 1) by (solve_hyps_min HOoAaceq HOoAacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABac *)
(* dans constructLemma(), requis par LABCac *)
(* dans la couche 0 *)
Lemma LOoABCApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacM : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacm : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApaceq HOoABCApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCac requis par la preuve de (?)ABCac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCac requis par la preuve de (?)ABCac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCac requis par la preuve de (?)ABCac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCacM3 : rk(A :: B :: C :: ac :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ac :: nil) (B :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: C :: ac :: nil) ((B :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HBMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCacm2 : rk(A :: B :: C :: ac :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: ac :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCacm3 : rk(A :: B :: C :: ac :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApaceq : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) = 4) by (apply LOoABCApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApaceq HOoABCApacm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacmtmp;try rewrite HT2 in HOoABCApacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ac :: nil) (A :: nil) 4 1 2 HOoABCApacmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCacM : rk(A :: B :: C :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCacm : rk(A :: B :: C :: ac ::  nil) >= 1) by (solve_hyps_min HABCaceq HABCacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABac requis par la preuve de (?)ABac pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApac requis par la preuve de (?)ABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacm2 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacm3 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABac requis par la preuve de (?)ABac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABacm2 : rk(A :: B :: ac :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacmtmp : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoABApaceq HOoABApacm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: nil) (Oo :: A :: B :: Ap :: A :: B :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacmtmp;try rewrite HT2 in HOoABApacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ac :: nil) (A :: B :: nil) 3 2 3 HOoABApacmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABacm3 : rk(A :: B :: ac :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HABCaceq : rk(A :: B :: C :: ac :: nil) = 3) by (apply LABCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCacmtmp : rk(A :: B :: C :: ac :: nil) >= 3) by (solve_hyps_min HABCaceq HABCacm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: B :: ac :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ac :: nil) (A :: B :: ac :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ac :: A :: C :: ac :: nil) ((A :: B :: ac :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCacmtmp;try rewrite HT2 in HABCacmtmp.
	assert(HT := rule_2 (A :: B :: ac :: nil) (A :: C :: ac :: nil) (A :: ac :: nil) 3 2 2 HABCacmtmp HAacmtmp HACacMtmp Hincl);apply HT.
}

assert(HABacM : rk(A :: B :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABaceq HABacM3).
assert(HABacm : rk(A :: B :: ac ::  nil) >= 1) by (solve_hyps_min HABaceq HABacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABac *)
(* dans la couche 0 *)
Lemma LOoABCac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCac requis par la preuve de (?)OoABCac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCacm4 : rk(Oo :: A :: B :: C :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCacM : rk(Oo :: A :: B :: C :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCacm : rk(Oo :: A :: B :: C :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCaceq HOoABCacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABac requis par la preuve de (?)OoABac pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpac requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpac requis par la preuve de (?)OoABCCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABac requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacm2 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacm3 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABac requis par la preuve de (?)OoABac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABacm2 : rk(Oo :: A :: B :: ac :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacmtmp : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoABApaceq HOoABApacm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacmtmp;try rewrite HT2 in HOoABApacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApacmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABacm3 : rk(Oo :: A :: B :: ac :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpacmtmp : rk(Oo :: A :: B :: C :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCCpaceq HOoABCCpacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ac :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpacmtmp;try rewrite HT2 in HOoABCCpacmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: nil) (Oo :: nil) 4 1 2 HOoABCCpacmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoABacm4 : rk(Oo :: A :: B :: ac :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoABCaceq : rk(Oo :: A :: B :: C :: ac :: nil) = 4) by (apply LOoABCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCacmtmp : rk(Oo :: A :: B :: C :: ac :: nil) >= 4) by (solve_hyps_min HOoABCaceq HOoABCacm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (Oo :: A :: B :: ac :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: nil) (Oo :: A :: B :: ac :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ac :: A :: C :: ac :: nil) ((Oo :: A :: B :: ac :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacmtmp;try rewrite HT2 in HOoABCacmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: ac :: nil) (A :: C :: ac :: nil) (A :: ac :: nil) 4 2 2 HOoABCacmtmp HAacmtmp HACacMtmp Hincl);apply HT.
}

assert(HOoABacM : rk(Oo :: A :: B :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABacm : rk(Oo :: A :: B :: ac ::  nil) >= 1) by (solve_hyps_min HOoABaceq HOoABacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCac *)
(* dans la couche 0 *)
Lemma LCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacm3 : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCApCpacM3 : rk(C :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Cp :: ac :: nil) ((C :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HCMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApCpacm2 : rk(C :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApCpacmtmp : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HBCApCpaceq HBCApCpacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: nil) (B :: Ap :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacmtmp;try rewrite HT2 in HBCApCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 3 1 2 HBCApCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HCApCpacm3 : rk(C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil) 3 3 HCApCpmtmp Hcomp Hincl);apply HT.
}

assert(HCApCpacM : rk(C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApCpacm : rk(C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HCApCpaceq HCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cac requis par la preuve de (?)Cac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCacm2 : rk(C :: ac :: nil) >= 2).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HCApCpaceq : rk(C :: Ap :: Cp :: ac :: nil) = 3) by (apply LCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApCpacmtmp : rk(C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HCApCpaceq HCApCpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (C :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: Ap :: Cp :: ac :: nil) ((C :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApCpacmtmp;try rewrite HT2 in HCApCpacmtmp.
	assert(HT := rule_2 (C :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HCApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HCacM : rk(C :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCaceq HCacM2).
assert(HCacm : rk(C :: ac ::  nil) >= 1) by (solve_hyps_min HCaceq HCacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApac requis par la preuve de (?)OoAApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApac requis par la preuve de (?)OoAApac pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApac requis par la preuve de (?)OoAApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApacm2 : rk(Oo :: A :: Ap :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApacM3 : rk(Oo :: A :: Ap :: ac :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HacMtmp : rk(ac :: nil) <= 1) by (solve_hyps_max Haceq HacM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (ac :: nil) (nil) 2 1 0 HOoAApMtmp HacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApacm3 : rk(Oo :: A :: Ap :: ac :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Ap :: ac :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApacM : rk(Oo :: A :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApacm : rk(Oo :: A :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoAApaceq HOoAApacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpac *)
(* dans la couche 0 *)
Lemma LACBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Bp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBpac requis par la preuve de (?)ACBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpac requis par la preuve de (?)ACBpac pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ACBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpac requis par la preuve de (?)OoABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpacm2 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpacm4 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpaceq HOoABCApBpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacmtmp;try rewrite HT2 in HOoABCApBpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpac requis par la preuve de (?)ACBpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ac ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACBpacm2 : rk(A :: C :: Bp :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpacmtmp : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HABCApBpaceq HABCApBpacm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ac :: nil) (B :: Ap :: A :: C :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Bp :: ac :: nil) ((B :: Ap :: nil) ++ (A :: C :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpacmtmp;try rewrite HT2 in HABCApBpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Bp :: ac :: nil) (nil) 4 0 2 HABCApBpacmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACBpacM3 : rk(A :: C :: Bp :: ac :: nil) <= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: ac :: nil) (Bp :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: C :: ac :: nil) ((Bp :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HBpMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ac ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HACBpacm3 : rk(A :: C :: Bp :: ac :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpaceq : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) = 4) by (apply LOoABCBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpacmtmp : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (A :: C :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ac :: nil) (Oo :: B :: Bp :: A :: C :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: A :: C :: Bp :: ac :: nil) ((Oo :: B :: Bp :: nil) ++ (A :: C :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpacmtmp;try rewrite HT2 in HOoABCBpacmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (A :: C :: Bp :: ac :: nil) (Bp :: nil) 4 1 2 HOoABCBpacmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HACBpacM : rk(A :: C :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpacm : rk(A :: C :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HACBpaceq HACBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bpac requis par la preuve de (?)Bpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Bp :: ac ::  de rang :  3 et 3 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HBpacm2 : rk(Bp :: ac :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACBpaceq : rk(A :: C :: Bp :: ac :: nil) = 3) by (apply LACBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACBpacmtmp : rk(A :: C :: Bp :: ac :: nil) >= 3) by (solve_hyps_min HACBpaceq HACBpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: ac :: nil) (A :: C :: ac :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Bp :: ac :: nil) ((A :: C :: ac :: nil) ++ (Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpacmtmp;try rewrite HT2 in HACBpacmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Bp :: ac :: nil) (ac :: nil) 3 1 2 HACBpacmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

assert(HBpacM : rk(Bp :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpaceq HBpacM2).
assert(HBpacm : rk(Bp :: ac ::  nil) >= 1) by (solve_hyps_min HBpaceq HBpacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApBpac *)
(* dans la couche 0 *)
Lemma LOoABCApBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpac requis par la preuve de (?)OoABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpacM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpacm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApBpaceq HOoABCApBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpacm2 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpacm4 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) = 4) by (apply LOoABCApBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpaceq HOoABCApBpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacmtmp;try rewrite HT2 in HOoABCApBpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpacM : rk(A :: B :: C :: Ap :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpacm : rk(A :: B :: C :: Ap :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HABCApBpaceq HABCApBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpac requis par la preuve de (?)OoABCCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpacM : rk(Oo :: A :: B :: C :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpacm : rk(Oo :: A :: B :: C :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCCpaceq HOoABCCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbc *)
(* dans la couche 0 *)
Lemma LBBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBBpCpbcM3 : rk(B :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Cp :: bc :: nil) ((B :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HBMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpbcm2 : rk(B :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpbcm3 : rk(B :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}

assert(HBBpCpbcM : rk(B :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpbcm : rk(B :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBBpCpbceq HBBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bbc requis par la preuve de (?)Bbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBbcm2 : rk(B :: bc :: nil) >= 2).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HBBpCpbceq : rk(B :: Bp :: Cp :: bc :: nil) = 3) by (apply LBBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpCpbcmtmp : rk(B :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HBBpCpbceq HBBpCpbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: Bp :: Cp :: bc :: nil) ((B :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpbcmtmp;try rewrite HT2 in HBBpCpbcmtmp.
	assert(HT := rule_2 (B :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HBBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}

assert(HBbcM : rk(B :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBbceq HBbcM2).
assert(HBbcm : rk(B :: bc ::  nil) >= 1) by (solve_hyps_min HBbceq HBbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbc *)
(* dans constructLemma(), requis par LCBpCpbc *)
(* dans constructLemma(), requis par LACApBpCpbc *)
(* dans constructLemma(), requis par LABCApBpCpbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpbc requis par la preuve de (?)ABCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpbc requis par la preuve de (?)ABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpbcm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpbcm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpCpbcM : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpbcm : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HABCApBpCpbceq HABCApBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpbc requis par la preuve de (?)ACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpbc requis par la preuve de (?)ACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpbc requis par la preuve de (?)ACApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpbcm2 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpbcm3 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpbceq HABCApBpCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcmtmp;try rewrite HT2 in HABCApBpCpbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HABCApBpCpbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpbcm4 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpbceq HABCApBpCpbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcmtmp;try rewrite HT2 in HABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HACApBpCpbcM : rk(A :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpCpbcm : rk(A :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HACApBpCpbceq HACApBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm2 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (nil) 4 0 2 HOoABCApBpCpbcmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCBpCpbcM3 : rk(C :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Cp :: bc :: nil) ((C :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HCMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpCpbcm2 : rk(C :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbceq HOoBCBpCpbcm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcmtmp;try rewrite HT2 in HOoBCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil) (Bp :: nil) 3 1 2 HOoBCBpCpbcmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HCBpCpbcm3 : rk(C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HACApBpCpbceq : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LACApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApBpCpbcmtmp : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HACApBpCpbceq HACApBpCpbcm4).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: C :: Ap :: Cp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: C :: Bp :: Cp :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpbcmtmp;try rewrite HT2 in HACApBpCpbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil) (C :: Cp :: nil) 4 2 3 HACApBpCpbcmtmp HCCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HCBpCpbcM : rk(C :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpCpbcm : rk(C :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HCBpCpbceq HCBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cbc requis par la preuve de (?)Cbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCbcm2 : rk(C :: bc :: nil) >= 2).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HCBpCpbceq : rk(C :: Bp :: Cp :: bc :: nil) = 3) by (apply LCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpCpbcmtmp : rk(C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HCBpCpbceq HCBpCpbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (C :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: Bp :: Cp :: bc :: nil) ((C :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpCpbcmtmp;try rewrite HT2 in HCBpCpbcmtmp.
	assert(HT := rule_2 (C :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HCBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}

assert(HCbcM : rk(C :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCbceq HCbcM2).
assert(HCbcm : rk(C :: bc ::  nil) >= 1) by (solve_hyps_min HCbceq HCbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACbc *)
(* dans constructLemma(), requis par LABCbc *)
(* dans la couche 0 *)
Lemma LOoABCApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbc requis par la preuve de (?)OoABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcM : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcm : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApbceq HOoABCApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCbcM3 : rk(A :: B :: C :: bc :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: bc :: nil) ((A :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HAMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCbcm2 : rk(A :: B :: C :: bc :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: bc :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCbcm3 : rk(A :: B :: C :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil) (A :: nil) 4 1 2 HOoABCApbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCbcM : rk(A :: B :: C :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCbcm : rk(A :: B :: C :: bc ::  nil) >= 1) by (solve_hyps_min HABCbceq HABCbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ACbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApbcm2 : rk(A :: B :: C :: Ap :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApbcm4 : rk(A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACbcm2 : rk(A :: C :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApbcmtmp : rk(A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HABCApbceq HABCApbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: bc :: nil) (B :: Ap :: A :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApbcmtmp;try rewrite HT2 in HABCApbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: bc :: nil) (nil) 4 0 2 HABCApbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HACbcm3 : rk(A :: C :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HABCbceq : rk(A :: B :: C :: bc :: nil) = 3) by (apply LABCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCbcmtmp : rk(A :: B :: C :: bc :: nil) >= 3) by (solve_hyps_min HABCbceq HABCbcm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (A :: C :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: C :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: bc :: B :: C :: bc :: nil) ((A :: C :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCbcmtmp;try rewrite HT2 in HABCbcmtmp.
	assert(HT := rule_2 (A :: C :: bc :: nil) (B :: C :: bc :: nil) (C :: bc :: nil) 3 2 2 HABCbcmtmp HCbcmtmp HBCbcMtmp Hincl);apply HT.
}

assert(HACbcM : rk(A :: C :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACbceq HACbcM3).
assert(HACbcm : rk(A :: C :: bc ::  nil) >= 1) by (solve_hyps_min HACbceq HACbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApbcm2 : rk(A :: B :: C :: Ap :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApbcm4 : rk(A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApbcM : rk(A :: B :: C :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApbcm : rk(A :: B :: C :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HABCApbceq HABCApbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpbc *)
(* dans constructLemma(), requis par LBCApCpbc *)
(* dans constructLemma(), requis par LABCApCpbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbc requis par la preuve de (?)OoABCApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpbc requis par la preuve de (?)ABCApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpbc requis par la preuve de (?)ABCApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpbcm2 : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpbcm4 : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpbcM : rk(A :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpbcm : rk(A :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HABCApCpbceq HABCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpbcm3 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBCApCpbcm4 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HABCApCpbceq : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApCpbcmtmp : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HABCApCpbceq HABCApCpbcm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: bc :: nil) (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpbcmtmp;try rewrite HT2 in HABCApCpbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HABCApCpbcmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HBCApCpbcM : rk(B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpbcm : rk(B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpbceq HBCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpbcm2 : rk(Ap :: Cp :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpbcm3 : rk(Ap :: Cp :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCApCpbceq : rk(B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LBCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApCpbcmtmp : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpbceq HBCApCpbcm4).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpbcmtmp;try rewrite HT2 in HBCApCpbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HApCpbcM : rk(Ap :: Cp :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpbceq HApCpbcM3).
assert(HApCpbcm : rk(Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HApCpbceq HApCpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACabbc *)
(* dans la couche 0 *)
Lemma LABCabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcm3 : rk(A :: B :: C :: ab :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCabbcM3 : rk(A :: B :: C :: ab :: bc :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: bc :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: C :: bc :: nil) (B :: nil) 2 2 1 HABabMtmp HBCbcMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCabbcM : rk(A :: B :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabbcm : rk(A :: B :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCabbceq HABCabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcm2 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcm4 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabbcm2 : rk(A :: C :: ab :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabbcmtmp : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApabbceq HABCApabbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: bc :: nil) (B :: Ap :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabbcmtmp;try rewrite HT2 in HABCApabbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: bc :: nil) (nil) 4 0 2 HABCApabbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc ::  de rang :  3 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcm3 : rk(A :: C :: ab :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcmtmp : rk(A :: B :: C :: ab :: bc :: nil) >= 3) by (solve_hyps_min HABCabbceq HABCabbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcmtmp;try rewrite HT2 in HABCabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACabbcM3 : rk(A :: C :: ab :: bc :: nil) <= 3).
{
	assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcMtmp : rk(A :: B :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HABCabbceq HABCabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil) 3 3 HABCabbcMtmp Hcomp Hincl);apply HT.
}

assert(HACabbcM : rk(A :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabbcm : rk(A :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HACabbceq HACabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabbc *)
(* dans la couche 0 *)
Lemma LOoABCApabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcm2 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcm4 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) = 4) by (apply LOoABCApabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabbcM : rk(A :: B :: C :: Ap :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabbcm : rk(A :: B :: C :: Ap :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCApabbceq HABCApabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpabbc *)
(* dans la couche 0 *)
Lemma LApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpabbcm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpabbcm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpabbcm2 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpabbcm3 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: nil) 4 1 2 HABCApBpCpabbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpabbcm4 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpabbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpabbcm2 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HApBpCpabbcm3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HACApBpCpabbcmtmp : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HACApBpCpabbceq HACApBpCpabbcm4).
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: C :: Ap :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpabbcmtmp;try rewrite HT2 in HACApBpCpabbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: Cp :: nil) 4 2 3 HACApBpCpabbcmtmp HApCpmtmp HACApCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApBpCpabbcM3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpCpbcMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApBpCpabbcM : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpabbcm : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApBpCpabbceq HApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm2 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabbcm2 : rk(Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabbcm3 : rk(Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabbceq HABApCpabbcm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabbcmtmp;try rewrite HT2 in HABApCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabbcM3 : rk(Ap :: Cp :: ab :: bc :: nil) <= 3).
{
	assert(HApBpCpabbceq : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) = 3) by (apply LApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpCpabbcMtmp : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApBpCpabbceq HApBpCpabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) 3 3 HApBpCpabbcMtmp Hcomp Hincl);apply HT.
}

assert(HApCpabbcM : rk(Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabbcm : rk(Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabbceq HApCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm2 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabbcM : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabbcm : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabbceq HABApCpabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBpCpabbc *)
(* dans constructLemma(), requis par LABCApBpCpabbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpabbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpabbcm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpabbcm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpabbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpCpabbcM : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpabbcm : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpabbcm2 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpabbcm3 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpabbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: nil) 4 1 2 HABCApBpCpabbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpabbcm4 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpabbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpabbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HACApBpCpabbcM : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpCpabbcm : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HACApBpCpabbceq HACApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacbcm2 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacbcm4 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacbcmtmp;try rewrite HT2 in HOoABCApacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacbcm2 : rk(A :: C :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacbcmtmp : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApacbceq HABCApacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: bc :: nil) (B :: Ap :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacbcmtmp;try rewrite HT2 in HABCApacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: bc :: nil) (nil) 4 0 2 HABCApacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HACacbcM3 : rk(A :: C :: ac :: bc :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (bc :: nil) (nil) 2 1 0 HACacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacbcm3 : rk(A :: C :: ac :: bc :: nil) >= 3).
{
	assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil) 3 3 HACbcmtmp Hcomp Hincl);apply HT.
}

assert(HACacbcM : rk(A :: C :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacbcm : rk(A :: C :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACacbceq HACacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacbc *)
(* dans la couche 0 *)
Lemma LOoABCApacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacbcM : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacbcm : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacbcm2 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacbcm4 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacbceq : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) = 4) by (apply LOoABCApacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacbcmtmp;try rewrite HT2 in HOoABCApacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacbcM : rk(A :: B :: C :: Ap :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacbcm : rk(A :: B :: C :: Ap :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApacbceq HABCApacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpacbc *)
(* dans constructLemma(), requis par LBCApCpacbc *)
(* dans constructLemma(), requis par LABCApCpacbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacbc requis par la preuve de (?)OoABCApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacbc requis par la preuve de (?)ABCApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacbc requis par la preuve de (?)ABCApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacbcm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacbcm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpacbcM : rk(A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpacbcm : rk(A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApCpacbceq HABCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacbcm3 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBCApCpacbcm4 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HABCApCpacbceq : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApCpacbcmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApCpacbceq HABCApCpacbcm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacbcmtmp;try rewrite HT2 in HABCApCpacbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HABCApCpacbcmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HBCApCpacbcM : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpacbcm : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpacbcm2 : rk(Ap :: Cp :: ac :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApCpacbcM3 : rk(Ap :: Cp :: ac :: bc :: nil) <= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Cp :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (bc :: nil) (nil) 2 1 0 HApCpacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpacbcm3 : rk(Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCApCpacbceq : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LBCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApCpacbcmtmp : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm4).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacbcmtmp;try rewrite HT2 in HBCApCpacbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpacbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HApCpacbcM : rk(Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacbcm : rk(Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpacbceq HApCpacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans constructLemma(), requis par LAabacbc *)
(* dans la couche 0 *)
Lemma LACabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACabacbcM3 : rk(A :: C :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HACabbceq : rk(A :: C :: ab :: bc :: nil) = 3) by (apply LACabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabbcMtmp : rk(A :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HACabbceq HACabbcM3).
	assert(HACacbceq : rk(A :: C :: ac :: bc :: nil) = 3) by (apply LACacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacbcMtmp : rk(A :: C :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACacbceq HACacbcM3).
	assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hincl : incl (A :: C :: bc :: nil) (list_inter (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil) ((A :: C :: ab :: bc :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil) (A :: C :: bc :: nil) 3 3 3 HACabbcMtmp HACacbcMtmp HACbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACabacbcM : rk(A :: C :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcm : rk(A :: C :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACabacbceq HACabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabacbc requis par la preuve de (?)OoABApabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabacbc requis par la preuve de (?)OoABApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcm2 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcm3 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabacbcm2 : rk(A :: B :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabacbcmtmp : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoABApabacbceq HOoABApabacbcm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabacbcmtmp;try rewrite HT2 in HOoABApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil) (A :: B :: nil) 3 2 3 HOoABApabacbcmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ac :: bc ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabacbcm2 : rk(A :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabacbcmtmp : rk(A :: B :: ab :: ac :: bc :: nil) >= 2) by (solve_hyps_min HABabacbceq HABabacbcm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabacbcmtmp;try rewrite HT2 in HABabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil) (A :: ab :: nil) 2 2 2 HABabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAabacbcm3 : rk(A :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil) (A :: ac :: nil) 3 2 2 HACabacbcmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabacbcM3 : rk(A :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HACabacbceq : rk(A :: C :: ab :: ac :: bc :: nil) = 3) by (apply LACabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabacbcMtmp : rk(A :: C :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACabacbceq HACabacbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil) 3 3 HACabacbcMtmp Hcomp Hincl);apply HT.
}

assert(HAabacbcM : rk(A :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabacbcm : rk(A :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAabacbceq HAabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans la couche 0 *)
Lemma LApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm2 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabacbcm2 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabacbcm3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabacbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApCpabacbcM3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HApCpabbceq : rk(Ap :: Cp :: ab :: bc :: nil) = 3) by (apply LApCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpabbcMtmp : rk(Ap :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApCpabbceq HApCpabbcM3).
	assert(HApCpacbceq : rk(Ap :: Cp :: ac :: bc :: nil) = 3) by (apply LApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpacbcMtmp : rk(Ap :: Cp :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpacbceq HApCpacbcM3).
	assert(HApCpbceq : rk(Ap :: Cp :: bc :: nil) = 3) by (apply LApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpbcmtmp : rk(Ap :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HApCpbceq HApCpbcm3).
	assert(Hincl : incl (Ap :: Cp :: bc :: nil) (list_inter (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ab :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: bc :: nil) 3 3 3 HApCpabbcMtmp HApCpacbcMtmp HApCpbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApCpabacbcM : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabacbcm : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabacbceq HApCpabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans constructLemma(), requis par LAApCpabacbc *)
(* dans la couche 0 *)
Lemma LABApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm2 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabacbcM : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabacbcm : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpabacbcm2 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpabacbcm3 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpabacbcm4 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabacbceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LABApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: nil) 4 2 2 HABApCpabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HAApCpabacbcM : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpabacbcm : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcm2 : rk(ab :: ac :: bc :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: nil) (ac :: nil) 3 1 2 HACabacbcmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabacbcM2 : rk(ab :: ac :: bc :: nil) <= 2).
{
	assert(HAabacbceq : rk(A :: ab :: ac :: bc :: nil) = 3) by (apply LAabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabacbcMtmp : rk(A :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HAabacbceq HAabacbcM3).
	assert(HApCpabacbceq : rk(Ap :: Cp :: ab :: ac :: bc :: nil) = 3) by (apply LApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpabacbcMtmp : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpabacbceq HApCpabacbcM3).
	assert(HAApCpabacbceq : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LAApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpabacbcmtmp : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm4).
	assert(Hincl : incl (ab :: ac :: bc :: nil) (list_inter (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: ab :: ac :: bc :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpabacbcmtmp;try rewrite HT2 in HAApCpabacbcmtmp.
	assert(HT := rule_3 (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: ac :: bc :: nil) 3 3 4 HAabacbcMtmp HApCpabacbcMtmp HAApCpabacbcmtmp Hincl);apply HT.
}


assert(HabacbcM : rk(ab :: ac :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habacbceq HabacbcM3).
assert(Habacbcm : rk(ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min Habacbceq Habacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbc *)
(* dans la couche 0 *)
Lemma LOoABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabacbcM : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcm : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApabacbceq HABCApabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoD *)
(* dans la couche 0 *)
Lemma LOoD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)OoD pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm2 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm3 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDmtmp : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3) by (solve_hyps_min HOoABApDeq HOoABApDm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDmtmp;try rewrite HT2 in HOoABApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil) (A :: B :: nil) 3 2 3 HOoABApDmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoD requis par la preuve de (?)OoD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HOoDm2 : rk(Oo :: D :: nil) >= 2).
{
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 3) by (solve_hyps_max HABDeq HABDM3).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HABDMtmp Hincl);apply HT.
}

assert(HOoDM : rk(Oo :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoDeq HOoDM2).
assert(HOoDm : rk(Oo :: D ::  nil) >= 1) by (solve_hyps_min HOoDeq HOoDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AD requis par la preuve de (?)AD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: D ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HADm2 : rk(A :: D :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Ap :: nil) (A :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: nil) (A :: Ap :: A :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: A :: D :: nil) ((A :: Ap :: nil) ++ (A :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDmtmp;try rewrite HT2 in HAApDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (A :: D :: nil) (A :: nil) 3 1 2 HAApDmtmp HAmtmp HAApMtmp Hincl); apply HT.
}

assert(HADM : rk(A :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HADeq HADM2).
assert(HADm : rk(A :: D ::  nil) >= 1) by (solve_hyps_min HADeq HADm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAD *)
(* dans la couche 0 *)
Lemma LBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BD requis par la preuve de (?)BD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: Bp :: D ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HBDm2 : rk(B :: D :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: D :: nil) (B :: Bp :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: B :: D :: nil) ((B :: Bp :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDmtmp;try rewrite HT2 in HBBpDmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (B :: D :: nil) (B :: nil) 3 1 2 HBBpDmtmp HBmtmp HBBpMtmp Hincl); apply HT.
}

assert(HBDM : rk(B :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBDeq HBDM2).
assert(HBDm : rk(B :: D ::  nil) >= 1) by (solve_hyps_min HBDeq HBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpD requis par la preuve de (?)OoAD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpD requis par la preuve de (?)OoABCBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDm4 : rk(Oo :: A :: B :: C :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoADm2 : rk(Oo :: A :: D :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpDmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCBpDeq HOoABCBpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: D :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDmtmp;try rewrite HT2 in HOoABCBpDmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: nil) (Oo :: nil) 4 1 3 HOoABCBpDmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 4*)
assert(HOoADm3 : rk(Oo :: A :: D :: nil) >= 3).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDMtmp : rk(B :: D :: nil) <= 2) by (solve_hyps_max HBDeq HBDM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: A :: D :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: B :: D :: nil) ((Oo :: A :: D :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: A :: D :: nil) (B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HBDMtmp Hincl);apply HT.
}

assert(HOoADM : rk(Oo :: A :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoADeq HOoADM3).
assert(HOoADm : rk(Oo :: A :: D ::  nil) >= 1) by (solve_hyps_min HOoADeq HOoADm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBDm2 : rk(Oo :: B :: D :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: D :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApDmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoBDm3 : rk(Oo :: B :: D :: nil) >= 3).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (A :: D :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: B :: D :: nil) ((A :: D :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HADMtmp Hincl); apply HT.
}

assert(HOoBDM : rk(Oo :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBDeq HOoBDM3).
assert(HOoBDm : rk(Oo :: B :: D ::  nil) >= 1) by (solve_hyps_min HOoBDeq HOoBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm2 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm3 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDmtmp : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3) by (solve_hyps_min HOoABApDeq HOoABApDm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDmtmp;try rewrite HT2 in HOoABApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil) (A :: B :: nil) 3 2 3 HOoABApDmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HABDm3 : rk(A :: B :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HABDM : rk(A :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABDeq HABDM3).
assert(HABDm : rk(A :: B :: D ::  nil) >= 1) by (solve_hyps_min HABDeq HABDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD requis par la preuve de (?)CD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : C :: Cp :: D ::  de rang :  3 et 3 	 AiB : C ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 2 et 2 *)
assert(HCDm2 : rk(C :: D :: nil) >= 2).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HCCpDmtmp : rk(C :: Cp :: D :: nil) >= 3) by (solve_hyps_min HCCpDeq HCCpDm3).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (C :: Cp :: nil) (C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: D :: nil) (C :: Cp :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: C :: D :: nil) ((C :: Cp :: nil) ++ (C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCCpDmtmp;try rewrite HT2 in HCCpDmtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (C :: D :: nil) (C :: nil) 3 1 2 HCCpDmtmp HCmtmp HCCpMtmp Hincl); apply HT.
}

assert(HCDM : rk(C :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCDeq HCDM2).
assert(HCDm : rk(C :: D ::  nil) >= 1) by (solve_hyps_min HCDeq HCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCDm2 : rk(Oo :: C :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApDmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoCDm3 : rk(Oo :: C :: D :: nil) >= 3).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (A :: D :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: C :: D :: nil) ((A :: D :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HADMtmp Hincl); apply HT.
}

assert(HOoCDM : rk(Oo :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCDeq HOoCDM3).
assert(HOoCDm : rk(Oo :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoCDeq HOoCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDm2 : rk(A :: B :: C :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACDm2 : rk(A :: C :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApDmtmp : rk(A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HABCApDeq HABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: nil) (B :: Ap :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDmtmp;try rewrite HT2 in HABCApDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: nil) (nil) 4 0 2 HABCApDmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HACDm3 : rk(A :: C :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (Oo :: D :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: C :: D :: nil) ((Oo :: D :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HACDM : rk(A :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACDeq HACDM3).
assert(HACDm : rk(A :: C :: D ::  nil) >= 1) by (solve_hyps_min HACDeq HACDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCDm2 : rk(B :: C :: D :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: D :: nil) (nil) 4 0 2 HOoABCApDmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HBCDm3 : rk(B :: C :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: nil) (Oo :: D :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: B :: C :: D :: nil) ((Oo :: D :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCDmtmp;try rewrite HT2 in HOoBCDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (B :: C :: D :: nil) (D :: nil) 4 1 2 HOoBCDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HBCDM : rk(B :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCDeq HBCDM3).
assert(HBCDm : rk(B :: C :: D ::  nil) >= 1) by (solve_hyps_min HBCDeq HBCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApD requis par la preuve de (?)ApD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: D ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HApDm2 : rk(Ap :: D :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: nil) (A :: Ap :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Ap :: D :: nil) ((A :: Ap :: nil) ++ (Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDmtmp;try rewrite HT2 in HAApDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Ap :: D :: nil) (Ap :: nil) 3 1 2 HAApDmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HApDM : rk(Ap :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApDeq HApDM2).
assert(HApDm : rk(Ap :: D ::  nil) >= 1) by (solve_hyps_min HApDeq HApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApD requis par la preuve de (?)OoAApD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApD requis par la preuve de (?)OoAApD pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApD requis par la preuve de (?)OoAApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDm2 : rk(Oo :: A :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApDM3 : rk(Oo :: A :: Ap :: D :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: nil) (Oo :: A :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (D :: nil) (nil) 2 1 0 HOoAApMtmp HDMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDm3 : rk(Oo :: A :: Ap :: D :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApDM : rk(Oo :: A :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDm : rk(Oo :: A :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HOoAApDeq HOoAApDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApD *)
(* dans la couche 0 *)
Lemma LOoABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDM : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDm : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApDeq HOoABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDm2 : rk(A :: B :: C :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApDM : rk(A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDm : rk(A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HABCApDeq HABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpD requis par la preuve de (?)BpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: Bp :: D ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HBpDm2 : rk(Bp :: D :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: D :: nil) (B :: Bp :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bp :: D :: nil) ((B :: Bp :: nil) ++ (Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDmtmp;try rewrite HT2 in HBBpDmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (Bp :: D :: nil) (Bp :: nil) 3 1 2 HBBpDmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

assert(HBpDM : rk(Bp :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpDeq HBpDM2).
assert(HBpDm : rk(Bp :: D ::  nil) >= 1) by (solve_hyps_min HBpDeq HBpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpD *)
(* dans la couche 0 *)
Lemma LOoABBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpD requis par la preuve de (?)OoABApBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpD requis par la preuve de (?)OoABApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDm2 : rk(Oo :: A :: B :: Ap :: Bp :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDm3 : rk(Oo :: A :: B :: Ap :: Bp :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: D ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABBpDm2 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpDmtmp : rk(Oo :: A :: B :: Ap :: Bp :: D :: nil) >= 3) by (solve_hyps_min HOoABApBpDeq HOoABApBpDm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpDmtmp;try rewrite HT2 in HOoABApBpDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApBpDmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDm3 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDm4 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABBpDM : rk(Oo :: A :: B :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpDm : rk(Oo :: A :: B :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABBpDeq HOoABBpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpD *)
(* dans la couche 0 *)
Lemma LOoBBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpD requis par la preuve de (?)OoBBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpD requis par la preuve de (?)OoBBpD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoBBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpD requis par la preuve de (?)OoBBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpDm2 : rk(Oo :: B :: Bp :: D :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDmtmp;try rewrite HT2 in HOoABCApBpDmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpDM3 : rk(Oo :: B :: Bp :: D :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: D :: nil) (Oo :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: nil) ((Oo :: B :: Bp :: nil) ++ (D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (D :: nil) (nil) 2 1 0 HOoBBpMtmp HDMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpDm3 : rk(Oo :: B :: Bp :: D :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBBpDM : rk(Oo :: B :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpDm : rk(Oo :: B :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoBBpDeq HOoBBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpD requis par la preuve de (?)ABpD pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpD requis par la preuve de (?)ABpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDm2 : rk(A :: Bp :: D :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: D :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpDm3 : rk(A :: Bp :: D :: nil) >= 3).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoABBpDeq : rk(Oo :: A :: B :: Bp :: D :: nil) = 4) by (apply LOoABBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpDmtmp : rk(Oo :: A :: B :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABBpDeq HOoABBpDm4).
	assert(HBpDeq : rk(Bp :: D :: nil) = 2) by (apply LBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDmtmp : rk(Bp :: D :: nil) >= 2) by (solve_hyps_min HBpDeq HBpDm2).
	assert(Hincl : incl (Bp :: D :: nil) (list_inter (A :: Bp :: D :: nil) (Oo :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: nil) (A :: Bp :: D :: Oo :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: D :: Oo :: B :: Bp :: D :: nil) ((A :: Bp :: D :: nil) ++ (Oo :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDmtmp;try rewrite HT2 in HOoABBpDmtmp.
	assert(HT := rule_2 (A :: Bp :: D :: nil) (Oo :: B :: Bp :: D :: nil) (Bp :: D :: nil) 4 2 3 HOoABBpDmtmp HBpDmtmp HOoBBpDMtmp Hincl);apply HT.
}

assert(HABpDM : rk(A :: Bp :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABpDeq HABpDM3).
assert(HABpDm : rk(A :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HABpDeq HABpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpD requis par la preuve de (?)OoABCBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDm4 : rk(Oo :: A :: B :: C :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDM : rk(Oo :: A :: B :: C :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDm : rk(Oo :: A :: B :: C :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCBpDeq HOoABCBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpD requis par la preuve de (?)CpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : C :: Cp :: D ::  de rang :  3 et 3 	 AiB : Cp ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 2 et 2 *)
assert(HCpDm2 : rk(Cp :: D :: nil) >= 2).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HCCpDmtmp : rk(C :: Cp :: D :: nil) >= 3) by (solve_hyps_min HCCpDeq HCCpDm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: D :: nil) (C :: Cp :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: Cp :: D :: nil) ((C :: Cp :: nil) ++ (Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCCpDmtmp;try rewrite HT2 in HCCpDmtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (Cp :: D :: nil) (Cp :: nil) 3 1 2 HCCpDmtmp HCpmtmp HCCpMtmp Hincl); apply HT.
}

assert(HCpDM : rk(Cp :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpDeq HCpDM2).
assert(HCpDm : rk(Cp :: D ::  nil) >= 1) by (solve_hyps_min HCpDeq HCpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpD *)
(* dans la couche 0 *)
Lemma LOoACCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Cp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpD requis par la preuve de (?)OoACCpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpD requis par la preuve de (?)OoABCBpCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpDm2 : rk(Oo :: A :: C :: Cp :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: D :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: D :: nil) (nil) 4 0 2 HOoABCApCpDmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpDm3 : rk(Oo :: A :: C :: Cp :: D :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpDmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCBpCpDeq HOoABCBpCpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: D :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpDmtmp;try rewrite HT2 in HOoABCBpCpDmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: D :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpDmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACCpDm4 : rk(Oo :: A :: C :: Cp :: D :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Cp :: D :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACCpDM : rk(Oo :: A :: C :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpDm : rk(Oo :: A :: C :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoACCpDeq HOoACCpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpD *)
(* dans la couche 0 *)
Lemma LOoCCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpD requis par la preuve de (?)OoCCpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpD requis par la preuve de (?)OoCCpD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoCCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpD requis par la preuve de (?)OoCCpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpDm2 : rk(Oo :: C :: Cp :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoCCpDM3 : rk(Oo :: C :: Cp :: D :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: D :: nil) ((Oo :: C :: Cp :: nil) ++ (D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (D :: nil) (nil) 2 1 0 HOoCCpMtmp HDMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCCpDm3 : rk(Oo :: C :: Cp :: D :: nil) >= 3).
{
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: D :: nil) (Oo :: C :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: D :: nil) (Oo :: C :: Cp :: D :: nil) 3 3 HOoCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoCCpDM : rk(Oo :: C :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpDm : rk(Oo :: C :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoCCpDeq HOoCCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpD requis par la preuve de (?)ACpD pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpD requis par la preuve de (?)ACpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDm2 : rk(A :: Cp :: D :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: D :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpDm3 : rk(A :: Cp :: D :: nil) >= 3).
{
	assert(HOoCCpDeq : rk(Oo :: C :: Cp :: D :: nil) = 3) by (apply LOoCCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDMtmp : rk(Oo :: C :: Cp :: D :: nil) <= 3) by (solve_hyps_max HOoCCpDeq HOoCCpDM3).
	assert(HOoACCpDeq : rk(Oo :: A :: C :: Cp :: D :: nil) = 4) by (apply LOoACCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACCpDmtmp : rk(Oo :: A :: C :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoACCpDeq HOoACCpDm4).
	assert(HCpDeq : rk(Cp :: D :: nil) = 2) by (apply LCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDmtmp : rk(Cp :: D :: nil) >= 2) by (solve_hyps_min HCpDeq HCpDm2).
	assert(Hincl : incl (Cp :: D :: nil) (list_inter (A :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: D :: nil) (A :: Cp :: D :: Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: D :: Oo :: C :: Cp :: D :: nil) ((A :: Cp :: D :: nil) ++ (Oo :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpDmtmp;try rewrite HT2 in HOoACCpDmtmp.
	assert(HT := rule_2 (A :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil) (Cp :: D :: nil) 4 2 3 HOoACCpDmtmp HCpDmtmp HOoCCpDMtmp Hincl);apply HT.
}

assert(HACpDM : rk(A :: Cp :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpDeq HACpDM3).
assert(HACpDm : rk(A :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HACpDeq HACpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCpD *)
(* dans la couche 0 *)
Lemma LOoBCCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Cp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpD requis par la preuve de (?)OoBCCpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoBCCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpD requis par la preuve de (?)OoBCCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpD requis par la preuve de (?)OoBCCpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpDm2 : rk(Oo :: B :: C :: Cp :: D :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: D :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil) (nil) 4 0 2 HOoABCApCpDmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpDm3 : rk(Oo :: B :: C :: Cp :: D :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil) (Oo :: nil) 4 1 2 HOoABCApCpDmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCCpDm4 : rk(Oo :: B :: C :: Cp :: D :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Cp :: D :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCCpDM : rk(Oo :: B :: C :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCCpDm : rk(Oo :: B :: C :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoBCCpDeq HOoBCCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Cp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCpD requis par la preuve de (?)BCpD pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCpD requis par la preuve de (?)BCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpDm2 : rk(B :: Cp :: D :: nil) >= 2).
{
	assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: nil) (B :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: nil) (B :: Cp :: D :: nil) 2 2 HBCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBCpDm3 : rk(B :: Cp :: D :: nil) >= 3).
{
	assert(HOoCCpDeq : rk(Oo :: C :: Cp :: D :: nil) = 3) by (apply LOoCCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDMtmp : rk(Oo :: C :: Cp :: D :: nil) <= 3) by (solve_hyps_max HOoCCpDeq HOoCCpDM3).
	assert(HOoBCCpDeq : rk(Oo :: B :: C :: Cp :: D :: nil) = 4) by (apply LOoBCCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCCpDmtmp : rk(Oo :: B :: C :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoBCCpDeq HOoBCCpDm4).
	assert(HCpDeq : rk(Cp :: D :: nil) = 2) by (apply LCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDmtmp : rk(Cp :: D :: nil) >= 2) by (solve_hyps_min HCpDeq HCpDm2).
	assert(Hincl : incl (Cp :: D :: nil) (list_inter (B :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: D :: nil) (B :: Cp :: D :: Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: D :: Oo :: C :: Cp :: D :: nil) ((B :: Cp :: D :: nil) ++ (Oo :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCCpDmtmp;try rewrite HT2 in HOoBCCpDmtmp.
	assert(HT := rule_2 (B :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil) (Cp :: D :: nil) 4 2 3 HOoBCCpDmtmp HCpDmtmp HOoCCpDMtmp Hincl);apply HT.
}

assert(HBCpDM : rk(B :: Cp :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCpDeq HBCpDM3).
assert(HBCpDm : rk(B :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HBCpDeq HBCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpDM : rk(Oo :: A :: B :: C :: Ap :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDm : rk(Oo :: A :: B :: C :: Ap :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpD requis par la preuve de (?)OoABCBpCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpDM : rk(Oo :: A :: B :: C :: Bp :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpDm : rk(Oo :: A :: B :: C :: Bp :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpDeq HOoABCBpCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApDp requis par la preuve de (?)ApDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Dp ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HApDpm2 : rk(Ap :: Dp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApDpmtmp : rk(A :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HAApDpeq HAApDpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: nil) (A :: Ap :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Ap :: Dp :: nil) ((A :: Ap :: nil) ++ (Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDpmtmp;try rewrite HT2 in HAApDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Ap :: Dp :: nil) (Ap :: nil) 3 1 2 HAApDpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HApDpM : rk(Ap :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApDpeq HApDpM2).
assert(HApDpm : rk(Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HApDpeq HApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpDp requis par la preuve de (?)BpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: Bp :: Dp ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HBpDpm2 : rk(Bp :: Dp :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBBpDpmtmp : rk(B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HBBpDpeq HBBpDpm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Dp :: nil) (B :: Bp :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bp :: Dp :: nil) ((B :: Bp :: nil) ++ (Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDpmtmp;try rewrite HT2 in HBBpDpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (Bp :: Dp :: nil) (Bp :: nil) 3 1 2 HBBpDpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

assert(HBpDpM : rk(Bp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpDpeq HBpDpM2).
assert(HBpDpm : rk(Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HBpDpeq HBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpDp requis par la preuve de (?)ApBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpDp requis par la preuve de (?)ApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpDpm2 : rk(Ap :: Bp :: Dp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: Dp :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -1 et -2*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Cp ::   de rang : 1 et 1 *)
assert(HApBpDpm3 : rk(Ap :: Bp :: Dp :: nil) >= 3).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HApBpCpDpmtmp : rk(Ap :: Bp :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (Ap :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) (Cp :: Ap :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Ap :: Bp :: Dp :: nil) ((Cp :: nil) ++ (Ap :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpDpmtmp;try rewrite HT2 in HApBpCpDpmtmp.
	assert(HT := rule_4 (Cp :: nil) (Ap :: Bp :: Dp :: nil) (nil) 4 0 1 HApBpCpDpmtmp Hmtmp HCpMtmp Hincl); apply HT.
}

assert(HApBpDpM : rk(Ap :: Bp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpDpeq HApBpDpM3).
assert(HApBpDpm : rk(Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HApBpDpeq HApBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpDp requis par la preuve de (?)CpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -1 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCpDpm2 : rk(Cp :: Dp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HApBpCpDpmtmp : rk(Ap :: Bp :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) (Ap :: Bp :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpDpmtmp;try rewrite HT2 in HApBpCpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Cp :: Dp :: nil) (nil) 4 0 2 HApBpCpDpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}

assert(HCpDpM : rk(Cp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpDpeq HCpDpM2).
assert(HCpDpm : rk(Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HCpDpeq HCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpDp *)
(* dans la couche 0 *)
Lemma LOoACCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpDDp requis par la preuve de (?)OoACCpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpDDp requis par la preuve de (?)OoACCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpDDp requis par la preuve de (?)OoABCBpCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpDDp requis par la preuve de (?)OoACCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoACCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoABCApCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpDDp requis par la preuve de (?)OoACCpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpDDpm2 : rk(Oo :: A :: C :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDDpeq HOoABCApCpDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDDpmtmp;try rewrite HT2 in HOoABCApCpDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApCpDDpmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpDDpm3 : rk(Oo :: A :: C :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpDDpmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpCpDDpeq HOoABCBpCpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpDDpmtmp;try rewrite HT2 in HOoABCBpCpDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpDDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACCpDDpm4 : rk(Oo :: A :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Cp :: D :: Dp :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACCpDDpM : rk(Oo :: A :: C :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpDDpm : rk(Oo :: A :: C :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACCpDDpeq HOoACCpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpDp *)
(* dans la couche 0 *)
Lemma LOoCCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpDDp requis par la preuve de (?)OoCCpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpDDp requis par la preuve de (?)OoCCpDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoCCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoABCApCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpDDp requis par la preuve de (?)OoCCpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpDDpm2 : rk(Oo :: C :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDDpeq HOoABCApCpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDDpmtmp;try rewrite HT2 in HOoABCApCpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: D :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDDpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoCCpDDpM3 : rk(Oo :: C :: Cp :: D :: Dp :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: D :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (Oo :: D :: Dp :: nil) (Oo :: nil) 2 2 1 HOoCCpMtmp HOoDDpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCCpDDpm3 : rk(Oo :: C :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: D :: nil) (Oo :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: D :: nil) (Oo :: C :: Cp :: D :: Dp :: nil) 3 3 HOoCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoCCpDDpM : rk(Oo :: C :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpDDpm : rk(Oo :: C :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCCpDDpeq HOoCCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpDp requis par la preuve de (?)ACpDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpDp requis par la preuve de (?)ACpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDpm2 : rk(A :: Cp :: Dp :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: Dp :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpDpm3 : rk(A :: Cp :: Dp :: nil) >= 3).
{
	assert(HOoCCpDDpeq : rk(Oo :: C :: Cp :: D :: Dp :: nil) = 3) by (apply LOoCCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDDpMtmp : rk(Oo :: C :: Cp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoCCpDDpeq HOoCCpDDpM3).
	assert(HOoACCpDDpeq : rk(Oo :: A :: C :: Cp :: D :: Dp :: nil) = 4) by (apply LOoACCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACCpDDpmtmp : rk(Oo :: A :: C :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACCpDDpeq HOoACCpDDpm4).
	assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hincl : incl (Cp :: Dp :: nil) (list_inter (A :: Cp :: Dp :: nil) (Oo :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: D :: Dp :: nil) (A :: Cp :: Dp :: Oo :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Dp :: Oo :: C :: Cp :: D :: Dp :: nil) ((A :: Cp :: Dp :: nil) ++ (Oo :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpDDpmtmp;try rewrite HT2 in HOoACCpDDpmtmp.
	assert(HT := rule_2 (A :: Cp :: Dp :: nil) (Oo :: C :: Cp :: D :: Dp :: nil) (Cp :: Dp :: nil) 4 2 3 HOoACCpDDpmtmp HCpDpmtmp HOoCCpDDpMtmp Hincl);apply HT.
}

assert(HACpDpM : rk(A :: Cp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpDpeq HACpDpM3).
assert(HACpDpm : rk(A :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HACpDpeq HACpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpDp requis par la preuve de (?)ApCpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HApCpDpm3 : rk(Ap :: Cp :: Dp :: nil) >= 3).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HApBpCpDpmtmp : rk(Ap :: Bp :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Ap :: Bp :: nil) (Ap :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) (Ap :: Bp :: Ap :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Ap :: Cp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Ap :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpDpmtmp;try rewrite HT2 in HApBpCpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Ap :: Cp :: Dp :: nil) (Ap :: nil) 4 1 2 HApBpCpDpmtmp HApmtmp HApBpMtmp Hincl); apply HT.
}

assert(HApCpDpM : rk(Ap :: Cp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpDpeq HApCpDpM3).
assert(HApCpDpm : rk(Ap :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HApCpDpeq HApCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpCpDp requis par la preuve de (?)BpCpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HBpCpDpm3 : rk(Bp :: Cp :: Dp :: nil) >= 3).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HApBpCpDpmtmp : rk(Ap :: Bp :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: nil) (Bp :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) (Ap :: Bp :: Bp :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Bp :: Cp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Bp :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpDpmtmp;try rewrite HT2 in HApBpCpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Bp :: Cp :: Dp :: nil) (Bp :: nil) 4 1 2 HApBpCpDpmtmp HBpmtmp HApBpMtmp Hincl); apply HT.
}

assert(HBpCpDpM : rk(Bp :: Cp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpCpDpeq HBpCpDpM3).
assert(HBpCpDpm : rk(Bp :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HBpCpDpeq HBpCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApDDp *)
(* dans la couche 0 *)
Lemma LOoAApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDDp requis par la preuve de (?)OoAApDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApDDp requis par la preuve de (?)OoAApDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDDp requis par la preuve de (?)OoAApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDDpm2 : rk(Oo :: A :: Ap :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoAApDDpM3 : rk(Oo :: A :: Ap :: D :: Dp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: D :: Dp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoDDpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDDpm3 : rk(Oo :: A :: Ap :: D :: Dp :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: Dp :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApDDpM : rk(Oo :: A :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDDpm : rk(Oo :: A :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoAApDDpeq HOoAApDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApDDp requis par la preuve de (?)AApDDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApDDp requis par la preuve de (?)AApDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDDp requis par la preuve de (?)AApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDDpm2 : rk(A :: Ap :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDDpm3 : rk(A :: Ap :: D :: Dp :: nil) >= 3).
{
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: D :: nil) (A :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: D :: nil) (A :: Ap :: D :: Dp :: nil) 3 3 HAApDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApDDpM3 : rk(A :: Ap :: D :: Dp :: nil) <= 3).
{
	assert(HOoAApDDpeq : rk(Oo :: A :: Ap :: D :: Dp :: nil) = 3) by (apply LOoAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDDpMtmp : rk(Oo :: A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDDpeq HOoAApDDpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: D :: Dp :: nil) 3 3 HOoAApDDpMtmp Hcomp Hincl);apply HT.
}

assert(HAApDDpM : rk(A :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDDpm : rk(A :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HAApDDpeq HAApDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpDDp *)
(* dans la couche 0 *)
Lemma LOoABBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpDDp requis par la preuve de (?)OoABApBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpDDp requis par la preuve de (?)OoABApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDDpm2 : rk(Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDDpm3 : rk(Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: D :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABBpDDpm2 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpDDpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApBpDDpeq HOoABApBpDDpm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpDDpmtmp;try rewrite HT2 in HOoABApBpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApBpDDpmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDDpm3 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDDpm4 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABBpDDpM : rk(Oo :: A :: B :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpDDpm : rk(Oo :: A :: B :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABBpDDpeq HOoABBpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpDDp *)
(* dans la couche 0 *)
Lemma LOoBBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpDDpm2 : rk(Oo :: B :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpmtmp;try rewrite HT2 in HOoABCApBpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoBBpDDpM3 : rk(Oo :: B :: Bp :: D :: Dp :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Oo :: D :: Dp :: nil) (Oo :: nil) 2 2 1 HOoBBpMtmp HOoDDpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpDDpm3 : rk(Oo :: B :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: Dp :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBBpDDpM : rk(Oo :: B :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpDDpm : rk(Oo :: B :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBBpDDpeq HOoBBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpDDp requis par la preuve de (?)ABpDDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpDDp requis par la preuve de (?)ABpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpDDp requis par la preuve de (?)ABpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDDpm2 : rk(A :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: D :: Dp :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDDpm3 : rk(A :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HABpDeq : rk(A :: Bp :: D :: nil) = 3) by (apply LABpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpDmtmp : rk(A :: Bp :: D :: nil) >= 3) by (solve_hyps_min HABpDeq HABpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: D :: nil) (A :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: D :: nil) (A :: Bp :: D :: Dp :: nil) 3 3 HABpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HABpDDpm4 : rk(A :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoBBpDDpeq : rk(Oo :: B :: Bp :: D :: Dp :: nil) = 3) by (apply LOoBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDDpMtmp : rk(Oo :: B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDDpeq HOoBBpDDpM3).
	assert(HOoABBpDDpeq : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) = 4) by (apply LOoABBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpDDpmtmp : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABBpDDpeq HOoABBpDDpm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (A :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: Dp :: nil) (A :: Bp :: D :: Dp :: Oo :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: D :: Dp :: Oo :: B :: Bp :: D :: Dp :: nil) ((A :: Bp :: D :: Dp :: nil) ++ (Oo :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDDpmtmp;try rewrite HT2 in HOoABBpDDpmtmp.
	assert(HT := rule_2 (A :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: D :: Dp :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HOoABBpDDpmtmp HBpDDpmtmp HOoBBpDDpMtmp Hincl);apply HT.
}

assert(HABpDDpM : rk(A :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpDDpm : rk(A :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABpDDpeq HABpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpDDp requis par la preuve de (?)BBpDDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpDDp requis par la preuve de (?)BBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpDDp requis par la preuve de (?)BBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDDpm2 : rk(B :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: D :: Dp :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDDpm3 : rk(B :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: D :: nil) (B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: D :: nil) (B :: Bp :: D :: Dp :: nil) 3 3 HBBpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpDDpM3 : rk(B :: Bp :: D :: Dp :: nil) <= 3).
{
	assert(HOoBBpDDpeq : rk(Oo :: B :: Bp :: D :: Dp :: nil) = 3) by (apply LOoBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDDpMtmp : rk(Oo :: B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDDpeq HOoBBpDDpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: D :: Dp :: nil) 3 3 HOoBBpDDpMtmp Hcomp Hincl);apply HT.
}

assert(HBBpDDpM : rk(B :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpDDpm : rk(B :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HBBpDDpeq HBBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpDDp requis par la preuve de (?)ACpDDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpDDp requis par la preuve de (?)ACpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpDDp requis par la preuve de (?)ACpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpm2 : rk(A :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: D :: Dp :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpm3 : rk(A :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HACpDeq : rk(A :: Cp :: D :: nil) = 3) by (apply LACpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDmtmp : rk(A :: Cp :: D :: nil) >= 3) by (solve_hyps_min HACpDeq HACpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: nil) 3 3 HACpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HACpDDpm4 : rk(A :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoCCpDDpeq : rk(Oo :: C :: Cp :: D :: Dp :: nil) = 3) by (apply LOoCCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDDpMtmp : rk(Oo :: C :: Cp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoCCpDDpeq HOoCCpDDpM3).
	assert(HOoACCpDDpeq : rk(Oo :: A :: C :: Cp :: D :: Dp :: nil) = 4) by (apply LOoACCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACCpDDpmtmp : rk(Oo :: A :: C :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACCpDDpeq HOoACCpDDpm4).
	assert(HCpDDpmtmp : rk(Cp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HCpDDpeq HCpDDpm3).
	assert(Hincl : incl (Cp :: D :: Dp :: nil) (list_inter (A :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: D :: Dp :: nil) (A :: Cp :: D :: Dp :: Oo :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: D :: Dp :: Oo :: C :: Cp :: D :: Dp :: nil) ((A :: Cp :: D :: Dp :: nil) ++ (Oo :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpDDpmtmp;try rewrite HT2 in HOoACCpDDpmtmp.
	assert(HT := rule_2 (A :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: D :: Dp :: nil) (Cp :: D :: Dp :: nil) 4 3 3 HOoACCpDDpmtmp HCpDDpmtmp HOoCCpDDpMtmp Hincl);apply HT.
}

assert(HACpDDpM : rk(A :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpDDpm : rk(A :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HACpDDpeq HACpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCpDDp *)
(* dans la couche 0 *)
Lemma LOoBCCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpDDp requis par la preuve de (?)OoBCCpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoBCCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoABCApCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpDDp requis par la preuve de (?)OoBCCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpDDp requis par la preuve de (?)OoBCCpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpDDpm2 : rk(Oo :: B :: C :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDDpeq HOoABCApCpDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: D :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDDpmtmp;try rewrite HT2 in HOoABCApCpDDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApCpDDpmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpDDpm3 : rk(Oo :: B :: C :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDDpeq HOoABCApCpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDDpmtmp;try rewrite HT2 in HOoABCApCpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApCpDDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCCpDDpm4 : rk(Oo :: B :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Cp :: D :: Dp :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCCpDDpM : rk(Oo :: B :: C :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCCpDDpm : rk(Oo :: B :: C :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCCpDDpeq HOoBCCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpDDp requis par la preuve de (?)BCpDDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpDDp requis par la preuve de (?)BCpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpDDp requis par la preuve de (?)BCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpDDpm2 : rk(B :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: nil) (B :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: nil) (B :: Cp :: D :: Dp :: nil) 2 2 HBCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpDDpm3 : rk(B :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HBCpDeq : rk(B :: Cp :: D :: nil) = 3) by (apply LBCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpDmtmp : rk(B :: Cp :: D :: nil) >= 3) by (solve_hyps_min HBCpDeq HBCpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: D :: nil) (B :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: D :: nil) (B :: Cp :: D :: Dp :: nil) 3 3 HBCpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HBCpDDpm4 : rk(B :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoCCpDDpeq : rk(Oo :: C :: Cp :: D :: Dp :: nil) = 3) by (apply LOoCCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDDpMtmp : rk(Oo :: C :: Cp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoCCpDDpeq HOoCCpDDpM3).
	assert(HOoBCCpDDpeq : rk(Oo :: B :: C :: Cp :: D :: Dp :: nil) = 4) by (apply LOoBCCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCCpDDpmtmp : rk(Oo :: B :: C :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCCpDDpeq HOoBCCpDDpm4).
	assert(HCpDDpmtmp : rk(Cp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HCpDDpeq HCpDDpm3).
	assert(Hincl : incl (Cp :: D :: Dp :: nil) (list_inter (B :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: D :: Dp :: nil) (B :: Cp :: D :: Dp :: Oo :: C :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Cp :: D :: Dp :: Oo :: C :: Cp :: D :: Dp :: nil) ((B :: Cp :: D :: Dp :: nil) ++ (Oo :: C :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCCpDDpmtmp;try rewrite HT2 in HOoBCCpDDpmtmp.
	assert(HT := rule_2 (B :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: D :: Dp :: nil) (Cp :: D :: Dp :: nil) 4 3 3 HOoBCCpDDpmtmp HCpDDpmtmp HOoCCpDDpMtmp Hincl);apply HT.
}

assert(HBCpDDpM : rk(B :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpDDpm : rk(B :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HBCpDDpeq HBCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoABCApCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpDDpM : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDDpm : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDDpeq HOoABCApCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpDDp requis par la preuve de (?)OoABCBpCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpDDpM : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpDDpm : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpDDpeq HOoABCBpCpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoad *)
(* dans la couche 0 *)
Lemma LOoADad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoABCBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADad requis par la preuve de (?)OoADad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoADadM3 : rk(Oo :: A :: D :: ad :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: ad :: nil) ((Oo :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HOoMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoADadm2 : rk(Oo :: A :: D :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpDadmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpDadeq HOoABCBpDadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: D :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDadmtmp;try rewrite HT2 in HOoABCBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpDadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADadm3 : rk(Oo :: A :: D :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoADadM : rk(Oo :: A :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADadm : rk(Oo :: A :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoADadeq HOoADadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ooad requis par la preuve de (?)Ooad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoadm2 : rk(Oo :: ad :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoADadeq : rk(Oo :: A :: D :: ad :: nil) = 3) by (apply LOoADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADadmtmp : rk(Oo :: A :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoADadeq HOoADadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: ad :: A :: D :: ad :: nil) ((Oo :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoADadmtmp;try rewrite HT2 in HOoADadmtmp.
	assert(HT := rule_2 (Oo :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HOoADadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoadM : rk(Oo :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoadeq HOoadM2).
assert(HOoadm : rk(Oo :: ad ::  nil) >= 1) by (solve_hyps_min HOoadeq HOoadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAad *)
(* dans la couche 0 *)
Lemma LAApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApDpadM3 : rk(A :: Ap :: Dp :: ad :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Dp :: ad :: nil) ((A :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HAMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpadm2 : rk(A :: Ap :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpadm3 : rk(A :: Ap :: Dp :: ad :: nil) >= 3).
{
	assert(HAApDpmtmp : rk(A :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HAApDpeq HAApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: ad :: nil) 3 3 HAApDpmtmp Hcomp Hincl);apply HT.
}

assert(HAApDpadM : rk(A :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDpadm : rk(A :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HAApDpadeq HAApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aad requis par la preuve de (?)Aad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAadm2 : rk(A :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HAApDpadeq : rk(A :: Ap :: Dp :: ad :: nil) = 3) by (apply LAApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDpadmtmp : rk(A :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HAApDpadeq HAApDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (A :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ad :: Ap :: Dp :: ad :: nil) ((A :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDpadmtmp;try rewrite HT2 in HAApDpadmtmp.
	assert(HT := rule_2 (A :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HAApDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HAadM : rk(A :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAadeq HAadM2).
assert(HAadm : rk(A :: ad ::  nil) >= 1) by (solve_hyps_min HAadeq HAadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBad *)
(* dans la couche 0 *)
Lemma LOoABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDad requis par la preuve de (?)OoABApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDad requis par la preuve de (?)OoABApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadm2 : rk(Oo :: A :: B :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadm3 : rk(Oo :: A :: B :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: ad ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABDadm2 : rk(Oo :: A :: B :: D :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDadmtmp : rk(Oo :: A :: B :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABApDadeq HOoABApDadm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDadmtmp;try rewrite HT2 in HOoABApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApDadmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDadm3 : rk(Oo :: A :: B :: D :: ad :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDadmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDadmtmp;try rewrite HT2 in HOoABCCpDadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpDadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABDadm4 : rk(Oo :: A :: B :: D :: ad :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABDadM : rk(Oo :: A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDadm : rk(Oo :: A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABDadeq HOoABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoBad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBadm2 : rk(Oo :: B :: ad :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: ad :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApadmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoBadm3 : rk(Oo :: B :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: ad :: A :: D :: ad :: nil) ((Oo :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: B :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoABDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoBadM : rk(Oo :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBadeq HOoBadM3).
assert(HOoBadm : rk(Oo :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoBadeq HOoBadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABad *)
(* dans la couche 0 *)
Lemma LABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDad requis par la preuve de (?)ABDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDadM3 : rk(A :: B :: D :: ad :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (B :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: D :: ad :: nil) ((B :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HBMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadm2 : rk(A :: B :: D :: ad :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: ad :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadm3 : rk(A :: B :: D :: ad :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: ad :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABDadM : rk(A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDadm : rk(A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABDadeq HABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApad requis par la preuve de (?)ABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm2 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm3 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABadm2 : rk(A :: B :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadmtmp : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoABApadeq HOoABApadm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadmtmp;try rewrite HT2 in HOoABApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: nil) (A :: B :: nil) 3 2 3 HOoABApadmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABadm3 : rk(A :: B :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABDadeq : rk(A :: B :: D :: ad :: nil) = 3) by (apply LABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDadmtmp : rk(A :: B :: D :: ad :: nil) >= 3) by (solve_hyps_min HABDadeq HABDadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ad :: A :: D :: ad :: nil) ((A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDadmtmp;try rewrite HT2 in HABDadmtmp.
	assert(HT := rule_2 (A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HABadM : rk(A :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABadeq HABadM3).
assert(HABadm : rk(A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HABadeq HABadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm2 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm3 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABadm2 : rk(Oo :: A :: B :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadmtmp : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoABApadeq HOoABApadm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadmtmp;try rewrite HT2 in HOoABApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ad :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApadmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABadm3 : rk(Oo :: A :: B :: ad :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoABadm4 : rk(Oo :: A :: B :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ad :: A :: D :: ad :: nil) ((Oo :: A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HOoABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoABadM : rk(Oo :: A :: B :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABadm : rk(Oo :: A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoABadeq HOoABadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCad *)
(* dans la couche 0 *)
Lemma LOoACDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACDad requis par la preuve de (?)OoACDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoABCBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACDadm2 : rk(Oo :: A :: C :: D :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (B :: Ap :: Oo :: A :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: D :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: D :: ad :: nil) (nil) 4 0 2 HOoABCApDadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACDadm3 : rk(Oo :: A :: C :: D :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpDadmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpDadeq HOoABCBpDadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: D :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDadmtmp;try rewrite HT2 in HOoABCBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCBpDadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACDadm4 : rk(Oo :: A :: C :: D :: ad :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: ad :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACDadM : rk(Oo :: A :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDadm : rk(Oo :: A :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoACDadeq HOoACDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCad requis par la preuve de (?)OoCad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoCad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCad requis par la preuve de (?)OoCad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCadm2 : rk(Oo :: C :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApadmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoCadm3 : rk(Oo :: C :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoACDadeq : rk(Oo :: A :: C :: D :: ad :: nil) = 4) by (apply LOoACDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACDadmtmp : rk(Oo :: A :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoACDadeq HOoACDadm4).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: ad :: nil) (Oo :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: ad :: A :: D :: ad :: nil) ((Oo :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDadmtmp;try rewrite HT2 in HOoACDadmtmp.
	assert(HT := rule_2 (Oo :: C :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoACDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoCadM : rk(Oo :: C :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCadeq HOoCadM3).
assert(HOoCadm : rk(Oo :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoCadeq HOoCadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACad requis par la preuve de (?)OoACad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoABCBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpadm4 : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACad requis par la preuve de (?)OoACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACad requis par la preuve de (?)OoACad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACadm2 : rk(Oo :: A :: C :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (B :: Ap :: Oo :: A :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: ad :: nil) (nil) 4 0 2 HOoABCApadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACadm3 : rk(Oo :: A :: C :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCBpadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoACadm4 : rk(Oo :: A :: C :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoACDadeq : rk(Oo :: A :: C :: D :: ad :: nil) = 4) by (apply LOoACDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACDadmtmp : rk(Oo :: A :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoACDadeq HOoACDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: ad :: nil) (Oo :: A :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: ad :: A :: D :: ad :: nil) ((Oo :: A :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDadmtmp;try rewrite HT2 in HOoACDadmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HOoACDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoACadM : rk(Oo :: A :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACadm : rk(Oo :: A :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoACadeq HOoACadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCad requis par la preuve de (?)OoABCad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCadm4 : rk(Oo :: A :: B :: C :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCadM : rk(Oo :: A :: B :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCadm : rk(Oo :: A :: B :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCadeq HOoABCadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApad *)
(* dans la couche 0 *)
Lemma LAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDad requis par la preuve de (?)AApDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApDadM3 : rk(A :: Ap :: D :: ad :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: D :: ad :: nil) ((Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HApMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDadm2 : rk(A :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDadm3 : rk(A :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: D :: nil) (A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: D :: nil) (A :: Ap :: D :: ad :: nil) 3 3 HAApDmtmp Hcomp Hincl);apply HT.
}

assert(HAApDadM : rk(A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDadm : rk(A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAApDadeq HAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApad requis par la preuve de (?)AApad pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApad requis par la preuve de (?)AApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApadm2 : rk(A :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAApadm3 : rk(A :: Ap :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAApDadeq : rk(A :: Ap :: D :: ad :: nil) = 3) by (apply LAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDadmtmp : rk(A :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HAApDadeq HAApDadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: Ap :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (A :: Ap :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: ad :: A :: D :: ad :: nil) ((A :: Ap :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDadmtmp;try rewrite HT2 in HAApDadmtmp.
	assert(HT := rule_2 (A :: Ap :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HAApDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HAApadM : rk(A :: Ap :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAApadeq HAApadM3).
assert(HAApadm : rk(A :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HAApadeq HAApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApadM : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApadm : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApadeq HOoABCApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpad *)
(* dans la couche 0 *)
Lemma LOoABpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacDDpad requis par la preuve de (?)OoABCApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacDDpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacDDpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacDDpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacDDpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacDDpadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacDDpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacDDpadeq HOoACApBpacDDpadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacDDpadmtmp;try rewrite HT2 in HOoACApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacDDpadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm2 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm3 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacDDpadm4 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacDDpadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacDDpadeq HOoAApBpacDDpadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacDDpadmtmp;try rewrite HT2 in HOoAApBpacDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacDDpadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpDDpadm2 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: ac ::   de rang : 2 et 2 *)
assert(HOoABpDDpadm3 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBpaceq : rk(Bp :: ac :: nil) = 2) by (apply LBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpacMtmp : rk(Bp :: ac :: nil) <= 2) by (solve_hyps_max HBpaceq HBpacM2).
	assert(HOoABpacDDpadmtmp : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpacDDpadeq HOoABpacDDpadm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: ac :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) (Bp :: ac :: Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: ac :: Oo :: A :: Bp :: D :: Dp :: ad :: nil) ((Bp :: ac :: nil) ++ (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpacDDpadmtmp;try rewrite HT2 in HOoABpacDDpadmtmp.
	assert(HT := rule_4 (Bp :: ac :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Bp :: nil) 4 1 2 HOoABpacDDpadmtmp HBpmtmp HBpacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpDDpadm4 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABpDDpeq : rk(A :: Bp :: D :: Dp :: nil) = 4) by (apply LABpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpDDpmtmp : rk(A :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HABpDDpeq HABpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) 4 4 HABpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABpDDpadM : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDDpadm : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpad *)
(* dans la couche 0 *)
Lemma LOoADDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoADDpad requis par la preuve de (?)OoADDpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoADDpad requis par la preuve de (?)OoADDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDDpad requis par la preuve de (?)OoADDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDpad requis par la preuve de (?)OoABCBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADDpad requis par la preuve de (?)OoADDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoADDpadm2 : rk(Oo :: A :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpDDpadeq HOoABCBpDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDDpadmtmp;try rewrite HT2 in HOoABCBpDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADDpadm3 : rk(Oo :: A :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoADDpadM3 : rk(Oo :: A :: D :: Dp :: ad :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: Dp :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: A :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (A :: D :: ad :: nil) (D :: nil) 2 2 1 HOoDDpMtmp HADadMtmp HDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoADDpadM : rk(Oo :: A :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADDpadm : rk(Oo :: A :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoADDpadeq HOoADDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpad requis par la preuve de (?)OoABCApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoBpadm2 : rk(Oo :: Bp :: ad :: nil) >= 2).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(HOoACApBpCpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpCpadeq HOoACApBpCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (Oo :: A :: C :: Ap :: Cp :: Oo :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Cp :: Oo :: Bp :: ad :: nil) ((Oo :: A :: C :: Ap :: Cp :: nil) ++ (Oo :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpadmtmp;try rewrite HT2 in HOoACApBpCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: Bp :: ad :: nil) (Oo :: nil) 4 1 3 HOoACApBpCpadmtmp HOomtmp HOoACApCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpadm3 : rk(Oo :: Bp :: ad :: nil) >= 3).
{
	assert(HOoADDpadeq : rk(Oo :: A :: D :: Dp :: ad :: nil) = 3) by (apply LOoADDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADDpadMtmp : rk(Oo :: A :: D :: Dp :: ad :: nil) <= 3) by (solve_hyps_max HOoADDpadeq HOoADDpadM3).
	assert(HOoABpDDpadeq : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpDDpadmtmp : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm4).
	assert(HOoadeq : rk(Oo :: ad :: nil) = 2) by (apply LOoad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoadmtmp : rk(Oo :: ad :: nil) >= 2) by (solve_hyps_min HOoadeq HOoadm2).
	assert(Hincl : incl (Oo :: ad :: nil) (list_inter (Oo :: Bp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: Bp :: ad :: Oo :: A :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: ad :: Oo :: A :: D :: Dp :: ad :: nil) ((Oo :: Bp :: ad :: nil) ++ (Oo :: A :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDDpadmtmp;try rewrite HT2 in HOoABpDDpadmtmp.
	assert(HT := rule_2 (Oo :: Bp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: ad :: nil) 4 2 3 HOoABpDDpadmtmp HOoadmtmp HOoADDpadMtmp Hincl);apply HT.
}

assert(HOoBpadM : rk(Oo :: Bp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpadeq HOoBpadM3).
assert(HOoBpadm : rk(Oo :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBpadeq HOoBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans constructLemma(), requis par LOoABBpad *)
(* dans la couche 0 *)
Lemma LOoABCBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoABCBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpadm4 : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpadM : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpadm : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpad requis par la preuve de (?)OoABApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpad requis par la preuve de (?)OoABApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpadeq HOoABApBpadm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpadmtmp;try rewrite HT2 in HOoABApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApBpadmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoABBpadm4 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOoABadeq : rk(Oo :: A :: B :: ad :: nil) = 4) by (apply LOoABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABadmtmp : rk(Oo :: A :: B :: ad :: nil) >= 4) by (solve_hyps_min HOoABadeq HOoABadm4).
	assert(Hincl : incl (Oo :: A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: B :: ad :: nil) 4 4 4 HOoABCBpadmtmp HOoABadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoABBpadM : rk(Oo :: A :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpadm : rk(Oo :: A :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABBpadeq HOoABBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans la couche 0 *)
Lemma LOoBBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpadm2 : rk(Oo :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApBpadmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpadM3 : rk(Oo :: B :: Bp :: ad :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (ad :: nil) (nil) 2 1 0 HOoBBpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoBBpadm3 : rk(Oo :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOoBadeq : rk(Oo :: B :: ad :: nil) = 3) by (apply LOoBad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBadmtmp : rk(Oo :: B :: ad :: nil) >= 3) by (solve_hyps_min HOoBadeq HOoBadm3).
	assert(Hincl : incl (Oo :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: ad :: nil) 4 3 4 HOoABCBpadmtmp HOoBadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoBBpadM : rk(Oo :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpadm : rk(Oo :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBBpadeq HOoBBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoABpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacad requis par la preuve de (?)OoABCApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacadeq HOoACApBpacadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacadmtmp;try rewrite HT2 in HOoACApBpacadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm2 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm3 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacadm4 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacadeq HOoAApBpacadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacadmtmp;try rewrite HT2 in HOoAApBpacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpadm2 : rk(Oo :: A :: Bp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: ac ::   de rang : 2 et 2 *)
assert(HOoABpadm3 : rk(Oo :: A :: Bp :: ad :: nil) >= 3).
{
	assert(HBpaceq : rk(Bp :: ac :: nil) = 2) by (apply LBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpacMtmp : rk(Bp :: ac :: nil) <= 2) by (solve_hyps_max HBpaceq HBpacM2).
	assert(HOoABpacadmtmp : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABpacadeq HOoABpacadm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: ac :: nil) (Oo :: A :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: ac :: ad :: nil) (Bp :: ac :: Oo :: A :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: ac :: Oo :: A :: Bp :: ad :: nil) ((Bp :: ac :: nil) ++ (Oo :: A :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpacadmtmp;try rewrite HT2 in HOoABpacadmtmp.
	assert(HT := rule_4 (Bp :: ac :: nil) (Oo :: A :: Bp :: ad :: nil) (Bp :: nil) 4 1 2 HOoABpacadmtmp HBpmtmp HBpacMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpadm4 : rk(Oo :: A :: Bp :: ad :: nil) >= 4).
{
	assert(HOoBBpadeq : rk(Oo :: B :: Bp :: ad :: nil) = 3) by (apply LOoBBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpadMtmp : rk(Oo :: B :: Bp :: ad :: nil) <= 3) by (solve_hyps_max HOoBBpadeq HOoBBpadM3).
	assert(HOoABBpadeq : rk(Oo :: A :: B :: Bp :: ad :: nil) = 4) by (apply LOoABBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABBpadeq HOoABBpadm4).
	assert(HOoBpadeq : rk(Oo :: Bp :: ad :: nil) = 3) by (apply LOoBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpadmtmp : rk(Oo :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoBpadeq HOoBpadm3).
	assert(Hincl : incl (Oo :: Bp :: ad :: nil) (list_inter (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: Bp :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: Bp :: ad :: nil) 4 3 3 HOoABBpadmtmp HOoBpadmtmp HOoBBpadMtmp Hincl);apply HT.
}

assert(HOoABpadM : rk(Oo :: A :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpadm : rk(Oo :: A :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpadeq HOoABpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApBpad *)
(* dans la couche 0 *)
Lemma LOoAApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpDadm2 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpDadm3 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDadm4 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpDadM : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpDadm : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApBpad *)
(* dans la couche 0 *)
Lemma LOoAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDadm2 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoAApDadM3 : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HOoAApMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDadm3 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApDadM : rk(Oo :: A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDadm : rk(Oo :: A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApDadeq HOoAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpadm2 : rk(A :: Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpadm3 : rk(A :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApBpadm4 : rk(A :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDadMtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3) by (solve_hyps_max HOoAApDadeq HOoAApDadM3).
	assert(HOoAApBpDadeq : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoAApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpDadmtmp : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm4).
	assert(HAApadeq : rk(A :: Ap :: ad :: nil) = 3) by (apply LAApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApadmtmp : rk(A :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HAApadeq HAApadm3).
	assert(Hincl : incl (A :: Ap :: ad :: nil) (list_inter (A :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: Bp :: ad :: Oo :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: ad :: Oo :: A :: Ap :: D :: ad :: nil) ((A :: Ap :: Bp :: ad :: nil) ++ (Oo :: A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpDadmtmp;try rewrite HT2 in HOoAApBpDadmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil) (A :: Ap :: ad :: nil) 4 3 3 HOoAApBpDadmtmp HAApadmtmp HOoAApDadMtmp Hincl);apply HT.
}

assert(HAApBpadM : rk(A :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpadm : rk(A :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpadeq HAApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpad *)
(* dans la couche 0 *)
Lemma LOoACpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDDpadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabDDpadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpadeq HOoABApCpabDDpadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpadmtmp;try rewrite HT2 in HOoABApCpabDDpadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabDDpadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoABCBpCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm2 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabDDpadeq HOoABCBpCpabDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabDDpadmtmp;try rewrite HT2 in HOoABCBpCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabDDpadm3 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm4 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabDDpadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabDDpadeq HOoAApCpabDDpadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabDDpadmtmp;try rewrite HT2 in HOoAApCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabDDpadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpDDpad requis par la preuve de (?)OoABCBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpDDpadm2 : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpDDpadeq HOoABCBpCpDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpDDpadmtmp;try rewrite HT2 in HOoABCBpCpDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoACpDDpadm3 : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoACpabDDpadmtmp : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpabDDpadeq HOoACpabDDpadm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Cp :: ab :: Oo :: A :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: A :: Cp :: D :: Dp :: ad :: nil) ((Cp :: ab :: nil) ++ (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpabDDpadmtmp;try rewrite HT2 in HOoACpabDDpadmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil) (Cp :: nil) 4 1 2 HOoACpabDDpadmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpDDpadm4 : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACpDDpeq : rk(A :: Cp :: D :: Dp :: nil) = 4) by (apply LACpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpmtmp : rk(A :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HACpDDpeq HACpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: Dp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: Dp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil) 4 4 HACpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoACpDDpadM : rk(Oo :: A :: Cp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpDDpadm : rk(Oo :: A :: Cp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpDDpadeq HOoACpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpad requis par la preuve de (?)OoCpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabadmtmp;try rewrite HT2 in HOoABApCpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpad requis par la preuve de (?)OoCpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoCpadm2 : rk(Oo :: Cp :: ad :: nil) >= 2).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: Cp :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabadmtmp;try rewrite HT2 in HOoAApCpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: ad :: nil) (Oo :: nil) 4 1 3 HOoAApCpabadmtmp HOomtmp HOoAApabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpadm3 : rk(Oo :: Cp :: ad :: nil) >= 3).
{
	assert(HOoADDpadeq : rk(Oo :: A :: D :: Dp :: ad :: nil) = 3) by (apply LOoADDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADDpadMtmp : rk(Oo :: A :: D :: Dp :: ad :: nil) <= 3) by (solve_hyps_max HOoADDpadeq HOoADDpadM3).
	assert(HOoACpDDpadeq : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) = 4) by (apply LOoACpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACpDDpadmtmp : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpDDpadeq HOoACpDDpadm4).
	assert(HOoadeq : rk(Oo :: ad :: nil) = 2) by (apply LOoad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoadmtmp : rk(Oo :: ad :: nil) >= 2) by (solve_hyps_min HOoadeq HOoadm2).
	assert(Hincl : incl (Oo :: ad :: nil) (list_inter (Oo :: Cp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: D :: Dp :: ad :: nil) (Oo :: Cp :: ad :: Oo :: A :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: ad :: Oo :: A :: D :: Dp :: ad :: nil) ((Oo :: Cp :: ad :: nil) ++ (Oo :: A :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpDDpadmtmp;try rewrite HT2 in HOoACpDDpadmtmp.
	assert(HT := rule_2 (Oo :: Cp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: ad :: nil) 4 2 3 HOoACpDDpadmtmp HOoadmtmp HOoADDpadMtmp Hincl);apply HT.
}

assert(HOoCpadM : rk(Oo :: Cp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpadeq HOoCpadM3).
assert(HOoCpadm : rk(Oo :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoCpadeq HOoCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpad *)
(* dans constructLemma(), requis par LOoACCpad *)
(* dans la couche 0 *)
Lemma LOoABCCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpadM : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpadm : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoABCBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoABCApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpadm2 : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApCpadeq HOoABCApCpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpadmtmp;try rewrite HT2 in HOoABCApCpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ad :: nil) (nil) 4 0 2 HOoABCApCpadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpadm3 : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpadeq HOoABCBpCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpadmtmp;try rewrite HT2 in HOoABCBpCpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: C :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoACCpadm4 : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCCpadeq : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) = 4) by (apply LOoABCCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	assert(HOoACadeq : rk(Oo :: A :: C :: ad :: nil) = 4) by (apply LOoACad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACadmtmp : rk(Oo :: A :: C :: ad :: nil) >= 4) by (solve_hyps_min HOoACadeq HOoACadm4).
	assert(Hincl : incl (Oo :: A :: C :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: C :: Cp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: C :: Cp :: ad :: nil) (Oo :: A :: C :: ad :: nil) 4 4 4 HOoABCCpadmtmp HOoACadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoACCpadM : rk(Oo :: A :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpadm : rk(Oo :: A :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACCpadeq HOoACCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpad *)
(* dans la couche 0 *)
Lemma LOoCCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpad requis par la preuve de (?)OoCCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpad requis par la preuve de (?)OoCCpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoCCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoABCApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpad requis par la preuve de (?)OoCCpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpadm2 : rk(Oo :: C :: Cp :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApCpadeq HOoABCApCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpadmtmp;try rewrite HT2 in HOoABCApCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApCpadmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoCCpadM3 : rk(Oo :: C :: Cp :: ad :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: ad :: nil) (Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (ad :: nil) (nil) 2 1 0 HOoCCpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: C :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoCCpadm3 : rk(Oo :: C :: Cp :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCCpadeq : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) = 4) by (apply LOoABCCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	assert(HOoCadeq : rk(Oo :: C :: ad :: nil) = 3) by (apply LOoCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCadmtmp : rk(Oo :: C :: ad :: nil) >= 3) by (solve_hyps_min HOoCadeq HOoCadm3).
	assert(Hincl : incl (Oo :: C :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: C :: Cp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: C :: Cp :: ad :: nil) (Oo :: C :: ad :: nil) 4 3 4 HOoABCCpadmtmp HOoCadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoCCpadM : rk(Oo :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpadm : rk(Oo :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoCCpadeq HOoCCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpad requis par la preuve de (?)OoACpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabadmtmp;try rewrite HT2 in HOoABApCpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoABCBpCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabadm2 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabadeq HOoABCBpCpabadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabadmtmp;try rewrite HT2 in HOoABCBpCpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabadm3 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabadm4 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabadmtmp;try rewrite HT2 in HOoAApCpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoABCBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpadm2 : rk(Oo :: A :: Cp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpadeq HOoABCBpCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpadmtmp;try rewrite HT2 in HOoABCBpCpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoACpadm3 : rk(Oo :: A :: Cp :: ad :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoACpabadmtmp : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoACpabadeq HOoACpabadm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: A :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: ab :: ad :: nil) (Cp :: ab :: Oo :: A :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: A :: Cp :: ad :: nil) ((Cp :: ab :: nil) ++ (Oo :: A :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpabadmtmp;try rewrite HT2 in HOoACpabadmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: A :: Cp :: ad :: nil) (Cp :: nil) 4 1 2 HOoACpabadmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpadm4 : rk(Oo :: A :: Cp :: ad :: nil) >= 4).
{
	assert(HOoCCpadeq : rk(Oo :: C :: Cp :: ad :: nil) = 3) by (apply LOoCCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpadMtmp : rk(Oo :: C :: Cp :: ad :: nil) <= 3) by (solve_hyps_max HOoCCpadeq HOoCCpadM3).
	assert(HOoACCpadeq : rk(Oo :: A :: C :: Cp :: ad :: nil) = 4) by (apply LOoACCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACCpadmtmp : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACCpadeq HOoACCpadm4).
	assert(HOoCpadeq : rk(Oo :: Cp :: ad :: nil) = 3) by (apply LOoCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpadmtmp : rk(Oo :: Cp :: ad :: nil) >= 3) by (solve_hyps_min HOoCpadeq HOoCpadm3).
	assert(Hincl : incl (Oo :: Cp :: ad :: nil) (list_inter (Oo :: A :: Cp :: ad :: nil) (Oo :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: ad :: nil) (Oo :: A :: Cp :: ad :: Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: ad :: Oo :: C :: Cp :: ad :: nil) ((Oo :: A :: Cp :: ad :: nil) ++ (Oo :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpadmtmp;try rewrite HT2 in HOoACCpadmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: ad :: nil) (Oo :: C :: Cp :: ad :: nil) (Oo :: Cp :: ad :: nil) 4 3 3 HOoACCpadmtmp HOoCpadmtmp HOoCCpadMtmp Hincl);apply HT.
}

assert(HOoACpadM : rk(Oo :: A :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpadm : rk(Oo :: A :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpadeq HOoACpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApCpad *)
(* dans la couche 0 *)
Lemma LOoAApCpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpDad requis par la preuve de (?)OoAApCpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpDad requis par la preuve de (?)OoAApCpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpDad requis par la preuve de (?)OoAApCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpDadm2 : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpDadm3 : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpDadm4 : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoACpadeq : rk(Oo :: A :: Cp :: ad :: nil) = 4) by (apply LOoACpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACpadmtmp : rk(Oo :: A :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpadeq HOoACpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil) 4 4 HOoACpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApCpDadM : rk(Oo :: A :: Ap :: Cp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpDadm : rk(Oo :: A :: Ap :: Cp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpDadeq HOoAApCpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpad requis par la preuve de (?)AApCpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpad requis par la preuve de (?)AApCpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpad requis par la preuve de (?)AApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpadm2 : rk(A :: Ap :: Cp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpadm3 : rk(A :: Ap :: Cp :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApCpadm4 : rk(A :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDadMtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3) by (solve_hyps_max HOoAApDadeq HOoAApDadM3).
	assert(HOoAApCpDadeq : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) = 4) by (apply LOoAApCpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpDadmtmp : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpDadeq HOoAApCpDadm4).
	assert(HAApadeq : rk(A :: Ap :: ad :: nil) = 3) by (apply LAApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApadmtmp : rk(A :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HAApadeq HAApadm3).
	assert(Hincl : incl (A :: Ap :: ad :: nil) (list_inter (A :: Ap :: Cp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: D :: ad :: nil) (A :: Ap :: Cp :: ad :: Oo :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Cp :: ad :: Oo :: A :: Ap :: D :: ad :: nil) ((A :: Ap :: Cp :: ad :: nil) ++ (Oo :: A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpDadmtmp;try rewrite HT2 in HOoAApCpDadmtmp.
	assert(HT := rule_2 (A :: Ap :: Cp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil) (A :: Ap :: ad :: nil) 4 3 3 HOoAApCpDadmtmp HAApadmtmp HOoAApDadMtmp Hincl);apply HT.
}

assert(HAApCpadM : rk(A :: Ap :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpadm : rk(A :: Ap :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HAApCpadeq HAApCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoABCApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpadM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpadm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApCpadeq HOoABCApCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoABCBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpadeq HOoABCBpCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACApBpCpad *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpad requis par la preuve de (?)OoABCApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) = 4) by (apply LOoABCApBpCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) = 4) by (apply LOoABCApBpCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpadM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpadm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpadeq HOoACApBpCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labad *)
(* dans constructLemma(), requis par LABabad *)
(* dans la couche 0 *)
Lemma LOoABCabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabad requis par la preuve de (?)OoABCabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabadm4 : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabadM : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabadm : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCabadeq HOoABCabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabad requis par la preuve de (?)OoABApabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabad requis par la preuve de (?)OoABApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadm2 : rk(A :: B :: ab :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApabadeq HOoABApabadm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadmtmp;try rewrite HT2 in HOoABApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: nil) (A :: B :: nil) 3 2 3 HOoABApabadmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABabadM3 : rk(A :: B :: ab :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (ad :: nil) (nil) 2 1 0 HABabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HABabadm3 : rk(A :: B :: ab :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCabadeq : rk(Oo :: A :: B :: C :: ab :: ad :: nil) = 4) by (apply LOoABCabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabadmtmp : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCabadeq HOoABCabadm4).
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hincl : incl (A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: ad :: nil) (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabadmtmp;try rewrite HT2 in HOoABCabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil) (A :: B :: ad :: nil) 4 3 4 HOoABCabadmtmp HABadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HABabadM : rk(A :: B :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabadm : rk(A :: B :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABabadeq HABabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour abad requis par la preuve de (?)abad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ad ::  de rang :  3 et 3 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(Habadm2 : rk(ab :: ad :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadmtmp : rk(A :: B :: ab :: ad :: nil) >= 3) by (solve_hyps_min HABabadeq HABabadm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadmtmp;try rewrite HT2 in HABabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (ab :: ad :: nil) (ab :: nil) 3 1 2 HABabadmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

assert(HabadM : rk(ab :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max Habadeq HabadM2).
assert(Habadm : rk(ab :: ad ::  nil) >= 1) by (solve_hyps_min Habadeq Habadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpabad *)
(* dans constructLemma(), requis par LOoAApCpabad *)
(* dans la couche 0 *)
Lemma LOoABApCpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabadM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabadm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabadeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) = 4) by (apply LOoABApCpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabadmtmp;try rewrite HT2 in HOoABApCpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoAApCpabadM : rk(Oo :: A :: Ap :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpabadm : rk(Oo :: A :: Ap :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoABCBpCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabadm2 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabadeq HOoABCBpCpabadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabadmtmp;try rewrite HT2 in HOoABCBpCpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabadm3 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabadm4 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabadeq : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) = 4) by (apply LOoAApCpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpabadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabadmtmp;try rewrite HT2 in HOoAApCpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

assert(HOoACpabadM : rk(Oo :: A :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpabadm : rk(Oo :: A :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpabadeq HOoACpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoABCBpCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpabadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpabadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpabadeq HOoABCBpCpabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpacad *)
(* dans constructLemma(), requis par LOoAApBpacad *)
(* dans constructLemma(), requis par LOoACApBpacad *)
(* dans la couche 0 *)
Lemma LOoABCApBpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacad requis par la preuve de (?)OoABCApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpacadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpacadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoABCApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoABCApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpacadM : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpacadm : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoACApBpacadeq HOoACApBpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacadeq : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoACApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpacadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacadeq HOoACApBpacadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacadmtmp;try rewrite HT2 in HOoACApBpacadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

assert(HOoAApBpacadM : rk(Oo :: A :: Ap :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpacadm : rk(Oo :: A :: Ap :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpacadeq HOoAApBpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm2 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm3 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacadm4 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacadeq : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoAApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpacadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacadeq HOoAApBpacadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacadmtmp;try rewrite HT2 in HOoAApBpacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

assert(HOoABpacadM : rk(Oo :: A :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpacadm : rk(Oo :: A :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpacadeq HOoABpacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDad *)
(* dans la couche 0 *)
Lemma LApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HApDDpadM3 : rk(Ap :: D :: Dp :: ad :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: Dp :: ad :: nil) ((D :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HDMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDDpadm2 : rk(Ap :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HApDeq : rk(Ap :: D :: nil) = 2) by (apply LApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDmtmp : rk(Ap :: D :: nil) >= 2) by (solve_hyps_min HApDeq HApDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: D :: nil) (Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: D :: nil) (Ap :: D :: Dp :: ad :: nil) 2 2 HApDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HApDDpadm3 : rk(Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil) 3 3 HApDDpmtmp Hcomp Hincl);apply HT.
}

assert(HApDDpadM : rk(Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDDpadm : rk(Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HApDDpadeq HApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dad requis par la preuve de (?)Dad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDadm2 : rk(D :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HApDDpadeq : rk(Ap :: D :: Dp :: ad :: nil) = 3) by (apply LApDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDDpadmtmp : rk(Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HApDDpadeq HApDDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (D :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: ad :: Ap :: Dp :: ad :: nil) ((D :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApDDpadmtmp;try rewrite HT2 in HApDDpadmtmp.
	assert(HT := rule_2 (D :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HApDDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HDadM : rk(D :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDadeq HDadM2).
assert(HDadm : rk(D :: ad ::  nil) >= 1) by (solve_hyps_min HDadeq HDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDadM : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDadm : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoABCBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDadM : rk(Oo :: A :: B :: C :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDadm : rk(Oo :: A :: B :: C :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpDadeq HOoABCBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpDadM : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDadm : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBabDad *)
(* dans la couche 0 *)
Lemma LABabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDad requis par la preuve de (?)OoABApabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDad requis par la preuve de (?)OoABApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadm2 : rk(A :: B :: ab :: D :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABApabDadeq HOoABApabDadm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadmtmp;try rewrite HT2 in HOoABApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDadM3 : rk(A :: B :: ab :: D :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HABabMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadm3 : rk(A :: B :: ab :: D :: ad :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABabDadM : rk(A :: B :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDadm : rk(A :: B :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABabDadeq HABabDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBabDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDad requis par la preuve de (?)OoABApabDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDad requis par la preuve de (?)OoABApabDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDad requis par la preuve de (?)ABabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadm2 : rk(A :: B :: ab :: D :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABApabDadeq HOoABApabDadm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadmtmp;try rewrite HT2 in HOoABApabDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDadM3 : rk(A :: B :: ab :: D :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: ab :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HABabMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDad requis par la preuve de (?)BabDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  2 et 3 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadm2 : rk(B :: ab :: D :: ad :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 2) by (solve_hyps_min HABabDadeq HABabDadm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: nil) (B :: ab :: nil) 2 2 2 HABabDadmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadm3 : rk(B :: ab :: D :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDadmtmp : rk(A :: B :: ab :: D :: ad :: nil) >= 3) by (solve_hyps_min HABabDadeq HABabDadm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadmtmp;try rewrite HT2 in HABabDadmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: nil) (D :: ad :: nil) 3 2 2 HABabDadmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBabDadM3 : rk(B :: ab :: D :: ad :: nil) <= 3).
{
	assert(HABabDadeq : rk(A :: B :: ab :: D :: ad :: nil) = 3) by (apply LABabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDadMtmp : rk(A :: B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HABabDadeq HABabDadM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: ab :: D :: ad :: nil) (A :: B :: ab :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: ab :: D :: ad :: nil) (A :: B :: ab :: D :: ad :: nil) 3 3 HABabDadMtmp Hcomp Hincl);apply HT.
}

assert(HBabDadM : rk(B :: ab :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBabDadm : rk(B :: ab :: D :: ad ::  nil) >= 1) by (solve_hyps_min HBabDadeq HBabDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCacDad *)
(* dans la couche 0 *)
Lemma LACacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadmtmp;try rewrite HT2 in HOoABCApacDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadm2 : rk(A :: C :: ac :: D :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApacDadeq HABCApacDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadmtmp;try rewrite HT2 in HABCApacDadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil) (nil) 4 0 2 HABCApacDadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDadM3 : rk(A :: C :: ac :: D :: ad :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HACacMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadm3 : rk(A :: C :: ac :: D :: ad :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACacDadM : rk(A :: C :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDadm : rk(A :: C :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HACacDadeq HACacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadmtmp;try rewrite HT2 in HOoABCApacDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDad requis par la preuve de (?)ACacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadm2 : rk(A :: C :: ac :: D :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCApacDadeq HABCApacDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadmtmp;try rewrite HT2 in HABCApacDadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: nil) (nil) 4 0 2 HABCApacDadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDadM3 : rk(A :: C :: ac :: D :: ad :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: ac :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HACacMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDad requis par la preuve de (?)CacDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  2 et 3 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadm2 : rk(C :: ac :: D :: ad :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 2) by (solve_hyps_min HACacDadeq HACacDadm2).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: nil) (C :: ac :: nil) 2 2 2 HACacDadmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadm3 : rk(C :: ac :: D :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDadmtmp : rk(A :: C :: ac :: D :: ad :: nil) >= 3) by (solve_hyps_min HACacDadeq HACacDadm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadmtmp;try rewrite HT2 in HACacDadmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: nil) (D :: ad :: nil) 3 2 2 HACacDadmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCacDadM3 : rk(C :: ac :: D :: ad :: nil) <= 3).
{
	assert(HACacDadeq : rk(A :: C :: ac :: D :: ad :: nil) = 3) by (apply LACacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDadMtmp : rk(A :: C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HACacDadeq HACacDadM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: ac :: D :: ad :: nil) (A :: C :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: ac :: D :: ad :: nil) (A :: C :: ac :: D :: ad :: nil) 3 3 HACacDadMtmp Hcomp Hincl);apply HT.
}

assert(HCacDadM : rk(C :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCacDadm : rk(C :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HCacDadeq HCacDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDad *)
(* dans la couche 0 *)
Lemma LOoABCApacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDad requis par la preuve de (?)OoABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDadM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDadm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDad requis par la preuve de (?)ABCApacDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadeq : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) = 4) by (apply LOoABCApacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDadeq HOoABCApacDadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadmtmp;try rewrite HT2 in HOoABCApacDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDadM : rk(A :: B :: C :: Ap :: ac :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDadm : rk(A :: B :: C :: Ap :: ac :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCApacDadeq HABCApacDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDpad requis par la preuve de (?)OoABCBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDDpadM : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDDpadm : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpDDpadeq HOoABCBpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpDDpad requis par la preuve de (?)OoABCBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpDDpadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpDDpadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpDDpadeq HOoABCBpCpDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpabDDpad *)
(* dans constructLemma(), requis par LOoAApCpabDDpad *)
(* dans la couche 0 *)
Lemma LOoABApCpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDDpadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabDDpadM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabDDpadm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABApCpabDDpadeq HOoABApCpabDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabDDpadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpadeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) = 4) by (apply LOoABApCpabDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDDpadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpadeq HOoABApCpabDDpadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpadmtmp;try rewrite HT2 in HOoABApCpabDDpadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabDDpadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoAApCpabDDpadM : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpabDDpadm : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpabDDpadeq HOoAApCpabDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoABCBpCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm2 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabDDpadeq HOoABCBpCpabDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabDDpadmtmp;try rewrite HT2 in HOoABCBpCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabDDpadm3 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm4 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabDDpadeq : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) = 4) by (apply LOoAApCpabDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpabDDpadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabDDpadeq HOoAApCpabDDpadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabDDpadmtmp;try rewrite HT2 in HOoAApCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabDDpadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

assert(HOoACpabDDpadM : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpabDDpadm : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpabDDpadeq HOoACpabDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoABCBpCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpabDDpadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpabDDpadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpabDDpadeq HOoABCBpCpabDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpacDDpad *)
(* dans constructLemma(), requis par LOoAApBpacDDpad *)
(* dans constructLemma(), requis par LOoACApBpacDDpad *)
(* dans la couche 0 *)
Lemma LOoABCApBpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacDDpad requis par la preuve de (?)OoABCApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpacDDpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpacDDpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacDDpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacDDpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacDDpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacDDpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpacDDpadM : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpacDDpadm : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACApBpacDDpadeq HOoACApBpacDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacDDpadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacDDpadeq : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoACApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpacDDpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacDDpadeq HOoACApBpacDDpadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacDDpadmtmp;try rewrite HT2 in HOoACApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacDDpadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

assert(HOoAApBpacDDpadM : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpacDDpadm : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpacDDpadeq HOoAApBpacDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm2 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm3 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacDDpadm4 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacDDpadeq : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoAApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpacDDpadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacDDpadeq HOoAApBpacDDpadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacDDpadmtmp;try rewrite HT2 in HOoAApBpacDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacDDpadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

assert(HOoABpacDDpadM : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpacDDpadm : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpacDDpadeq HOoABpacDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOobd *)
(* dans la couche 0 *)
Lemma LOoBDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBDbd requis par la preuve de (?)OoBDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoBDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoABCApDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBDbd requis par la preuve de (?)OoBDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBDbd requis par la preuve de (?)OoBDbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBDbdM3 : rk(Oo :: B :: D :: bd :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: bd :: nil) (Oo :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: D :: bd :: nil) ((Oo :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HOoMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBDbdm2 : rk(Oo :: B :: D :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: D :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApDbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBDbdm3 : rk(Oo :: B :: D :: bd :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: D :: bd :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBDbdM : rk(Oo :: B :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBDbdm : rk(Oo :: B :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoBDbdeq HOoBDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOobd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Oobd requis par la preuve de (?)Oobd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOobdm2 : rk(Oo :: bd :: nil) >= 2).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HOoBDbdeq : rk(Oo :: B :: D :: bd :: nil) = 3) by (apply LOoBDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDbdmtmp : rk(Oo :: B :: D :: bd :: nil) >= 3) by (solve_hyps_min HOoBDbdeq HOoBDbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (Oo :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: bd :: nil) (Oo :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: bd :: B :: D :: bd :: nil) ((Oo :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBDbdmtmp;try rewrite HT2 in HOoBDbdmtmp.
	assert(HT := rule_2 (Oo :: bd :: nil) (B :: D :: bd :: nil) (bd :: nil) 3 1 2 HOoBDbdmtmp Hbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HOobdM : rk(Oo :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOobdeq HOobdM2).
assert(HOobdm : rk(Oo :: bd ::  nil) >= 1) by (solve_hyps_min HOobdeq HOobdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbd *)
(* dans la couche 0 *)
Lemma LBBpDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpDpbd requis par la preuve de (?)BBpDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpDpbd requis par la preuve de (?)BBpDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpDpbd requis par la preuve de (?)BBpDpbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBBpDpbdM3 : rk(B :: Bp :: Dp :: bd :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Dp :: bd :: nil) (B :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Dp :: bd :: nil) ((B :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: Dp :: bd :: nil) (nil) 1 2 0 HBMtmp HBpDpbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDpbdm2 : rk(B :: Bp :: Dp :: bd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Dp :: bd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDpbdm3 : rk(B :: Bp :: Dp :: bd :: nil) >= 3).
{
	assert(HBBpDpmtmp : rk(B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HBBpDpeq HBBpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Dp :: nil) (B :: Bp :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Dp :: nil) (B :: Bp :: Dp :: bd :: nil) 3 3 HBBpDpmtmp Hcomp Hincl);apply HT.
}

assert(HBBpDpbdM : rk(B :: Bp :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpDpbdm : rk(B :: Bp :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBBpDpbdeq HBBpDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bbd requis par la preuve de (?)Bbd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBbdm2 : rk(B :: bd :: nil) >= 2).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBBpDpbdeq : rk(B :: Bp :: Dp :: bd :: nil) = 3) by (apply LBBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDpbdmtmp : rk(B :: Bp :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HBBpDpbdeq HBBpDpbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: bd :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Dp :: bd :: nil) (B :: bd :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bd :: Bp :: Dp :: bd :: nil) ((B :: bd :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDpbdmtmp;try rewrite HT2 in HBBpDpbdmtmp.
	assert(HT := rule_2 (B :: bd :: nil) (Bp :: Dp :: bd :: nil) (bd :: nil) 3 1 2 HBBpDpbdmtmp Hbdmtmp HBpDpbdMtmp Hincl);apply HT.
}

assert(HBbdM : rk(B :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBbdeq HBbdM2).
assert(HBbdm : rk(B :: bd ::  nil) >= 1) by (solve_hyps_min HBbdeq HBbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCbd *)
(* dans la couche 0 *)
Lemma LOoBCDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDbd requis par la preuve de (?)OoBCDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoBCDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoABCApDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCDbd requis par la preuve de (?)OoBCDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDbd requis par la preuve de (?)OoBCDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDbdm2 : rk(Oo :: B :: C :: D :: bd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (A :: Ap :: Oo :: B :: C :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: D :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: D :: bd :: nil) (nil) 4 0 2 HOoABCApDbdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDbdm3 : rk(Oo :: B :: C :: D :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDbdmtmp;try rewrite HT2 in HOoABCApDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: bd :: nil) (Oo :: nil) 4 1 2 HOoABCApDbdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCDbdm4 : rk(Oo :: B :: C :: D :: bd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: D :: bd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCDbdM : rk(Oo :: B :: C :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDbdm : rk(Oo :: B :: C :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCDbdeq HOoBCDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCbd requis par la preuve de (?)OoCbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)OoCbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)OoABCApbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbdm4 : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCbd requis par la preuve de (?)OoCbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCbdm2 : rk(Oo :: C :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbdeq HOoABCApbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbdmtmp;try rewrite HT2 in HOoABCApbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApbdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoCbdm3 : rk(Oo :: C :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HOoBCDbdeq : rk(Oo :: B :: C :: D :: bd :: nil) = 4) by (apply LOoBCDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDbdmtmp : rk(Oo :: B :: C :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoBCDbdeq HOoBCDbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (Oo :: C :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: bd :: nil) (Oo :: C :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: bd :: B :: D :: bd :: nil) ((Oo :: C :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCDbdmtmp;try rewrite HT2 in HOoBCDbdmtmp.
	assert(HT := rule_2 (Oo :: C :: bd :: nil) (B :: D :: bd :: nil) (bd :: nil) 4 1 2 HOoBCDbdmtmp Hbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HOoCbdM : rk(Oo :: C :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCbdeq HOoCbdM3).
assert(HOoCbdm : rk(Oo :: C :: bd ::  nil) >= 1) by (solve_hyps_min HOoCbdeq HOoCbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCbd requis par la preuve de (?)OoBCbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)OoBCbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)OoABCApbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbdm4 : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCbd requis par la preuve de (?)OoBCbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCbd requis par la preuve de (?)OoBCbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCbdm2 : rk(Oo :: B :: C :: bd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbdeq HOoABCApbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bd :: nil) (A :: Ap :: Oo :: B :: C :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbdmtmp;try rewrite HT2 in HOoABCApbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: bd :: nil) (nil) 4 0 2 HOoABCApbdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCbdm3 : rk(Oo :: B :: C :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbdeq HOoABCApbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbdmtmp;try rewrite HT2 in HOoABCApbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: bd :: nil) (Oo :: nil) 4 1 2 HOoABCApbdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoBCbdm4 : rk(Oo :: B :: C :: bd :: nil) >= 4).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HOoBCDbdeq : rk(Oo :: B :: C :: D :: bd :: nil) = 4) by (apply LOoBCDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDbdmtmp : rk(Oo :: B :: C :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoBCDbdeq HOoBCDbdm4).
	assert(HBbdeq : rk(B :: bd :: nil) = 2) by (apply LBbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbdmtmp : rk(B :: bd :: nil) >= 2) by (solve_hyps_min HBbdeq HBbdm2).
	assert(Hincl : incl (B :: bd :: nil) (list_inter (Oo :: B :: C :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: bd :: nil) (Oo :: B :: C :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: bd :: B :: D :: bd :: nil) ((Oo :: B :: C :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCDbdmtmp;try rewrite HT2 in HOoBCDbdmtmp.
	assert(HT := rule_2 (Oo :: B :: C :: bd :: nil) (B :: D :: bd :: nil) (B :: bd :: nil) 4 2 2 HOoBCDbdmtmp HBbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HOoBCbdM : rk(Oo :: B :: C :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCbdm : rk(Oo :: B :: C :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCbdeq HOoBCbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCbd requis par la preuve de (?)OoABCbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCbdm4 : rk(Oo :: A :: B :: C :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCbdM : rk(Oo :: A :: B :: C :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCbdm : rk(Oo :: A :: B :: C :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCbdeq HOoABCbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)OoABCApbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbdm4 : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbdM : rk(Oo :: A :: B :: C :: Ap :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbdm : rk(Oo :: A :: B :: C :: Ap :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbdeq HOoABCApbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpbd *)
(* dans la couche 0 *)
Lemma LBBpDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpDbd requis par la preuve de (?)BBpDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpDbd requis par la preuve de (?)BBpDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpDbd requis par la preuve de (?)BBpDbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBBpDbdM3 : rk(B :: Bp :: D :: bd :: nil) <= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: D :: bd :: nil) (Bp :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: B :: D :: bd :: nil) ((Bp :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HBpMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDbdm2 : rk(B :: Bp :: D :: bd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: D :: bd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDbdm3 : rk(B :: Bp :: D :: bd :: nil) >= 3).
{
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: D :: nil) (B :: Bp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: D :: nil) (B :: Bp :: D :: bd :: nil) 3 3 HBBpDmtmp Hcomp Hincl);apply HT.
}

assert(HBBpDbdM : rk(B :: Bp :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpDbdm : rk(B :: Bp :: D :: bd ::  nil) >= 1) by (solve_hyps_min HBBpDbdeq HBBpDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpbd requis par la preuve de (?)BBpbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpbd requis par la preuve de (?)BBpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpbdm2 : rk(B :: Bp :: bd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: bd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBBpbdm3 : rk(B :: Bp :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBBpDbdeq : rk(B :: Bp :: D :: bd :: nil) = 3) by (apply LBBpDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDbdmtmp : rk(B :: Bp :: D :: bd :: nil) >= 3) by (solve_hyps_min HBBpDbdeq HBBpDbdm3).
	assert(HBbdeq : rk(B :: bd :: nil) = 2) by (apply LBbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbdmtmp : rk(B :: bd :: nil) >= 2) by (solve_hyps_min HBbdeq HBbdm2).
	assert(Hincl : incl (B :: bd :: nil) (list_inter (B :: Bp :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: D :: bd :: nil) (B :: Bp :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: bd :: B :: D :: bd :: nil) ((B :: Bp :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDbdmtmp;try rewrite HT2 in HBBpDbdmtmp.
	assert(HT := rule_2 (B :: Bp :: bd :: nil) (B :: D :: bd :: nil) (B :: bd :: nil) 3 2 2 HBBpDbdmtmp HBbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HBBpbdM : rk(B :: Bp :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBBpbdeq HBBpbdM3).
assert(HBBpbdm : rk(B :: Bp :: bd ::  nil) >= 1) by (solve_hyps_min HBBpbdeq HBBpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpbd *)
(* dans la couche 0 *)
Lemma LOoBCpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpDDpbd requis par la preuve de (?)OoBCpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCpabDDpbd requis par la preuve de (?)OoBCpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabDDpbd requis par la preuve de (?)OoBApCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDpbd requis par la preuve de (?)OoABApCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDpbd requis par la preuve de (?)OoABApCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDpbd requis par la preuve de (?)OoABApCpabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpbdm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpbdm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDDpbdm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabDDpbd requis par la preuve de (?)OoBApCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabDDpbd requis par la preuve de (?)OoBApCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabDDpbd requis par la preuve de (?)OoBApCpabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpbdm2 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpbdm3 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDDpbdm4 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpbdeq HOoABApCpabDDpbdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpbdmtmp;try rewrite HT2 in HOoABApCpabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDDpbd requis par la preuve de (?)OoABCApCpabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpbdm2 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDDpbdeq HOoABCApCpabDDpbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDDpbdmtmp;try rewrite HT2 in HOoABCApCpabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDDpbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDDpbdm3 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpbdm4 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDDpbdmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApCpabDDpbdeq HOoBApCpabDDpbdm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDDpbdmtmp;try rewrite HT2 in HOoBApCpabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDDpbdmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpDDpbd requis par la preuve de (?)OoBCpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDDpbd requis par la preuve de (?)OoBCpDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDpbd requis par la preuve de (?)OoABCApCpDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpDDpbd requis par la preuve de (?)OoBCpDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpDDpbdm2 : rk(Oo :: B :: Cp :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpDDpbdeq HOoABCApCpDDpbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: D :: Dp :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDDpbdmtmp;try rewrite HT2 in HOoABCApCpDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: D :: Dp :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDDpbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: Cp :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoBCpDDpbdm3 : rk(Oo :: B :: Cp :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoBCpabDDpbdmtmp : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCpabDDpbdeq HOoBCpabDDpbdm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: B :: Cp :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) (Cp :: ab :: Oo :: B :: Cp :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: B :: Cp :: D :: Dp :: bd :: nil) ((Cp :: ab :: nil) ++ (Oo :: B :: Cp :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpabDDpbdmtmp;try rewrite HT2 in HOoBCpabDDpbdmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: B :: Cp :: D :: Dp :: bd :: nil) (Cp :: nil) 4 1 2 HOoBCpabDDpbdmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpDDpbdm4 : rk(Oo :: B :: Cp :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HBCpDDpeq : rk(B :: Cp :: D :: Dp :: nil) = 4) by (apply LBCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpDDpmtmp : rk(B :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HBCpDDpeq HBCpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: D :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: D :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: bd :: nil) 4 4 HBCpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCpDDpbdM : rk(Oo :: B :: Cp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpDDpbdm : rk(Oo :: B :: Cp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCpDDpbdeq HOoBCpDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpbd *)
(* dans la couche 0 *)
Lemma LOoBDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBDDpbd requis par la preuve de (?)OoBDDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBDDpbd requis par la preuve de (?)OoBDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpbd requis par la preuve de (?)OoBDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpbd requis par la preuve de (?)OoABCApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBDDpbd requis par la preuve de (?)OoBDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBDDpbdm2 : rk(Oo :: B :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpbdeq HOoABCApDDpbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: D :: Dp :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpbdmtmp;try rewrite HT2 in HOoABCApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: Dp :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApDDpbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBDDpbdm3 : rk(Oo :: B :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: D :: Dp :: bd :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoBDDpbdM3 : rk(Oo :: B :: D :: Dp :: bd :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: D :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (B :: D :: bd :: nil) (D :: nil) 2 2 1 HOoDDpMtmp HBDbdMtmp HDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBDDpbdM : rk(Oo :: B :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBDDpbdm : rk(Oo :: B :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBDDpbdeq HOoBDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpbd requis par la preuve de (?)OoCpbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpabbd requis par la preuve de (?)OoCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoAApCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbdm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbdm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbdm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabbd requis par la preuve de (?)OoAApCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabbd requis par la preuve de (?)OoAApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabbd requis par la preuve de (?)OoAApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabbdm2 : rk(Oo :: A :: Ap :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabbdm3 : rk(Oo :: A :: Ap :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabbdm4 : rk(Oo :: A :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabbdmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoABApCpabbdeq HOoABApCpabbdm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: bd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbdmtmp;try rewrite HT2 in HOoABApCpabbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpbd requis par la preuve de (?)OoCpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoCpbdm2 : rk(Oo :: Cp :: bd :: nil) >= 2).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabbdmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoAApCpabbdeq HOoAApCpabbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: bd :: nil) (Oo :: A :: Ap :: ab :: Oo :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: Cp :: bd :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabbdmtmp;try rewrite HT2 in HOoAApCpabbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: bd :: nil) (Oo :: nil) 4 1 3 HOoAApCpabbdmtmp HOomtmp HOoAApabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpbdm3 : rk(Oo :: Cp :: bd :: nil) >= 3).
{
	assert(HOoBDDpbdeq : rk(Oo :: B :: D :: Dp :: bd :: nil) = 3) by (apply LOoBDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDDpbdMtmp : rk(Oo :: B :: D :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HOoBDDpbdeq HOoBDDpbdM3).
	assert(HOoBCpDDpbdeq : rk(Oo :: B :: Cp :: D :: Dp :: bd :: nil) = 4) by (apply LOoBCpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCpDDpbdmtmp : rk(Oo :: B :: Cp :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCpDDpbdeq HOoBCpDDpbdm4).
	assert(HOobdeq : rk(Oo :: bd :: nil) = 2) by (apply LOobd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOobdmtmp : rk(Oo :: bd :: nil) >= 2) by (solve_hyps_min HOobdeq HOobdm2).
	assert(Hincl : incl (Oo :: bd :: nil) (list_inter (Oo :: Cp :: bd :: nil) (Oo :: B :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: D :: Dp :: bd :: nil) (Oo :: Cp :: bd :: Oo :: B :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: bd :: Oo :: B :: D :: Dp :: bd :: nil) ((Oo :: Cp :: bd :: nil) ++ (Oo :: B :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpDDpbdmtmp;try rewrite HT2 in HOoBCpDDpbdmtmp.
	assert(HT := rule_2 (Oo :: Cp :: bd :: nil) (Oo :: B :: D :: Dp :: bd :: nil) (Oo :: bd :: nil) 4 2 3 HOoBCpDDpbdmtmp HOobdmtmp HOoBDDpbdMtmp Hincl);apply HT.
}

assert(HOoCpbdM : rk(Oo :: Cp :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpbdeq HOoCpbdM3).
assert(HOoCpbdm : rk(Oo :: Cp :: bd ::  nil) >= 1) by (solve_hyps_min HOoCpbdeq HOoCpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpbd *)
(* dans constructLemma(), requis par LOoBCCpbd *)
(* dans la couche 0 *)
Lemma LOoABCCpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpbd requis par la preuve de (?)OoABCCpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpbdm4 : rk(Oo :: A :: B :: C :: Cp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpbdM : rk(Oo :: A :: B :: C :: Cp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpbdm : rk(Oo :: A :: B :: C :: Cp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCCpbdeq HOoABCCpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCCpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Cp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpbd requis par la preuve de (?)OoBCCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpbd requis par la preuve de (?)OoBCCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbd requis par la preuve de (?)OoABCApCpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpbd requis par la preuve de (?)OoBCCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpbd requis par la preuve de (?)OoBCCpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbdm2 : rk(Oo :: B :: C :: Cp :: bd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbdeq HOoABCApCpbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbdmtmp;try rewrite HT2 in HOoABCApCpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bd :: nil) (nil) 4 0 2 HOoABCApCpbdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbdm3 : rk(Oo :: B :: C :: Cp :: bd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbdeq HOoABCApCpbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbdmtmp;try rewrite HT2 in HOoABCApCpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bd :: nil) (Oo :: nil) 4 1 2 HOoABCApCpbdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: B :: C :: bd ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: bd ::   de rang : 4 et 4 *)
assert(HOoBCCpbdm4 : rk(Oo :: B :: C :: Cp :: bd :: nil) >= 4).
{
	assert(HOoABCbdeq : rk(Oo :: A :: B :: C :: bd :: nil) = 4) by (apply LOoABCbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCbdMtmp : rk(Oo :: A :: B :: C :: bd :: nil) <= 4) by (solve_hyps_max HOoABCbdeq HOoABCbdM4).
	assert(HOoABCCpbdeq : rk(Oo :: A :: B :: C :: Cp :: bd :: nil) = 4) by (apply LOoABCCpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpbdmtmp : rk(Oo :: A :: B :: C :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCCpbdeq HOoABCCpbdm4).
	assert(HOoBCbdeq : rk(Oo :: B :: C :: bd :: nil) = 4) by (apply LOoBCbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCbdmtmp : rk(Oo :: B :: C :: bd :: nil) >= 4) by (solve_hyps_min HOoBCbdeq HOoBCbdm4).
	assert(Hincl : incl (Oo :: B :: C :: bd :: nil) (list_inter (Oo :: A :: B :: C :: bd :: nil) (Oo :: B :: C :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: bd :: nil) (Oo :: A :: B :: C :: bd :: Oo :: B :: C :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: bd :: Oo :: B :: C :: Cp :: bd :: nil) ((Oo :: A :: B :: C :: bd :: nil) ++ (Oo :: B :: C :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpbdmtmp;try rewrite HT2 in HOoABCCpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: bd :: nil) (Oo :: B :: C :: Cp :: bd :: nil) (Oo :: B :: C :: bd :: nil) 4 4 4 HOoABCCpbdmtmp HOoBCbdmtmp HOoABCbdMtmp Hincl); apply HT.
}

assert(HOoBCCpbdM : rk(Oo :: B :: C :: Cp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCCpbdm : rk(Oo :: B :: C :: Cp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCCpbdeq HOoBCCpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpbd *)
(* dans la couche 0 *)
Lemma LOoCCpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpbd requis par la preuve de (?)OoCCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpbd requis par la preuve de (?)OoCCpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpbd requis par la preuve de (?)OoCCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbd requis par la preuve de (?)OoABCApCpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpbd requis par la preuve de (?)OoCCpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpbdm2 : rk(Oo :: C :: Cp :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbdeq HOoABCApCpbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbdmtmp;try rewrite HT2 in HOoABCApCpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApCpbdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoCCpbdM3 : rk(Oo :: C :: Cp :: bd :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: bd :: nil) (Oo :: C :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: bd :: nil) ((Oo :: C :: Cp :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (bd :: nil) (nil) 2 1 0 HOoCCpMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: C :: bd ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: bd ::   de rang : 4 et 4 *)
assert(HOoCCpbdm3 : rk(Oo :: C :: Cp :: bd :: nil) >= 3).
{
	assert(HOoABCbdeq : rk(Oo :: A :: B :: C :: bd :: nil) = 4) by (apply LOoABCbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCbdMtmp : rk(Oo :: A :: B :: C :: bd :: nil) <= 4) by (solve_hyps_max HOoABCbdeq HOoABCbdM4).
	assert(HOoABCCpbdeq : rk(Oo :: A :: B :: C :: Cp :: bd :: nil) = 4) by (apply LOoABCCpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpbdmtmp : rk(Oo :: A :: B :: C :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCCpbdeq HOoABCCpbdm4).
	assert(HOoCbdeq : rk(Oo :: C :: bd :: nil) = 3) by (apply LOoCbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCbdmtmp : rk(Oo :: C :: bd :: nil) >= 3) by (solve_hyps_min HOoCbdeq HOoCbdm3).
	assert(Hincl : incl (Oo :: C :: bd :: nil) (list_inter (Oo :: A :: B :: C :: bd :: nil) (Oo :: C :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: bd :: nil) (Oo :: A :: B :: C :: bd :: Oo :: C :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: bd :: Oo :: C :: Cp :: bd :: nil) ((Oo :: A :: B :: C :: bd :: nil) ++ (Oo :: C :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpbdmtmp;try rewrite HT2 in HOoABCCpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: bd :: nil) (Oo :: C :: Cp :: bd :: nil) (Oo :: C :: bd :: nil) 4 3 4 HOoABCCpbdmtmp HOoCbdmtmp HOoABCbdMtmp Hincl); apply HT.
}

assert(HOoCCpbdM : rk(Oo :: C :: Cp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpbdm : rk(Oo :: C :: Cp :: bd ::  nil) >= 1) by (solve_hyps_min HOoCCpbdeq HOoCCpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpbd requis par la preuve de (?)OoBCpbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCpabbd requis par la preuve de (?)OoBCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoBApCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbdm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbdm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbdm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabbd requis par la preuve de (?)OoBApCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabbd requis par la preuve de (?)OoBApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabbd requis par la preuve de (?)OoBApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabbdm2 : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabbdm3 : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabbdm4 : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabbdmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoABApCpabbdeq HOoABApCpabbdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: bd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbdmtmp;try rewrite HT2 in HOoABApCpabbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabbd requis par la preuve de (?)OoABCApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabbdm2 : rk(Oo :: B :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpabbdeq HOoABCApCpabbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabbdmtmp;try rewrite HT2 in HOoABCApCpabbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabbdm3 : rk(Oo :: B :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabbdm4 : rk(Oo :: B :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabbdmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoBApCpabbdeq HOoBApCpabbdm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: bd :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabbdmtmp;try rewrite HT2 in HOoBApCpabbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabbdmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpbd requis par la preuve de (?)OoBCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpbd requis par la preuve de (?)OoBCpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbd requis par la preuve de (?)OoABCApCpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpbd requis par la preuve de (?)OoBCpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpbdm2 : rk(Oo :: B :: Cp :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbdeq HOoABCApCpbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbdmtmp;try rewrite HT2 in HOoABCApCpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApCpbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoBCpbdm3 : rk(Oo :: B :: Cp :: bd :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoBCpabbdmtmp : rk(Oo :: B :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoBCpabbdeq HOoBCpabbdm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: B :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: ab :: bd :: nil) (Cp :: ab :: Oo :: B :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: B :: Cp :: bd :: nil) ((Cp :: ab :: nil) ++ (Oo :: B :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpabbdmtmp;try rewrite HT2 in HOoBCpabbdmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: B :: Cp :: bd :: nil) (Cp :: nil) 4 1 2 HOoBCpabbdmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBCpbdm4 : rk(Oo :: B :: Cp :: bd :: nil) >= 4).
{
	assert(HOoCCpbdeq : rk(Oo :: C :: Cp :: bd :: nil) = 3) by (apply LOoCCpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpbdMtmp : rk(Oo :: C :: Cp :: bd :: nil) <= 3) by (solve_hyps_max HOoCCpbdeq HOoCCpbdM3).
	assert(HOoBCCpbdeq : rk(Oo :: B :: C :: Cp :: bd :: nil) = 4) by (apply LOoBCCpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCCpbdmtmp : rk(Oo :: B :: C :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCCpbdeq HOoBCCpbdm4).
	assert(HOoCpbdeq : rk(Oo :: Cp :: bd :: nil) = 3) by (apply LOoCpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpbdmtmp : rk(Oo :: Cp :: bd :: nil) >= 3) by (solve_hyps_min HOoCpbdeq HOoCpbdm3).
	assert(Hincl : incl (Oo :: Cp :: bd :: nil) (list_inter (Oo :: B :: Cp :: bd :: nil) (Oo :: C :: Cp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: bd :: nil) (Oo :: B :: Cp :: bd :: Oo :: C :: Cp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Cp :: bd :: Oo :: C :: Cp :: bd :: nil) ((Oo :: B :: Cp :: bd :: nil) ++ (Oo :: C :: Cp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCCpbdmtmp;try rewrite HT2 in HOoBCCpbdmtmp.
	assert(HT := rule_2 (Oo :: B :: Cp :: bd :: nil) (Oo :: C :: Cp :: bd :: nil) (Oo :: Cp :: bd :: nil) 4 3 3 HOoBCCpbdmtmp HOoCpbdmtmp HOoCCpbdMtmp Hincl);apply HT.
}

assert(HOoBCpbdM : rk(Oo :: B :: Cp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpbdm : rk(Oo :: B :: Cp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCpbdeq HOoBCpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbd requis par la preuve de (?)OoABCApCpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpbdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpbdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpbdeq HOoABCApCpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpCpbd *)
(* dans la couche 0 *)
Lemma LOoBBpCpDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: Cp :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBBpCpDbd requis par la preuve de (?)OoBBpCpDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpCpDbd requis par la preuve de (?)OoBBpCpDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpDbd requis par la preuve de (?)OoBBpCpDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpDbd requis par la preuve de (?)OoABCApBpCpDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpDbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpCpDbd requis par la preuve de (?)OoBBpCpDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpCpDbdm2 : rk(Oo :: B :: Bp :: Cp :: D :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpCpDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDbdeq HOoABCApBpCpDbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: Cp :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: Cp :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: Cp :: D :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: Cp :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDbdmtmp;try rewrite HT2 in HOoABCApBpCpDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: Cp :: D :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpDbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBBpCpDbdm3 : rk(Oo :: B :: Bp :: Cp :: D :: bd :: nil) >= 3).
{
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Cp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (Oo :: B :: Bp :: Cp :: D :: bd :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpCpDbdm4 : rk(Oo :: B :: Bp :: Cp :: D :: bd :: nil) >= 4).
{
	assert(HOoBCpbdeq : rk(Oo :: B :: Cp :: bd :: nil) = 4) by (apply LOoBCpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCpbdmtmp : rk(Oo :: B :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCpbdeq HOoBCpbdm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Cp :: bd :: nil) (Oo :: B :: Bp :: Cp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: Cp :: bd :: nil) (Oo :: B :: Bp :: Cp :: D :: bd :: nil) 4 4 HOoBCpbdmtmp Hcomp Hincl);apply HT.
}

assert(HOoBBpCpDbdM : rk(Oo :: B :: Bp :: Cp :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpCpDbdm : rk(Oo :: B :: Bp :: Cp :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoBBpCpDbdeq HOoBBpCpDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpCpbd *)
(* dans la couche 0 *)
Lemma LOoBBpDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpDbd requis par la preuve de (?)OoBBpDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDbd requis par la preuve de (?)OoBBpDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDbd requis par la preuve de (?)OoBBpDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDbd requis par la preuve de (?)OoABCApBpDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDbd requis par la preuve de (?)OoBBpDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpDbdm2 : rk(Oo :: B :: Bp :: D :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDbdeq HOoABCApBpDbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDbdmtmp;try rewrite HT2 in HOoABCApBpDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoBBpDbdM3 : rk(Oo :: B :: Bp :: D :: bd :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: D :: bd :: nil) (Oo :: B :: Bp :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: D :: bd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HOoBBpMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpDbdm3 : rk(Oo :: B :: Bp :: D :: bd :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: bd :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBBpDbdM : rk(Oo :: B :: Bp :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpDbdm : rk(Oo :: B :: Bp :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoBBpDbdeq HOoBBpDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpCpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpCpbd requis par la preuve de (?)BBpCpbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpCpbd requis par la preuve de (?)BBpCpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpbd requis par la preuve de (?)BBpCpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpbdm2 : rk(B :: Bp :: Cp :: bd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Cp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Cp :: bd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpbdm3 : rk(B :: Bp :: Cp :: bd :: nil) >= 3).
{
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bd :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBBpCpbdm4 : rk(B :: Bp :: Cp :: bd :: nil) >= 4).
{
	assert(HOoBBpDbdeq : rk(Oo :: B :: Bp :: D :: bd :: nil) = 3) by (apply LOoBBpDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDbdMtmp : rk(Oo :: B :: Bp :: D :: bd :: nil) <= 3) by (solve_hyps_max HOoBBpDbdeq HOoBBpDbdM3).
	assert(HOoBBpCpDbdeq : rk(Oo :: B :: Bp :: Cp :: D :: bd :: nil) = 4) by (apply LOoBBpCpDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpCpDbdmtmp : rk(Oo :: B :: Bp :: Cp :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoBBpCpDbdeq HOoBBpCpDbdm4).
	assert(HBBpbdeq : rk(B :: Bp :: bd :: nil) = 3) by (apply LBBpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpbdmtmp : rk(B :: Bp :: bd :: nil) >= 3) by (solve_hyps_min HBBpbdeq HBBpbdm3).
	assert(Hincl : incl (B :: Bp :: bd :: nil) (list_inter (B :: Bp :: Cp :: bd :: nil) (Oo :: B :: Bp :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: Cp :: D :: bd :: nil) (B :: Bp :: Cp :: bd :: Oo :: B :: Bp :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Cp :: bd :: Oo :: B :: Bp :: D :: bd :: nil) ((B :: Bp :: Cp :: bd :: nil) ++ (Oo :: B :: Bp :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBBpCpDbdmtmp;try rewrite HT2 in HOoBBpCpDbdmtmp.
	assert(HT := rule_2 (B :: Bp :: Cp :: bd :: nil) (Oo :: B :: Bp :: D :: bd :: nil) (B :: Bp :: bd :: nil) 4 3 3 HOoBBpCpDbdmtmp HBBpbdmtmp HOoBBpDbdMtmp Hincl);apply HT.
}

assert(HBBpCpbdM : rk(B :: Bp :: Cp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpbdm : rk(B :: Bp :: Cp :: bd ::  nil) >= 1) by (solve_hyps_min HBBpCpbdeq HBBpCpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpabbd *)
(* dans constructLemma(), requis par LOoBApCpabbd *)
(* dans la couche 0 *)
Lemma LOoABApCpabbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabbd requis par la preuve de (?)OoABApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbdm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabbdm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabbdm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabbdM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabbdm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApCpabbdeq HOoABApCpabbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApCpabbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Cp :: ab :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabbd requis par la preuve de (?)OoBApCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabbd requis par la preuve de (?)OoBApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabbd requis par la preuve de (?)OoBApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabbdm2 : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabbdm3 : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabbdm4 : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabbdeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) = 4) by (apply LOoABApCpabbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabbdmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoABApCpabbdeq HOoABApCpabbdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: bd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbdmtmp;try rewrite HT2 in HOoABApCpabbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBApCpabbdM : rk(Oo :: B :: Ap :: Cp :: ab :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpabbdm : rk(Oo :: B :: Ap :: Cp :: ab :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApCpabbdeq HOoBApCpabbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpabbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: ab :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabbd requis par la preuve de (?)OoABCApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabbd requis par la preuve de (?)OoBCpabbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabbdm2 : rk(Oo :: B :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpabbdeq HOoABCApCpabbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabbdmtmp;try rewrite HT2 in HOoABCApCpabbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabbdm3 : rk(Oo :: B :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabbdm4 : rk(Oo :: B :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabbdeq : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) = 4) by (apply LOoBApCpabbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApCpabbdmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoBApCpabbdeq HOoBApCpabbdm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: bd :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: bd :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabbdmtmp;try rewrite HT2 in HOoBApCpabbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: bd :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabbdmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

assert(HOoBCpabbdM : rk(Oo :: B :: Cp :: ab :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpabbdm : rk(Oo :: B :: Cp :: ab :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCpabbdeq HOoBCpabbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpabbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ab :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabbd requis par la preuve de (?)OoAApCpabbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabbd requis par la preuve de (?)OoAApCpabbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabbd requis par la preuve de (?)OoAApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabbdm2 : rk(Oo :: A :: Ap :: Cp :: ab :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabbdm3 : rk(Oo :: A :: Ap :: Cp :: ab :: bd :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: bd ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabbdm4 : rk(Oo :: A :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabbdeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) = 4) by (apply LOoABApCpabbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabbdmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) >= 4) by (solve_hyps_min HOoABApCpabbdeq HOoABApCpabbdm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: bd :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: bd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabbdmtmp;try rewrite HT2 in HOoABApCpabbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: bd :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoAApCpabbdM : rk(Oo :: A :: Ap :: Cp :: ab :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpabbdm : rk(Oo :: A :: Ap :: Cp :: ab :: bd ::  nil) >= 1) by (solve_hyps_min HOoAApCpabbdeq HOoAApCpabbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabbd requis par la preuve de (?)OoABCApCpabbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabbdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabbdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabbdeq HOoABCApCpabbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDbd *)
(* dans la couche 0 *)
Lemma LBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBpDDpbdM3 : rk(Bp :: D :: Dp :: bd :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: Dp :: bd :: nil) ((D :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Bp :: Dp :: bd :: nil) (nil) 1 2 0 HDMtmp HBpDpbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDDpbdm2 : rk(Bp :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBpDeq : rk(Bp :: D :: nil) = 2) by (apply LBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDmtmp : rk(Bp :: D :: nil) >= 2) by (solve_hyps_min HBpDeq HBpDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: D :: nil) (Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: D :: nil) (Bp :: D :: Dp :: bd :: nil) 2 2 HBpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBpDDpbdm3 : rk(Bp :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil) 3 3 HBpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HBpDDpbdM : rk(Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpDDpbdm : rk(Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dbd requis par la preuve de (?)Dbd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDbdm2 : rk(D :: bd :: nil) >= 2).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBpDDpbdeq : rk(Bp :: D :: Dp :: bd :: nil) = 3) by (apply LBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDDpbdmtmp : rk(Bp :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (D :: bd :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: bd :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: bd :: Bp :: Dp :: bd :: nil) ((D :: bd :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpDDpbdmtmp;try rewrite HT2 in HBpDDpbdmtmp.
	assert(HT := rule_2 (D :: bd :: nil) (Bp :: Dp :: bd :: nil) (bd :: nil) 3 1 2 HBpDDpbdmtmp Hbdmtmp HBpDpbdMtmp Hincl);apply HT.
}

assert(HDbdM : rk(D :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDbdeq HDbdM2).
assert(HDbdm : rk(D :: bd ::  nil) >= 1) by (solve_hyps_min HDbdeq HDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADbd *)
(* dans la couche 0 *)
Lemma LABDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDbdM3 : rk(A :: B :: D :: bd :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: bd :: nil) ((A :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HAMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDbdm2 : rk(A :: B :: D :: bd :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: bd :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDbdm3 : rk(A :: B :: D :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABDbdM : rk(A :: B :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDbdm : rk(A :: B :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABDbdeq HABDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADbdm2 : rk(A :: D :: bd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: bd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HADbdm3 : rk(A :: D :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HABDbdeq : rk(A :: B :: D :: bd :: nil) = 3) by (apply LABDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDbdmtmp : rk(A :: B :: D :: bd :: nil) >= 3) by (solve_hyps_min HABDbdeq HABDbdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (A :: D :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: D :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: bd :: B :: D :: bd :: nil) ((A :: D :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDbdmtmp;try rewrite HT2 in HABDbdmtmp.
	assert(HT := rule_2 (A :: D :: bd :: nil) (B :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HABDbdmtmp HDbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HADbdM : rk(A :: D :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADbdeq HADbdM3).
assert(HADbdm : rk(A :: D :: bd ::  nil) >= 1) by (solve_hyps_min HADbdeq HADbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDbd requis par la preuve de (?)OoABCApDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDbdM : rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDbdm : rk(Oo :: A :: B :: C :: Ap :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDbdeq HOoABCApDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDbd requis par la preuve de (?)OoABCApBpDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDbdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDbdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDbdeq HOoABCApBpDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpCpDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpDbd requis par la preuve de (?)OoABCApBpCpDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpDbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpDbdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpDbdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpDbdeq HOoABCApBpCpDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabDbd *)
(* dans la couche 0 *)
Lemma LABabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDbdeq HOoABApabDbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDbdmtmp;try rewrite HT2 in HOoABApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDbdm3 : rk(A :: B :: ab :: D :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABabDbdM : rk(A :: B :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDbdm : rk(A :: B :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABabDbdeq HABabDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDbdeq HOoABApabDbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDbdmtmp;try rewrite HT2 in HOoABApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: bd ::  de rang :  2 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDbdm2 : rk(A :: ab :: D :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDbdmtmp : rk(A :: B :: ab :: D :: bd :: nil) >= 2) by (solve_hyps_min HABabDbdeq HABabDbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDbdmtmp;try rewrite HT2 in HABabDbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDbdm3 : rk(A :: ab :: D :: bd :: nil) >= 3).
{
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: ab :: D :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDbdM3 : rk(A :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABabDbdMtmp Hcomp Hincl);apply HT.
}

assert(HAabDbdM : rk(A :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDbdm : rk(A :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HAabDbdeq HAabDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbcDbd *)
(* dans la couche 0 *)
Lemma LBCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdm3 : rk(B :: C :: bc :: D :: bd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCbcDbdM : rk(B :: C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdm : rk(B :: C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  2 et 3 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdm2 : rk(C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 2) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdm3 : rk(C :: bc :: D :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 3) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCbcDbdM3 : rk(C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdMtmp : rk(B :: C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HBCbcDbdeq HBCbcDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCbcDbdMtmp Hcomp Hincl);apply HT.
}

assert(HCbcDbdM : rk(C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdm : rk(C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HCbcDbdeq HCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDpbd *)
(* dans la couche 0 *)
Lemma LBDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDDpbd requis par la preuve de (?)BDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BDDpbd requis par la preuve de (?)BDDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BDDpbd requis par la preuve de (?)BDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDDpbdm2 : rk(B :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: Dp :: bd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBDDpbdM3 : rk(B :: D :: Dp :: bd :: nil) <= 3).
{
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Dp :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: D :: Dp :: bd :: nil) (Dp :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Dp :: B :: D :: bd :: nil) ((Dp :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Dp :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HDpMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: D :: Dp :: bd ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBDDpbdm3 : rk(B :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBDDpbdeq : rk(Oo :: B :: D :: Dp :: bd :: nil) = 3) by (apply LOoBDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDDpbdmtmp : rk(Oo :: B :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoBDDpbdeq HOoBDDpbdm3).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBDDpbdmtmp;try rewrite HT2 in HOoBDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 3 2 2 HOoBDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBDDpbdM : rk(B :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBDDpbdm : rk(B :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBDDpbdeq HBDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Dp :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dpbd requis par la preuve de (?)Dpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: D :: Dp :: bd ::  de rang :  3 et 3 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HDpbdm2 : rk(Dp :: bd :: nil) >= 2).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBDDpbdeq : rk(B :: D :: Dp :: bd :: nil) = 3) by (apply LBDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDDpbdmtmp : rk(B :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HBDDpbdeq HBDDpbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: D :: Dp :: bd :: nil) (B :: D :: bd :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBDDpbdmtmp;try rewrite HT2 in HBDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Dp :: bd :: nil) (bd :: nil) 3 1 2 HBDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HDpbdM : rk(Dp :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDpbdeq HDpbdM2).
assert(HDpbdm : rk(Dp :: bd ::  nil) >= 1) by (solve_hyps_min HDpbdeq HDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpbd *)
(* dans constructLemma(), requis par LBApDDpbd *)
(* dans constructLemma(), requis par LABApDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpbd requis par la preuve de (?)OoABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpbdm4 : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApDDpbdM : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApDDpbdm : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApDDpbd requis par la preuve de (?)ABApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApDDpbd requis par la preuve de (?)ABApDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApDDpbd requis par la preuve de (?)ABApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApDDpbdm2 : rk(A :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApDDpbdm3 : rk(A :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HABApDDpbdm4 : rk(A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApDDpbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: D :: A :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: D :: Dp :: bd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoABApDDpbdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HABApDDpbdM : rk(A :: B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApDDpbdm : rk(A :: B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HABApDDpbdeq HABApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApDDpbdm2 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HBApDDpbdm3 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApDDpbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpbdeq HOoABApDDpbdm4).
	assert(HApDeq : rk(Ap :: D :: nil) = 2) by (apply LApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDmtmp : rk(Ap :: D :: nil) >= 2) by (solve_hyps_min HApDeq HApDm2).
	assert(Hincl : incl (Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: D :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpbdmtmp;try rewrite HT2 in HOoABApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (Ap :: D :: nil) 4 2 3 HOoABApDDpbdmtmp HApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HBApDDpbdm4 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HABApDDpbdeq : rk(A :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LABApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApDDpbdmtmp : rk(A :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HABApDDpbdeq HABApDDpbdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: D :: Dp :: bd :: nil) (A :: Ap :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApDDpbdmtmp;try rewrite HT2 in HABApDDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HABApDDpbdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HBApDDpbdM : rk(B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpbdm : rk(B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpbdm2 : rk(Ap :: Dp :: bd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: bd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpbdm3 : rk(Ap :: Dp :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApDDpbdeq : rk(B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LBApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApDDpbdmtmp : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpbdmtmp;try rewrite HT2 in HBApDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HApDpbdM : rk(Ap :: Dp :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpbdeq HApDpbdM3).
assert(HApDpbdm : rk(Ap :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApDpbdeq HApDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApDpbd *)
(* dans constructLemma(), requis par LAApBpDpbd *)
(* dans la couche 0 *)
Lemma LAApBpDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpDpadbd requis par la preuve de (?)AApBpDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpDpadbd requis par la preuve de (?)AApBpDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpDpadbd requis par la preuve de (?)AApBpDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpDpadbdm2 : rk(A :: Ap :: Bp :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpDpadbdm3 : rk(A :: Ap :: Bp :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Dp :: ad :: bd :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApBpDpadbdm4 : rk(A :: Ap :: Bp :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HAApBpadeq : rk(A :: Ap :: Bp :: ad :: nil) = 4) by (apply LAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpadmtmp : rk(A :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HAApBpadeq HAApBpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: Dp :: ad :: bd :: nil) 4 4 HAApBpadmtmp Hcomp Hincl);apply HT.
}

assert(HAApBpDpadbdM : rk(A :: Ap :: Bp :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpDpadbdm : rk(A :: Ap :: Bp :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAApBpDpadbdeq HAApBpDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpDpbd requis par la preuve de (?)AApBpDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpDpbd requis par la preuve de (?)AApBpDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpDpbd requis par la preuve de (?)AApBpDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpDpbdm2 : rk(A :: Ap :: Bp :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpDpbdm3 : rk(A :: Ap :: Bp :: Dp :: bd :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: Dp :: bd :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Ap :: Bp :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Ap :: Dp :: ad ::   de rang : 2 et 2 *)
assert(HAApBpDpbdm4 : rk(A :: Ap :: Bp :: Dp :: bd :: nil) >= 4).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HAApBpDpadbdeq : rk(A :: Ap :: Bp :: Dp :: ad :: bd :: nil) = 4) by (apply LAApBpDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpDpadbdmtmp : rk(A :: Ap :: Bp :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HAApBpDpadbdeq HAApBpDpadbdm4).
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Ap :: Dp :: ad :: nil) (A :: Ap :: Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Dp :: ad :: bd :: nil) (Ap :: Dp :: ad :: A :: Ap :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: A :: Ap :: Bp :: Dp :: bd :: nil) ((Ap :: Dp :: ad :: nil) ++ (A :: Ap :: Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpDpadbdmtmp;try rewrite HT2 in HAApBpDpadbdmtmp.
	assert(HT := rule_4 (Ap :: Dp :: ad :: nil) (A :: Ap :: Bp :: Dp :: bd :: nil) (Ap :: Dp :: nil) 4 2 2 HAApBpDpadbdmtmp HApDpmtmp HApDpadMtmp Hincl); apply HT.
}

assert(HAApBpDpbdM : rk(A :: Ap :: Bp :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpDpbdm : rk(A :: Ap :: Bp :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HAApBpDpbdeq HAApBpDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApDpbd requis par la preuve de (?)AApDpbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApDpbd requis par la preuve de (?)AApDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDpbd requis par la preuve de (?)AApDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpbdm2 : rk(A :: Ap :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpbdm3 : rk(A :: Ap :: Dp :: bd :: nil) >= 3).
{
	assert(HAApDpmtmp : rk(A :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HAApDpeq HAApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: bd :: nil) 3 3 HAApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAApDpbdm4 : rk(A :: Ap :: Dp :: bd :: nil) >= 4).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HAApBpDpbdeq : rk(A :: Ap :: Bp :: Dp :: bd :: nil) = 4) by (apply LAApBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpDpbdmtmp : rk(A :: Ap :: Bp :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HAApBpDpbdeq HAApBpDpbdm4).
	assert(HDpbdeq : rk(Dp :: bd :: nil) = 2) by (apply LDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDpbdmtmp : rk(Dp :: bd :: nil) >= 2) by (solve_hyps_min HDpbdeq HDpbdm2).
	assert(Hincl : incl (Dp :: bd :: nil) (list_inter (A :: Ap :: Dp :: bd :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: Dp :: bd :: nil) (A :: Ap :: Dp :: bd :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Dp :: bd :: Bp :: Dp :: bd :: nil) ((A :: Ap :: Dp :: bd :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpDpbdmtmp;try rewrite HT2 in HAApBpDpbdmtmp.
	assert(HT := rule_2 (A :: Ap :: Dp :: bd :: nil) (Bp :: Dp :: bd :: nil) (Dp :: bd :: nil) 4 2 2 HAApBpDpbdmtmp HDpbdmtmp HBpDpbdMtmp Hincl);apply HT.
}

assert(HAApDpbdM : rk(A :: Ap :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDpbdm : rk(A :: Ap :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HAApDpbdeq HAApDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApabDpbd *)
(* dans la couche 0 *)
Lemma LApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpabDpbdm2 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApBpabDpbdM3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpDpbdMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpabDpbdm3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HApBpDpeq : rk(Ap :: Bp :: Dp :: nil) = 3) by (apply LApBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpDpmtmp : rk(Ap :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HApBpDpeq HApBpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HApBpDpmtmp Hcomp Hincl);apply HT.
}

assert(HApBpabDpbdM : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpabDpbdm : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApBpabDpbdeq HApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpbdm2 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HABApabDDpbdm4 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoABApabDDpbdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApabDDpbdm2 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm3 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HBApabDDpbdm4 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HABApabDDpbdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpbdm2 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpbdm3 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpbdm2 : rk(Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpbdeq HABApabDpbdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpbdmtmp;try rewrite HT2 in HABApabDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDpbdm3 : rk(Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApabDDpbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpbdeq HBApabDDpbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: D :: bd :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpbdmtmp;try rewrite HT2 in HBApabDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: Dp :: bd :: nil) (bd :: nil) 4 1 2 HBApabDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApabDpbdM3 : rk(Ap :: ab :: Dp :: bd :: nil) <= 3).
{
	assert(HApBpabDpbdeq : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) = 3) by (apply LApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpabDpbdMtmp : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApBpabDpbdeq HApBpabDpbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HApBpabDpbdMtmp Hcomp Hincl);apply HT.
}

assert(HApabDpbdM : rk(Ap :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpbdm : rk(Ap :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpbdeq HApabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpbd requis par la preuve de (?)OoABCApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpbdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpbdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpbdeq HOoABCApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDpbd requis par la preuve de (?)OoABCApCpDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpDDpbdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDDpbdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDDpbdeq HOoABCApCpDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApabDDpbd *)
(* dans constructLemma(), requis par LABApabDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpbd requis par la preuve de (?)OoABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApabDDpbdM : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabDDpbdm : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpbdm2 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HABApabDDpbdm4 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApabDDpbdeq : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpbdeq HOoABApabDDpbdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpbdmtmp;try rewrite HT2 in HOoABApabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoABApabDDpbdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HABApabDDpbdM : rk(A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabDDpbdm : rk(A :: B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpbd requis par la preuve de (?)ABApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpbdm2 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpbd requis par la preuve de (?)BApabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApabDDpbdm2 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpbdm3 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HBApabDDpbdm4 : rk(B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HABApabDDpbdeq : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LABApabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApabDDpbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HABApabDDpbdeq HABApabDDpbdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: bd :: nil) (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: bd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpbdmtmp;try rewrite HT2 in HABApabDDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: bd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HABApabDDpbdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HBApabDDpbdM : rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApabDDpbdm : rk(B :: Ap :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBApabDDpbdeq HBApabDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpabDDpbd *)
(* dans constructLemma(), requis par LOoBApCpabDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApCpabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDpbd requis par la preuve de (?)OoABApCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDpbd requis par la preuve de (?)OoABApCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDpbd requis par la preuve de (?)OoABApCpabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpbdm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpbdm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDDpbdm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabDDpbdM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabDDpbdm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApCpabDDpbdeq HOoABApCpabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApCpabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabDDpbd requis par la preuve de (?)OoBApCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabDDpbd requis par la preuve de (?)OoBApCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabDDpbd requis par la preuve de (?)OoBApCpabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpbdm2 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpbdm3 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDDpbdm4 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpbdeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApCpabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDDpbdmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpbdeq HOoABApCpabDDpbdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpbdmtmp;try rewrite HT2 in HOoABApCpabDDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDDpbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBApCpabDDpbdM : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpabDDpbdm : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApCpabDDpbdeq HOoBApCpabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDDpbd requis par la preuve de (?)OoABCApCpabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabDDpbd requis par la preuve de (?)OoBCpabDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpbdm2 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDDpbdeq HOoABCApCpabDDpbdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDDpbdmtmp;try rewrite HT2 in HOoABCApCpabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDDpbdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDDpbdm3 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpbdm4 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDDpbdeq : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) = 4) by (apply LOoBApCpabDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApCpabDDpbdmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApCpabDDpbdeq HOoBApCpabDDpbdm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDDpbdmtmp;try rewrite HT2 in HOoBApCpabDDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: bd :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDDpbdmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

assert(HOoBCpabDDpbdM : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpabDDpbdm : rk(Oo :: B :: Cp :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCpabDDpbdeq HOoBCpabDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDDpbd requis par la preuve de (?)OoABCApCpabDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabDDpbdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabDDpbdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabDDpbdeq HOoABCApCpabDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LAabadbd *)
(* dans constructLemma(), requis par LAabDadbd *)
(* dans la couche 0 *)
Lemma LADadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadbdm2 : rk(A :: D :: ad :: bd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: ad :: bd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HADadbdM3 : rk(A :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (bd :: nil) (nil) 2 1 0 HADadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadbdm3 : rk(A :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}

assert(HADadbdM : rk(A :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadbdm : rk(A :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HADadbdeq HADadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDadbdeq HOoABApabDadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadbdmtmp;try rewrite HT2 in HOoABApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadbdm2 : rk(A :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDadbdm3 : rk(A :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAabDadbdM3 : rk(A :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HAabDbdeq : rk(A :: ab :: D :: bd :: nil) = 3) by (apply LAabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabDbdMtmp : rk(A :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HAabDbdeq HAabDbdM3).
	assert(HADadbdeq : rk(A :: D :: ad :: bd :: nil) = 3) by (apply LADadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadbdMtmp : rk(A :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HADadbdeq HADadbdM3).
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hincl : incl (A :: D :: bd :: nil) (list_inter (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil) ((A :: ab :: D :: bd :: nil) ++ (A :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) (A :: D :: bd :: nil) 3 3 3 HAabDbdMtmp HADadbdMtmp HADbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAabDadbdM : rk(A :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDadbdm : rk(A :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAabDadbdeq HAabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aabadbd requis par la preuve de (?)Aabadbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABpabDpadbd requis par la preuve de (?)Aabadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABpabDDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpabDDpadbd requis par la preuve de (?)ABBpabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDDpadbd requis par la preuve de (?)ABBpabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDDpadbd requis par la preuve de (?)OoABApBpabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDDpadbd requis par la preuve de (?)OoABApBpabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpabDDpadbd requis par la preuve de (?)ABBpabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABBpabDDpadbdm2 : rk(A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDDpadbdeq HOoABApBpabDDpadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDDpadbdmtmp;try rewrite HT2 in HOoABApBpabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApBpabDDpadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABBpabDDpadbdm3 : rk(A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpabDDpadbdm2 : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Bp :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HABpabDDpadbdm3 : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABBpabDDpadbdmtmp : rk(A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABBpabDDpadbdeq HABBpabDDpadbdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpabDDpadbdmtmp;try rewrite HT2 in HABBpabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: ab :: nil) 3 2 2 HABBpabDDpadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpabDDpadbdm4 : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HABpDDpeq : rk(A :: Bp :: D :: Dp :: nil) = 4) by (apply LABpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpDDpmtmp : rk(A :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HABpDDpeq HABpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: D :: Dp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: D :: Dp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HABpDDpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpabDpadbd requis par la preuve de (?)ABBpabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpadbd requis par la preuve de (?)ABBpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpadbd requis par la preuve de (?)OoABApBpabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpadbd requis par la preuve de (?)OoABApBpabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDpadbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDpadbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpabDpadbd requis par la preuve de (?)ABBpabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABBpabDpadbdm2 : rk(A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDpadbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDpadbdeq HOoABApBpabDpadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpadbdmtmp;try rewrite HT2 in HOoABApBpabDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApBpabDpadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABBpabDpadbdm3 : rk(A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpabDpadbdm2 : rk(A :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Bp :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HABpabDpadbdm3 : rk(A :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABBpabDpadbdmtmp : rk(A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABBpabDpadbdeq HABBpabDpadbdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: A :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Bp :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpabDpadbdmtmp;try rewrite HT2 in HABBpabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: ab :: nil) 3 2 2 HABBpabDpadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Bp :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HABpabDpadbdm4 : rk(A :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABpabDDpadbdmtmp : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABpabDDpadbdeq HABpabDDpadbdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: D :: ad :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: D :: ad :: A :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: Bp :: ab :: Dp :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpabDDpadbdmtmp;try rewrite HT2 in HABpabDDpadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: ad :: nil) 4 2 2 HABpabDDpadbdmtmp HAadmtmp HADadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aabadbd requis par la preuve de (?)Aabadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabadbd requis par la preuve de (?)Aabadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)ABabadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)OoABApabadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)OoABApabadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabadbd requis par la preuve de (?)ABabadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadbdm2 : rk(A :: B :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabadbdeq HOoABApabadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadbdmtmp;try rewrite HT2 in HOoABApabadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aabadbd requis par la preuve de (?)Aabadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabadbdm2 : rk(A :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabadbdmtmp : rk(A :: B :: ab :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabadbdeq HABabadbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadbdmtmp;try rewrite HT2 in HABabadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: Bp :: ab :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : Bp :: Dp :: bd ::   de rang : 2 et 2 *)
assert(HAabadbdm3 : rk(A :: ab :: ad :: bd :: nil) >= 3).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HABpabDpadbdmtmp : rk(A :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABpabDpadbdeq HABpabDpadbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (Bp :: Dp :: bd :: nil) (A :: ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: ab :: Dp :: ad :: bd :: nil) (Bp :: Dp :: bd :: A :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Dp :: bd :: A :: ab :: ad :: bd :: nil) ((Bp :: Dp :: bd :: nil) ++ (A :: ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpabDpadbdmtmp;try rewrite HT2 in HABpabDpadbdmtmp.
	assert(HT := rule_4 (Bp :: Dp :: bd :: nil) (A :: ab :: ad :: bd :: nil) (bd :: nil) 4 1 2 HABpabDpadbdmtmp Hbdmtmp HBpDpbdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabadbdM3 : rk(A :: ab :: ad :: bd :: nil) <= 3).
{
	assert(HAabDadbdeq : rk(A :: ab :: D :: ad :: bd :: nil) = 3) by (apply LAabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabDadbdMtmp : rk(A :: ab :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HAabDadbdeq HAabDadbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HAabDadbdMtmp Hcomp Hincl);apply HT.
}

assert(HAabadbdM : rk(A :: ab :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabadbdm : rk(A :: ab :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAabadbdeq HAabadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LApabDpadbd *)
(* dans constructLemma(), requis par LApDpadbd *)
(* dans constructLemma(), requis par LBApDDpadbd *)
(* dans constructLemma(), requis par LABApDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDpadbd requis par la preuve de (?)OoABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadbdm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadbdm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpadbdm4 : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApDDpadbdM : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApDDpadbdm : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApDDpadbd requis par la preuve de (?)ABApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApDDpadbd requis par la preuve de (?)ABApDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApDDpadbd requis par la preuve de (?)ABApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApDDpadbdm2 : rk(A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApDDpadbdm3 : rk(A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HABApDDpadbdm4 : rk(A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApDDpadbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: D :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoABApDDpadbdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HABApDDpadbdM : rk(A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApDDpadbdm : rk(A :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABApDDpadbdeq HABApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApDDpadbdm2 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HBApDDpadbdm3 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApDDpadbdeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApDDpadbdeq HOoABApDDpadbdm4).
	assert(HApDeq : rk(Ap :: D :: nil) = 2) by (apply LApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDmtmp : rk(Ap :: D :: nil) >= 2) by (solve_hyps_min HApDeq HApDm2).
	assert(Hincl : incl (Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: D :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpadbdmtmp;try rewrite HT2 in HOoABApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (Ap :: D :: nil) 4 2 3 HOoABApDDpadbdmtmp HApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HBApDDpadbdm4 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HABApDDpadbdeq : rk(A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LABApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApDDpadbdmtmp : rk(A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABApDDpadbdeq HABApDDpadbdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApDDpadbdmtmp;try rewrite HT2 in HABApDDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HABApDDpadbdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HBApDDpadbdM : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpadbdm : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpadbdm2 : rk(Ap :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApDpadbdM3 : rk(Ap :: Dp :: ad :: bd :: nil) <= 3).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: bd :: nil) ((Ap :: Dp :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (bd :: nil) (nil) 2 1 0 HApDpadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpadbdm3 : rk(Ap :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApDDpadbdeq : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LBApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApDDpadbdmtmp : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpadbdmtmp;try rewrite HT2 in HBApDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HApDpadbdM : rk(Ap :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadbdm : rk(Ap :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApDpadbdeq HApDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpadbdm2 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm4 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoABApabDDpadbdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApabDDpadbdm2 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm3 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HBApabDDpadbdm4 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HABApabDDpadbdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm2 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpadbdm2 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpadbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApabDpadbdm3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApabDDpadbdmtmp : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApabDDpadbdmtmp;try rewrite HT2 in HBApabDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (bd :: nil) 4 1 2 HBApabDDpadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApabDpadbdM3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3).
{
	assert(HApabDpbdeq : rk(Ap :: ab :: Dp :: bd :: nil) = 3) by (apply LApabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDpbdMtmp : rk(Ap :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApabDpbdeq HApabDpbdM3).
	assert(HApDpadbdeq : rk(Ap :: Dp :: ad :: bd :: nil) = 3) by (apply LApDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpadbdMtmp : rk(Ap :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApDpadbdeq HApDpadbdM3).
	assert(HApDpbdeq : rk(Ap :: Dp :: bd :: nil) = 3) by (apply LApDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpbdmtmp : rk(Ap :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HApDpbdeq HApDpbdm3).
	assert(Hincl : incl (Ap :: Dp :: bd :: nil) (list_inter (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: Dp :: ad :: bd :: nil) (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil) ((Ap :: ab :: Dp :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: bd :: nil) 3 3 3 HApabDpbdMtmp HApDpadbdMtmp HApDpbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApabDpadbdM : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpadbdm : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpadbdeq HApabDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans la couche 0 *)
Lemma LAApabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: ab :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm2 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApabDpadbdm2 : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApabDpadbdm3 : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: A :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: ab :: nil) 3 2 2 HABApabDpadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApabDpadbdm4 : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HAApDpbdeq : rk(A :: Ap :: Dp :: bd :: nil) = 4) by (apply LAApDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDpbdmtmp : rk(A :: Ap :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HAApDpbdeq HAApDpbdm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Dp :: bd :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Dp :: bd :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil) 4 4 HAApDpbdmtmp Hcomp Hincl);apply HT.
}

assert(HAApabDpadbdM : rk(A :: Ap :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApabDpadbdm : rk(A :: Ap :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAApabDpadbdeq HAApabDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BabDadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDadbdeq HOoABApabDadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadbdmtmp;try rewrite HT2 in HOoABApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(Habadbdm2 : rk(ab :: ad :: bd :: nil) >= 2).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBabDadbdmtmp : rk(B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HBabDadbdeq HBabDadbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: D :: bd :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: ab :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBabDadbdmtmp;try rewrite HT2 in HBabDadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (ab :: ad :: bd :: nil) (bd :: nil) 3 1 2 HBabDadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabadbdM2 : rk(ab :: ad :: bd :: nil) <= 2).
{
	assert(HAabadbdeq : rk(A :: ab :: ad :: bd :: nil) = 3) by (apply LAabadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadbdMtmp : rk(A :: ab :: ad :: bd :: nil) <= 3) by (solve_hyps_max HAabadbdeq HAabadbdM3).
	assert(HApabDpadbdeq : rk(Ap :: ab :: Dp :: ad :: bd :: nil) = 3) by (apply LApabDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDpadbdMtmp : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApabDpadbdeq HApabDpadbdM3).
	assert(HAApabDpadbdeq : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) = 4) by (apply LAApabDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApabDpadbdmtmp : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HAApabDpadbdeq HAApabDpadbdm4).
	assert(Hincl : incl (ab :: ad :: bd :: nil) (list_inter (A :: ab :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: ab :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: ab :: ad :: bd :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApabDpadbdmtmp;try rewrite HT2 in HAApabDpadbdmtmp.
	assert(HT := rule_3 (A :: ab :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: ad :: bd :: nil) 3 3 4 HAabadbdMtmp HApabDpadbdMtmp HAApabDpadbdmtmp Hincl);apply HT.
}


assert(HabadbdM : rk(ab :: ad :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habadbdeq HabadbdM3).
assert(Habadbdm : rk(ab :: ad :: bd ::  nil) >= 1) by (solve_hyps_min Habadbdeq Habadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ABabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDadbdeq HOoABApabDadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadbdmtmp;try rewrite HT2 in HOoABApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BabDadbd requis par la preuve de (?)BabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabDadbdm2 : rk(B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: nil) 2 2 2 HABabDadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBabDadbdm3 : rk(B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabDadbdeq HABabDadbdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: ab :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: ab :: D :: ad :: bd :: nil) (D :: ad :: nil) 3 2 2 HABabDadbdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HBabDadbdM3 : rk(B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HBabDadeq : rk(B :: ab :: D :: ad :: nil) = 3) by (apply LBabDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabDadMtmp : rk(B :: ab :: D :: ad :: nil) <= 3) by (solve_hyps_max HBabDadeq HBabDadM3).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: D :: ad :: bd :: nil) (B :: ab :: D :: ad :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: D :: ad :: B :: D :: bd :: nil) ((B :: ab :: D :: ad :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: ab :: D :: ad :: nil) (B :: D :: bd :: nil) (B :: D :: nil) 3 2 2 HBabDadMtmp HBDbdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBabDadbdM : rk(B :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBabDadbdm : rk(B :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBabDadbdeq HBabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDadbdeq HOoABApabDadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadbdmtmp;try rewrite HT2 in HOoABApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDadbdm3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HABabDadbdM3 : rk(A :: B :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: B :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HABabDbdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABabDadbdM : rk(A :: B :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDadbdm : rk(A :: B :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABabDadbdeq HABabDadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpabDpadbd *)
(* dans la couche 0 *)
Lemma LABpabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpabDDpadbd requis par la preuve de (?)ABBpabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDDpadbd requis par la preuve de (?)ABBpabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDDpadbd requis par la preuve de (?)OoABApBpabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDDpadbd requis par la preuve de (?)OoABApBpabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpabDDpadbd requis par la preuve de (?)ABBpabDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABBpabDDpadbdm2 : rk(A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDDpadbdeq HOoABApBpabDDpadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDDpadbdmtmp;try rewrite HT2 in HOoABApBpabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApBpabDDpadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABBpabDDpadbdm3 : rk(A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpabDDpadbd requis par la preuve de (?)ABpabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpabDDpadbdm2 : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Bp :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HABpabDDpadbdm3 : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABBpabDDpadbdmtmp : rk(A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABBpabDDpadbdeq HABBpabDDpadbdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpabDDpadbdmtmp;try rewrite HT2 in HABBpabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: ab :: nil) 3 2 2 HABBpabDDpadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpabDDpadbdm4 : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HABpDDpeq : rk(A :: Bp :: D :: Dp :: nil) = 4) by (apply LABpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpDDpmtmp : rk(A :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HABpDDpeq HABpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: D :: Dp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: D :: Dp :: nil) (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HABpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HABpabDDpadbdM : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpabDDpadbdm : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABpabDDpadbdeq HABpabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: ab :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABBpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABBpabDpadbd requis par la preuve de (?)ABBpabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpabDpadbd requis par la preuve de (?)ABBpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpabDpadbd requis par la preuve de (?)OoABApBpabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpabDpadbd requis par la preuve de (?)OoABApBpabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDpadbdm2 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpabDpadbdm3 : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABBpabDpadbd requis par la preuve de (?)ABBpabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABBpabDpadbdm2 : rk(A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpabDpadbdmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApBpabDpadbdeq HOoABApBpabDpadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ab :: Dp :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpabDpadbdmtmp;try rewrite HT2 in HOoABApBpabDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApBpabDpadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABBpabDpadbdm3 : rk(A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpabDpadbd requis par la preuve de (?)ABpabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpabDpadbdm2 : rk(A :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Bp :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HABpabDpadbdm3 : rk(A :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABBpabDpadbdmtmp : rk(A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABBpabDpadbdeq HABBpabDpadbdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: A :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Bp :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABBpabDpadbdmtmp;try rewrite HT2 in HABBpabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: ab :: nil) 3 2 2 HABBpabDpadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Bp :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HABpabDpadbdm4 : rk(A :: Bp :: ab :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABpabDDpadbdeq : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LABpabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpabDDpadbdmtmp : rk(A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABpabDDpadbdeq HABpabDDpadbdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: D :: ad :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Bp :: ab :: D :: Dp :: ad :: bd :: nil) (A :: D :: ad :: A :: Bp :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: Bp :: ab :: Dp :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: Bp :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABpabDDpadbdmtmp;try rewrite HT2 in HABpabDDpadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: Bp :: ab :: Dp :: ad :: bd :: nil) (A :: ad :: nil) 4 2 2 HABpabDDpadbdmtmp HAadmtmp HADadMtmp Hincl); apply HT.
}

assert(HABpabDpadbdM : rk(A :: Bp :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpabDpadbdm : rk(A :: Bp :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABpabDpadbdeq HABpabDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApabDDpadbd *)
(* dans constructLemma(), requis par LABApabDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDDpadbd requis par la preuve de (?)OoABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApabDDpadbdM : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabDDpadbdm : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpadbdm2 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HABApabDDpadbdm4 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoABApabDDpadbdeq : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApabDDpadbdeq HOoABApabDDpadbdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDDpadbdmtmp;try rewrite HT2 in HOoABApabDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoABApabDDpadbdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HABApabDDpadbdM : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabDDpadbdm : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApabDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDDpadbd requis par la preuve de (?)ABApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpadbdm2 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDDpadbdm3 : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApabDDpadbd requis par la preuve de (?)BApabDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApabDDpadbdm2 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBApabDDpadbdm3 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (B :: ab :: nil) 3 2 2 HABApabDDpadbdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HBApabDDpadbdm4 : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HABApabDDpadbdeq : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LABApabDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApabDDpadbdmtmp : rk(A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABApabDDpadbdeq HABApabDDpadbdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDDpadbdmtmp;try rewrite HT2 in HABApabDDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (B :: Ap :: ab :: D :: Dp :: ad :: bd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HABApabDDpadbdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HBApabDDpadbdM : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApabDDpadbdm : rk(B :: Ap :: ab :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBApabDDpadbdeq HBApabDDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDcd *)
(* dans la couche 0 *)
Lemma LCpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCpDDpcdM3 : rk(Cp :: D :: Dp :: cd :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: Dp :: cd :: nil) ((D :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Cp :: Dp :: cd :: nil) (nil) 1 2 0 HDMtmp HCpDpcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCpDDpcdm2 : rk(Cp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HCpDeq : rk(Cp :: D :: nil) = 2) by (apply LCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDmtmp : rk(Cp :: D :: nil) >= 2) by (solve_hyps_min HCpDeq HCpDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Cp :: D :: nil) (Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Cp :: D :: nil) (Cp :: D :: Dp :: cd :: nil) 2 2 HCpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HCpDDpcdm3 : rk(Cp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HCpDDpmtmp : rk(Cp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HCpDDpeq HCpDDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Cp :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Cp :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil) 3 3 HCpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HCpDDpcdM : rk(Cp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCpDDpcdm : rk(Cp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dcd requis par la preuve de (?)Dcd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDcdm2 : rk(D :: cd :: nil) >= 2).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpDDpcdeq : rk(Cp :: D :: Dp :: cd :: nil) = 3) by (apply LCpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDDpcdmtmp : rk(Cp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (D :: cd :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: cd :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: cd :: Cp :: Dp :: cd :: nil) ((D :: cd :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCpDDpcdmtmp;try rewrite HT2 in HCpDDpcdmtmp.
	assert(HT := rule_2 (D :: cd :: nil) (Cp :: Dp :: cd :: nil) (cd :: nil) 3 1 2 HCpDDpcdmtmp Hcdmtmp HCpDpcdMtmp Hincl);apply HT.
}

assert(HDcdM : rk(D :: cd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDcdeq HDcdM2).
assert(HDcdm : rk(D :: cd ::  nil) >= 1) by (solve_hyps_min HDcdeq HDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADcd *)
(* dans la couche 0 *)
Lemma LACDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDcdM3 : rk(A :: C :: D :: cd :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: cd :: nil) ((A :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HAMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDcdm2 : rk(A :: C :: D :: cd :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: D :: cd :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDcdm3 : rk(A :: C :: D :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACDcdM : rk(A :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACDcdm : rk(A :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACDcdeq HACDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADcdm2 : rk(A :: D :: cd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: cd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HADcdm3 : rk(A :: D :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HACDcdeq : rk(A :: C :: D :: cd :: nil) = 3) by (apply LACDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDcdmtmp : rk(A :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HACDcdeq HACDcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (A :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: cd :: C :: D :: cd :: nil) ((A :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDcdmtmp;try rewrite HT2 in HACDcdmtmp.
	assert(HT := rule_2 (A :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HACDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}

assert(HADcdM : rk(A :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADcdeq HADcdM3).
assert(HADcdm : rk(A :: D :: cd ::  nil) >= 1) by (solve_hyps_min HADcdeq HADcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBDcd *)
(* dans la couche 0 *)
Lemma LBCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDcdM3 : rk(B :: C :: D :: cd :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: D :: cd :: nil) ((B :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HBMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDcdm2 : rk(B :: C :: D :: cd :: nil) >= 2).
{
	assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: D :: cd :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDcdm3 : rk(B :: C :: D :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCDcdM : rk(B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCDcdm : rk(B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCDcdeq HBCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDcdm2 : rk(B :: D :: cd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBDcdm3 : rk(B :: D :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HBCDcdeq : rk(B :: C :: D :: cd :: nil) = 3) by (apply LBCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDcdmtmp : rk(B :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HBCDcdeq HBCDcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (B :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: cd :: C :: D :: cd :: nil) ((B :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDcdmtmp;try rewrite HT2 in HBCDcdmtmp.
	assert(HT := rule_2 (B :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HBCDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}

assert(HBDcdM : rk(B :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBDcdeq HBDcdM3).
assert(HBDcdm : rk(B :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBDcdeq HBDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABDcd *)
(* dans la couche 0 *)
Lemma LABCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCDcd requis par la preuve de (?)ABCDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)ABCDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDcd requis par la preuve de (?)ABCDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCDcdm3 : rk(A :: B :: C :: D :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: cd :: nil) (A :: nil) 4 1 2 HOoABCApDcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCDcdm4 : rk(A :: B :: C :: D :: cd :: nil) >= 4).
{
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (A :: B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: nil) (A :: B :: C :: D :: cd :: nil) 4 4 HABCDmtmp Hcomp Hincl);apply HT.
}

assert(HABCDcdM : rk(A :: B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCDcdm : rk(A :: B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HABCDcdeq HABCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDcd requis par la preuve de (?)ABDcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABDcd requis par la preuve de (?)ABDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDcd requis par la preuve de (?)ABDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDcd requis par la preuve de (?)OoABApDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDcd requis par la preuve de (?)OoABApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDcdm2 : rk(Oo :: A :: B :: Ap :: D :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDcdm3 : rk(Oo :: A :: B :: Ap :: D :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDcd requis par la preuve de (?)ABDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDcdm2 : rk(A :: B :: D :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDcdmtmp : rk(Oo :: A :: B :: Ap :: D :: cd :: nil) >= 3) by (solve_hyps_min HOoABApDcdeq HOoABApDcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: D :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDcdmtmp;try rewrite HT2 in HOoABApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApDcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDcdm3 : rk(A :: B :: D :: cd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: cd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABDcdm4 : rk(A :: B :: D :: cd :: nil) >= 4).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HABCDcdeq : rk(A :: B :: C :: D :: cd :: nil) = 4) by (apply LABCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCDcdmtmp : rk(A :: B :: C :: D :: cd :: nil) >= 4) by (solve_hyps_min HABCDcdeq HABCDcdm4).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (A :: B :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: cd :: nil) (A :: B :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: cd :: C :: D :: cd :: nil) ((A :: B :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDcdmtmp;try rewrite HT2 in HABCDcdmtmp.
	assert(HT := rule_2 (A :: B :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 4 2 2 HABCDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}

assert(HABDcdM : rk(A :: B :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDcdm : rk(A :: B :: D :: cd ::  nil) >= 1) by (solve_hyps_min HABDcdeq HABDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDcdM : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDcdm : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAacDcd *)
(* dans la couche 0 *)
Lemma LACacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDcdeq HABCApacDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDcdmtmp;try rewrite HT2 in HABCApacDcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (nil) 4 0 2 HABCApacDcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDcdm3 : rk(A :: C :: ac :: D :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACacDcdM : rk(A :: C :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDcdm : rk(A :: C :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACacDcdeq HACacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDcdeq HABCApacDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDcdmtmp;try rewrite HT2 in HABCApacDcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (nil) 4 0 2 HABCApacDcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: cd ::  de rang :  2 et 3 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDcdm2 : rk(A :: ac :: D :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDcdmtmp : rk(A :: C :: ac :: D :: cd :: nil) >= 2) by (solve_hyps_min HACacDcdeq HACacDcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDcdmtmp;try rewrite HT2 in HACacDcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDcdm3 : rk(A :: ac :: D :: cd :: nil) >= 3).
{
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: ac :: D :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDcdM3 : rk(A :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACacDcdMtmp Hcomp Hincl);apply HT.
}

assert(HAacDcdM : rk(A :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDcdm : rk(A :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HAacDcdeq HAacDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) = 4) by (apply LOoABCApacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDcdM : rk(A :: B :: C :: Ap :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDcdm : rk(A :: B :: C :: Ap :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDcdeq HABCApacDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbcDcd *)
(* dans la couche 0 *)
Lemma LBCbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDcdm3 : rk(B :: C :: bc :: D :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCbcDcdM : rk(B :: C :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDcdm : rk(B :: C :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: cd ::  de rang :  2 et 3 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDcdm2 : rk(B :: bc :: D :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDcdmtmp : rk(B :: C :: bc :: D :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDcdmtmp;try rewrite HT2 in HBCbcDcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdm3 : rk(B :: bc :: D :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdM3 : rk(B :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCbcDcdMtmp Hcomp Hincl);apply HT.
}

assert(HBbcDcdM : rk(B :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDcdm : rk(B :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDcdeq HBbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDpcd *)
(* dans constructLemma(), requis par LCDDpcd *)
(* dans la couche 0 *)
Lemma LOoCDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCDDpcd requis par la preuve de (?)OoCDDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCDDpcd requis par la preuve de (?)OoCDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoCDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCDDpcd requis par la preuve de (?)OoCDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCDDpcdm2 : rk(Oo :: C :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: D :: Dp :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApDDpcdmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCDDpcdm3 : rk(Oo :: C :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: D :: nil) (Oo :: C :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: D :: nil) (Oo :: C :: D :: Dp :: cd :: nil) 3 3 HOoCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoCDDpcdM3 : rk(Oo :: C :: D :: Dp :: cd :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: D :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (C :: D :: cd :: nil) (D :: nil) 2 2 1 HOoDDpMtmp HCDcdMtmp HDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoCDDpcdM : rk(Oo :: C :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCDDpcdm : rk(Oo :: C :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCDDpcdeq HOoCDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CDDpcd requis par la preuve de (?)CDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CDDpcd requis par la preuve de (?)CDDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CDDpcd requis par la preuve de (?)CDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCDDpcdm2 : rk(C :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (C :: D :: nil) (C :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: D :: nil) (C :: D :: Dp :: cd :: nil) 2 2 HCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCDDpcdM3 : rk(C :: D :: Dp :: cd :: nil) <= 3).
{
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Dp :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: D :: Dp :: cd :: nil) (Dp :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Dp :: C :: D :: cd :: nil) ((Dp :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Dp :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HDpMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: C :: D :: Dp :: cd ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCDDpcdm3 : rk(C :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCDDpcdeq : rk(Oo :: C :: D :: Dp :: cd :: nil) = 3) by (apply LOoCDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDDpcdmtmp : rk(Oo :: C :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoCDDpcdeq HOoCDDpcdm3).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCDDpcdmtmp;try rewrite HT2 in HOoCDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 3 2 2 HOoCDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCDDpcdM : rk(C :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCDDpcdm : rk(C :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCDDpcdeq HCDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Dp :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dpcd requis par la preuve de (?)Dpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: D :: Dp :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HDpcdm2 : rk(Dp :: cd :: nil) >= 2).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDDpcdeq : rk(C :: D :: Dp :: cd :: nil) = 3) by (apply LCDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDDpcdmtmp : rk(C :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HCDDpcdeq HCDDpcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: D :: Dp :: cd :: nil) (C :: D :: cd :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCDDpcdmtmp;try rewrite HT2 in HCDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Dp :: cd :: nil) (cd :: nil) 3 1 2 HCDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HDpcdM : rk(Dp :: cd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDpcdeq HDpcdM2).
assert(HDpcdm : rk(Dp :: cd ::  nil) >= 1) by (solve_hyps_min HDpcdeq HDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpcd *)
(* dans constructLemma(), requis par LCApDDpcd *)
(* dans constructLemma(), requis par LACApDDpcd *)
(* dans la couche 0 *)
Lemma LOoACApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApDDpcd requis par la preuve de (?)OoACApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpcdm2 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApDDpcdm3 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpcdm4 : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApDDpcdM : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApDDpcdm : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApDDpcd requis par la preuve de (?)ACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDDpcd requis par la preuve de (?)ACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)ABCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApDDpcd requis par la preuve de (?)ABCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDDpcd requis par la preuve de (?)ABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDDpcdm2 : rk(A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDDpcdm4 : rk(A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApDDpcd requis par la preuve de (?)ACApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApDDpcd requis par la preuve de (?)ACApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApDDpcdm2 : rk(A :: C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApDDpcdm3 : rk(A :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApDDpcdmtmp : rk(A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApDDpcdeq HABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDDpcdmtmp;try rewrite HT2 in HABCApDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HACApDDpcdm4 : rk(A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApDDpcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: D :: A :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpcdmtmp;try rewrite HT2 in HOoACApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: D :: Dp :: cd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoACApDDpcdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HACApDDpcdM : rk(A :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApDDpcdm : rk(A :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HACApDDpcdeq HACApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)BCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApDDpcd requis par la preuve de (?)BCApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApDDpcdm3 : rk(B :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApDDpcdm2 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApDDpcdmtmp : rk(B :: C :: Ap :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCApDDpcdeq HBCApDDpcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApDDpcdmtmp;try rewrite HT2 in HBCApDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 3 1 2 HBCApDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HCApDDpcdm3 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApDDpcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpcdeq HOoACApDDpcdm4).
	assert(HApDeq : rk(Ap :: D :: nil) = 2) by (apply LApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDmtmp : rk(Ap :: D :: nil) >= 2) by (solve_hyps_min HApDeq HApDm2).
	assert(Hincl : incl (Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: D :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpcdmtmp;try rewrite HT2 in HOoACApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: D :: nil) 4 2 3 HOoACApDDpcdmtmp HApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCApDDpcdm4 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HACApDDpcdeq : rk(A :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LACApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApDDpcdmtmp : rk(A :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HACApDDpcdeq HACApDDpcdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: D :: Dp :: cd :: nil) (A :: Ap :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApDDpcdmtmp;try rewrite HT2 in HACApDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HACApDDpcdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HCApDDpcdM : rk(C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpcdm : rk(C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpcdm2 : rk(Ap :: Dp :: cd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: cd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpcdm3 : rk(Ap :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApDDpcdeq : rk(C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApDDpcdmtmp : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpcdmtmp;try rewrite HT2 in HCApDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HApDpcdM : rk(Ap :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpcdeq HApDpcdM3).
assert(HApDpcdm : rk(Ap :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApDpcdeq HApDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAApDpcd *)
(* dans constructLemma(), requis par LAApCpDpcd *)
(* dans la couche 0 *)
Lemma LAApCpDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpDpadcd requis par la preuve de (?)AApCpDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpDpadcd requis par la preuve de (?)AApCpDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpDpadcd requis par la preuve de (?)AApCpDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpDpadcdm2 : rk(A :: Ap :: Cp :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpDpadcdm3 : rk(A :: Ap :: Cp :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Dp :: ad :: cd :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApCpDpadcdm4 : rk(A :: Ap :: Cp :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HAApCpadeq : rk(A :: Ap :: Cp :: ad :: nil) = 4) by (apply LAApCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpadmtmp : rk(A :: Ap :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HAApCpadeq HAApCpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: ad :: nil) (A :: Ap :: Cp :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: ad :: nil) (A :: Ap :: Cp :: Dp :: ad :: cd :: nil) 4 4 HAApCpadmtmp Hcomp Hincl);apply HT.
}

assert(HAApCpDpadcdM : rk(A :: Ap :: Cp :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpDpadcdm : rk(A :: Ap :: Cp :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAApCpDpadcdeq HAApCpDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpDpcd requis par la preuve de (?)AApCpDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpDpcd requis par la preuve de (?)AApCpDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpDpcd requis par la preuve de (?)AApCpDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpDpcdm2 : rk(A :: Ap :: Cp :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpDpcdm3 : rk(A :: Ap :: Cp :: Dp :: cd :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: Dp :: cd :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Ap :: Cp :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Dp ::  de rang :  2 et 2 	 A : Ap :: Dp :: ad ::   de rang : 2 et 2 *)
assert(HAApCpDpcdm4 : rk(A :: Ap :: Cp :: Dp :: cd :: nil) >= 4).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HAApCpDpadcdeq : rk(A :: Ap :: Cp :: Dp :: ad :: cd :: nil) = 4) by (apply LAApCpDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpDpadcdmtmp : rk(A :: Ap :: Cp :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HAApCpDpadcdeq HAApCpDpadcdm4).
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hincl : incl (Ap :: Dp :: nil) (list_inter (Ap :: Dp :: ad :: nil) (A :: Ap :: Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: Dp :: ad :: cd :: nil) (Ap :: Dp :: ad :: A :: Ap :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: A :: Ap :: Cp :: Dp :: cd :: nil) ((Ap :: Dp :: ad :: nil) ++ (A :: Ap :: Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpDpadcdmtmp;try rewrite HT2 in HAApCpDpadcdmtmp.
	assert(HT := rule_4 (Ap :: Dp :: ad :: nil) (A :: Ap :: Cp :: Dp :: cd :: nil) (Ap :: Dp :: nil) 4 2 2 HAApCpDpadcdmtmp HApDpmtmp HApDpadMtmp Hincl); apply HT.
}

assert(HAApCpDpcdM : rk(A :: Ap :: Cp :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpDpcdm : rk(A :: Ap :: Cp :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HAApCpDpcdeq HAApCpDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApDpcd requis par la preuve de (?)AApDpcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApDpcd requis par la preuve de (?)AApDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDpcd requis par la preuve de (?)AApDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpcdm2 : rk(A :: Ap :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpcdm3 : rk(A :: Ap :: Dp :: cd :: nil) >= 3).
{
	assert(HAApDpmtmp : rk(A :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HAApDpeq HAApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: cd :: nil) 3 3 HAApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAApDpcdm4 : rk(A :: Ap :: Dp :: cd :: nil) >= 4).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HAApCpDpcdeq : rk(A :: Ap :: Cp :: Dp :: cd :: nil) = 4) by (apply LAApCpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpDpcdmtmp : rk(A :: Ap :: Cp :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HAApCpDpcdeq HAApCpDpcdm4).
	assert(HDpcdeq : rk(Dp :: cd :: nil) = 2) by (apply LDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDpcdmtmp : rk(Dp :: cd :: nil) >= 2) by (solve_hyps_min HDpcdeq HDpcdm2).
	assert(Hincl : incl (Dp :: cd :: nil) (list_inter (A :: Ap :: Dp :: cd :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: Dp :: cd :: nil) (A :: Ap :: Dp :: cd :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Dp :: cd :: Cp :: Dp :: cd :: nil) ((A :: Ap :: Dp :: cd :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpDpcdmtmp;try rewrite HT2 in HAApCpDpcdmtmp.
	assert(HT := rule_2 (A :: Ap :: Dp :: cd :: nil) (Cp :: Dp :: cd :: nil) (Dp :: cd :: nil) 4 2 2 HAApCpDpcdmtmp HDpcdmtmp HCpDpcdMtmp Hincl);apply HT.
}

assert(HAApDpcdM : rk(A :: Ap :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDpcdm : rk(A :: Ap :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HAApDpcdeq HAApDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpDpcd *)
(* dans constructLemma(), requis par LCBpDDpcd *)
(* dans constructLemma(), requis par LBCBpDDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm2 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpDDpcdm4 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpDDpcdM : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpDDpcdm : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpDDpcd requis par la preuve de (?)BCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)BCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm2 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpDDpcd requis par la preuve de (?)BCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpDDpcd requis par la preuve de (?)BCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpDDpcdm2 : rk(B :: C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpDDpcdm3 : rk(B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : B :: Bp :: D ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HBCBpDDpcdm4 : rk(B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpDDpcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm4).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hincl : incl (B :: Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: D :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: D :: Dp :: cd :: nil) (B :: Bp :: D :: nil) 4 3 3 HOoBCBpDDpcdmtmp HBBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

assert(HBCBpDDpcdM : rk(B :: C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpDDpcdm : rk(B :: C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBCBpDDpcdeq HBCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpcd requis par la preuve de (?)OoBCBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm2 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpcdmtmp;try rewrite HT2 in HOoABCApBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpDDpcd requis par la preuve de (?)CBpDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpDDpcdm2 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HCBpDDpcdm3 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpDDpcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpcdeq HOoBCBpDDpcdm4).
	assert(HBpDeq : rk(Bp :: D :: nil) = 2) by (apply LBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDmtmp : rk(Bp :: D :: nil) >= 2) by (solve_hyps_min HBpDeq HBpDm2).
	assert(Hincl : incl (Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: D :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: C :: Bp :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpcdmtmp;try rewrite HT2 in HOoBCBpDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (Bp :: D :: nil) 4 2 3 HOoBCBpDDpcdmtmp HBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D :: Dp ::  de rang :  3 et 3 	 A : B :: Bp :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCBpDDpcdm4 : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HBBpDDpeq : rk(B :: Bp :: D :: Dp :: nil) = 3) by (apply LBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDDpMtmp : rk(B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HBBpDDpeq HBBpDDpM3).
	assert(HBCBpDDpcdeq : rk(B :: C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LBCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCBpDDpcdmtmp : rk(B :: C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HBCBpDDpcdeq HBCBpDDpcdm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (B :: Bp :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: D :: Dp :: cd :: nil) (B :: Bp :: D :: Dp :: C :: Bp :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: D :: Dp :: C :: Bp :: D :: Dp :: cd :: nil) ((B :: Bp :: D :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpDDpcdmtmp;try rewrite HT2 in HBCBpDDpcdmtmp.
	assert(HT := rule_4 (B :: Bp :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: cd :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HBCBpDDpcdmtmp HBpDDpmtmp HBBpDDpMtmp Hincl); apply HT.
}

assert(HCBpDDpcdM : rk(C :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpDDpcdm : rk(C :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCBpDDpcdeq HCBpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDpcd requis par la preuve de (?)BpDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpDpcd requis par la preuve de (?)BpDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDpcdm2 : rk(Bp :: Dp :: cd :: nil) >= 2).
{
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: Dp :: cd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpDpcdm3 : rk(Bp :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpDDpcdeq : rk(C :: Bp :: D :: Dp :: cd :: nil) = 4) by (apply LCBpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpDDpcdmtmp : rk(C :: Bp :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCBpDDpcdeq HCBpDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: D :: Dp :: cd :: nil) (C :: D :: cd :: Bp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpDDpcdmtmp;try rewrite HT2 in HCBpDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCBpDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HBpDpcdM : rk(Bp :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBpDpcdeq HBpDpcdM3).
assert(HBpDpcdm : rk(Bp :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpDpcdeq HBpDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBBpDpcd *)
(* dans constructLemma(), requis par LBBpCpDpcd *)
(* dans la couche 0 *)
Lemma LBBpCpDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpCpDpbdcd requis par la preuve de (?)BBpCpDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpCpDpbdcd requis par la preuve de (?)BBpCpDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpDpbdcd requis par la preuve de (?)BBpCpDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpDpbdcdm2 : rk(B :: Bp :: Cp :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Cp :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Cp :: Dp :: bd :: cd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpDpbdcdm3 : rk(B :: Bp :: Cp :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Dp :: bd :: cd :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpCpDpbdcdm4 : rk(B :: Bp :: Cp :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBBpCpbdeq : rk(B :: Bp :: Cp :: bd :: nil) = 4) by (apply LBBpCpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpCpbdmtmp : rk(B :: Bp :: Cp :: bd :: nil) >= 4) by (solve_hyps_min HBBpCpbdeq HBBpCpbdm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: bd :: nil) (B :: Bp :: Cp :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: bd :: nil) (B :: Bp :: Cp :: Dp :: bd :: cd :: nil) 4 4 HBBpCpbdmtmp Hcomp Hincl);apply HT.
}

assert(HBBpCpDpbdcdM : rk(B :: Bp :: Cp :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpDpbdcdm : rk(B :: Bp :: Cp :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBBpCpDpbdcdeq HBBpCpDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpCpDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpCpDpcd requis par la preuve de (?)BBpCpDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpCpDpcd requis par la preuve de (?)BBpCpDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpDpcd requis par la preuve de (?)BBpCpDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpDpcdm2 : rk(B :: Bp :: Cp :: Dp :: cd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Cp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Cp :: Dp :: cd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpDpcdm3 : rk(B :: Bp :: Cp :: Dp :: cd :: nil) >= 3).
{
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: Dp :: cd :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Bp :: Cp :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Bp :: Dp :: bd ::   de rang : 2 et 2 *)
assert(HBBpCpDpcdm4 : rk(B :: Bp :: Cp :: Dp :: cd :: nil) >= 4).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBBpCpDpbdcdeq : rk(B :: Bp :: Cp :: Dp :: bd :: cd :: nil) = 4) by (apply LBBpCpDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpCpDpbdcdmtmp : rk(B :: Bp :: Cp :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBBpCpDpbdcdeq HBBpCpDpbdcdm4).
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Bp :: Dp :: bd :: nil) (B :: Bp :: Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: Dp :: bd :: cd :: nil) (Bp :: Dp :: bd :: B :: Bp :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Dp :: bd :: B :: Bp :: Cp :: Dp :: cd :: nil) ((Bp :: Dp :: bd :: nil) ++ (B :: Bp :: Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpDpbdcdmtmp;try rewrite HT2 in HBBpCpDpbdcdmtmp.
	assert(HT := rule_4 (Bp :: Dp :: bd :: nil) (B :: Bp :: Cp :: Dp :: cd :: nil) (Bp :: Dp :: nil) 4 2 2 HBBpCpDpbdcdmtmp HBpDpmtmp HBpDpbdMtmp Hincl); apply HT.
}

assert(HBBpCpDpcdM : rk(B :: Bp :: Cp :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpDpcdm : rk(B :: Bp :: Cp :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBBpCpDpcdeq HBBpCpDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBBpDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpDpcd requis par la preuve de (?)BBpDpcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpDpcd requis par la preuve de (?)BBpDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpDpcd requis par la preuve de (?)BBpDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDpcdm2 : rk(B :: Bp :: Dp :: cd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Dp :: cd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDpcdm3 : rk(B :: Bp :: Dp :: cd :: nil) >= 3).
{
	assert(HBBpDpmtmp : rk(B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HBBpDpeq HBBpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Dp :: nil) (B :: Bp :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Dp :: nil) (B :: Bp :: Dp :: cd :: nil) 3 3 HBBpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBBpDpcdm4 : rk(B :: Bp :: Dp :: cd :: nil) >= 4).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HBBpCpDpcdeq : rk(B :: Bp :: Cp :: Dp :: cd :: nil) = 4) by (apply LBBpCpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpCpDpcdmtmp : rk(B :: Bp :: Cp :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HBBpCpDpcdeq HBBpCpDpcdm4).
	assert(HDpcdeq : rk(Dp :: cd :: nil) = 2) by (apply LDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDpcdmtmp : rk(Dp :: cd :: nil) >= 2) by (solve_hyps_min HDpcdeq HDpcdm2).
	assert(Hincl : incl (Dp :: cd :: nil) (list_inter (B :: Bp :: Dp :: cd :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: Dp :: cd :: nil) (B :: Bp :: Dp :: cd :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Dp :: cd :: Cp :: Dp :: cd :: nil) ((B :: Bp :: Dp :: cd :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpDpcdmtmp;try rewrite HT2 in HBBpCpDpcdmtmp.
	assert(HT := rule_2 (B :: Bp :: Dp :: cd :: nil) (Cp :: Dp :: cd :: nil) (Dp :: cd :: nil) 4 2 2 HBBpCpDpcdmtmp HDpcdmtmp HCpDpcdMtmp Hincl);apply HT.
}

assert(HBBpDpcdM : rk(B :: Bp :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpDpcdm : rk(B :: Bp :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBBpDpcdeq HBBpDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApacDpcd *)
(* dans la couche 0 *)
Lemma LApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpacDpcdm2 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApCpacDpcdM3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil) ((Ap :: Cp :: ac :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil) (Cp :: nil) 2 2 1 HApCpacMtmp HCpDpcdMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpacDpcdm3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HApCpDpeq : rk(Ap :: Cp :: Dp :: nil) = 3) by (apply LApCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpDpmtmp : rk(Ap :: Cp :: Dp :: nil) >= 3) by (solve_hyps_min HApCpDpeq HApCpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) 3 3 HApCpDpmtmp Hcomp Hincl);apply HT.
}

assert(HApCpacDpcdM : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacDpcdm : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApCpacDpcdeq HApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDDpcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDDpcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDDpcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDDpcdeq HABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDDpcdmtmp;try rewrite HT2 in HABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HACApacDDpcdm4 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApacDDpcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpcdmtmp;try rewrite HT2 in HOoACApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoACApacDDpcdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApacDDpcd requis par la preuve de (?)BCApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApacDDpcdm3 : rk(B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm2 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApacDDpcdmtmp : rk(B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCApacDDpcdeq HBCApacDDpcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApacDDpcdmtmp;try rewrite HT2 in HBCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 3 1 2 HBCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm3 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCApacDDpcdm4 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HACApacDDpcdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpcdmtmp;try rewrite HT2 in HOoABCApacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpcdm2 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpcdm3 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpcdeq HABCApacDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpcdmtmp;try rewrite HT2 in HABCApacDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpcdm2 : rk(Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpcdeq HACApacDpcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpcdmtmp;try rewrite HT2 in HACApacDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDpcdm3 : rk(Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApacDDpcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpcdeq HCApacDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: D :: cd :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpcdmtmp;try rewrite HT2 in HCApacDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCApacDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApacDpcdM3 : rk(Ap :: ac :: Dp :: cd :: nil) <= 3).
{
	assert(HApCpacDpcdeq : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) = 3) by (apply LApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpacDpcdMtmp : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApCpacDpcdeq HApCpacDpcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) 3 3 HApCpacDpcdMtmp Hcomp Hincl);apply HT.
}

assert(HApacDpcdM : rk(Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpcdm : rk(Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpcdeq HApacDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) = 4) by (apply LOoABCApacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpcdmtmp;try rewrite HT2 in HOoABCApacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDpcdM : rk(A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDpcdm : rk(A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDpcdeq HABCApacDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpbcDpcd *)
(* dans la couche 0 *)
Lemma LBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApBpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpbcDpcd requis par la preuve de (?)ACApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)ABCApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpbcDpcd requis par la preuve de (?)ABCApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpbcDpcd requis par la preuve de (?)ABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpbcDpcdm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpbcDpcdm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpbcDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpbcDpcd requis par la preuve de (?)ACApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpbcDpcd requis par la preuve de (?)ACApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpbcDpcd requis par la preuve de (?)ACApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpbcDpcdm2 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpbcDpcdm3 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpbcDpcdmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApBpCpbcDpcdeq HABCApBpCpbcDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcDpcdmtmp;try rewrite HT2 in HABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApBpCpbcDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpbcDpcdm4 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpbcDpcdmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApBpCpbcDpcdeq HABCApBpCpbcDpcdm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcDpcdmtmp;try rewrite HT2 in HABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpbcDpcdmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpCpbcDpcd requis par la preuve de (?)BpCpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBpCpbcDpcdm2 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HACApBpCpbcDpcdmtmp : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HACApBpCpbcDpcdeq HACApBpCpbcDpcdm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (A :: C :: Ap :: Cp :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpbcDpcdmtmp;try rewrite HT2 in HACApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) (Cp :: nil) 4 1 3 HACApBpCpbcDpcdmtmp HCpmtmp HACApCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBpCpbcDpcdM3 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) <= 3).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Bp :: Cp :: bc :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: Cp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Cp :: bc :: Cp :: Dp :: cd :: nil) ((Bp :: Cp :: bc :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: Cp :: bc :: nil) (Cp :: Dp :: cd :: nil) (Cp :: nil) 2 2 1 HBpCpbcMtmp HCpDpcdMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpCpbcDpcdm3 : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HBpCpDpeq : rk(Bp :: Cp :: Dp :: nil) = 3) by (apply LBpCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpCpDpmtmp : rk(Bp :: Cp :: Dp :: nil) >= 3) by (solve_hyps_min HBpCpDpeq HBpCpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: Cp :: Dp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Cp :: Dp :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) 3 3 HBpCpDpmtmp Hcomp Hincl);apply HT.
}

assert(HBpCpbcDpcdM : rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpCpbcDpcdm : rk(Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpCpbcDpcdeq HBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : B :: Bp :: D ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HBCBpbcDDpcdm4 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm4).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hincl : incl (B :: Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: D :: nil) 4 3 3 HOoBCBpbcDDpcdmtmp HBBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm2 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm3 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D :: Dp ::  de rang :  3 et 3 	 A : B :: Bp :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCBpbcDDpcdm4 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HBBpDDpeq : rk(B :: Bp :: D :: Dp :: nil) = 3) by (apply LBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDDpMtmp : rk(B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HBBpDDpeq HBBpDDpM3).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: Bp :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HBCBpbcDDpcdmtmp HBpDDpmtmp HBBpDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoBCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoABCApBpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDpcd requis par la preuve de (?)OoBCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDpcd requis par la preuve de (?)OoBCBpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpcdm2 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDpcd requis par la preuve de (?)BCBpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDpcdm2 : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDpcdm3 : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDpcdeq HOoBCBpbcDpcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDpcdmtmp;try rewrite HT2 in HOoBCBpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDpcd requis par la preuve de (?)BpbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: Dp :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDpcdm2 : rk(Bp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDpcdmtmp : rk(B :: C :: Bp :: bc :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDpcdeq HBCBpbcDpcdm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: Dp :: cd :: nil) (B :: C :: bc :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDpcdmtmp;try rewrite HT2 in HBCBpbcDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: Dp :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDpcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDpcdm3 : rk(Bp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpbcDDpcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpcdeq HCBpbcDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: D :: cd :: Bp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpcdmtmp;try rewrite HT2 in HCBpbcDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCBpbcDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpbcDpcdM3 : rk(Bp :: bc :: Dp :: cd :: nil) <= 3).
{
	assert(HBpCpbcDpcdeq : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) = 3) by (apply LBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpCpbcDpcdMtmp : rk(Bp :: Cp :: bc :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HBpCpbcDpcdeq HBpCpbcDpcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Bp :: bc :: Dp :: cd :: nil) (Bp :: Cp :: bc :: Dp :: cd :: nil) 3 3 HBpCpbcDpcdMtmp Hcomp Hincl);apply HT.
}

assert(HBpbcDpcdM : rk(Bp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDpcdm : rk(Bp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDpcdeq HBpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpcd requis par la preuve de (?)OoABCApBpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDpcdeq HOoABCApBpbcDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBpCpbcDpcd *)
(* dans constructLemma(), requis par LABCApBpCpbcDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbcDpcd requis par la preuve de (?)OoABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpbcDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpbcDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpbcDpcd requis par la preuve de (?)ABCApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpbcDpcd requis par la preuve de (?)ABCApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpbcDpcdm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpbcDpcdm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbcDpcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) = 4) by (apply LOoABCApBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbcDpcdeq HOoABCApBpCpbcDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcDpcdmtmp;try rewrite HT2 in HOoABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpbcDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpCpbcDpcdM : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpbcDpcdm : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HABCApBpCpbcDpcdeq HABCApBpCpbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpCpbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpbcDpcd requis par la preuve de (?)ACApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpbcDpcd requis par la preuve de (?)ACApBpCpbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpbcDpcd requis par la preuve de (?)ACApBpCpbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpbcDpcdm2 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpbcDpcdm3 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpbcDpcdeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) = 4) by (apply LABCApBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpbcDpcdmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApBpCpbcDpcdeq HABCApBpCpbcDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcDpcdmtmp;try rewrite HT2 in HABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApBpCpbcDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpbcDpcdm4 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpbcDpcdeq : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) = 4) by (apply LABCApBpCpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpbcDpcdmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApBpCpbcDpcdeq HABCApBpCpbcDpcdm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcDpcdmtmp;try rewrite HT2 in HABCApBpCpbcDpcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpbcDpcdmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HACApBpCpbcDpcdM : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpCpbcDpcdm : rk(A :: C :: Ap :: Bp :: Cp :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HACApBpCpbcDpcdeq HACApBpCpbcDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApDDpcd requis par la preuve de (?)ABCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDDpcd requis par la preuve de (?)ABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDDpcdm2 : rk(A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDDpcdm4 : rk(A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApDDpcdM : rk(A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDDpcdm : rk(A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HABCApDDpcdeq HABCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpcd requis par la preuve de (?)OoABCApBpDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpcdeq HOoABCApBpDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApacDDpcd *)
(* dans constructLemma(), requis par LACApacDDpcd *)
(* dans la couche 0 *)
Lemma LOoACApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpcd requis par la preuve de (?)OoACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApacDDpcdM : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApacDDpcdm : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDDpcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDDpcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDDpcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDDpcdeq HABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDDpcdmtmp;try rewrite HT2 in HABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HACApacDDpcdm4 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApacDDpcdeq : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApacDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApacDDpcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpcdeq HOoACApacDDpcdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpcdmtmp;try rewrite HT2 in HOoACApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoACApacDDpcdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HACApacDDpcdM : rk(A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacDDpcdm : rk(A :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpcd requis par la preuve de (?)ACApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDDpcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDDpcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDDpcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDDpcdeq HABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDDpcdmtmp;try rewrite HT2 in HABCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApacDDpcd requis par la preuve de (?)BCApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApacDDpcdm3 : rk(B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpcd requis par la preuve de (?)CApacDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm2 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApacDDpcdmtmp : rk(B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCApacDDpcdeq HBCApacDDpcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApacDDpcdmtmp;try rewrite HT2 in HBCApacDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: nil) 3 1 2 HBCApacDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpcdm3 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCApacDDpcdm4 : rk(C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HACApacDDpcdeq : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) = 4) by (apply LACApacDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApacDDpcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HACApacDDpcdeq HACApacDDpcdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpcdmtmp;try rewrite HT2 in HACApacDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: cd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HACApacDDpcdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HCApacDDpcdM : rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApacDDpcdm : rk(C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCApacDDpcdeq HCApacDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpcd requis par la preuve de (?)OoABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDDpcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDDpcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpcd requis par la preuve de (?)ABCApacDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApacDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpcdeq HOoABCApacDDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpcdmtmp;try rewrite HT2 in HOoABCApacDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDDpcdM : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDDpcdm : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDDpcdeq HABCApacDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpbcDDpcd *)
(* dans constructLemma(), requis par LBCBpbcDDpcd *)
(* dans la couche 0 *)
Lemma LOoBCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpbcDDpcdM : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcDDpcdm : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : B :: Bp :: D ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HBCBpbcDDpcdm4 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpbcDDpcdeq : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCBpbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm4).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hincl : incl (B :: Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: D :: nil) 4 3 3 HOoBCBpbcDDpcdmtmp HBBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

assert(HBCBpbcDDpcdM : rk(B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpbcDDpcdm : rk(B :: C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpcd requis par la preuve de (?)OoBCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpcd requis par la preuve de (?)BCBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpcd requis par la preuve de (?)CBpbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm2 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpcdeq HOoBCBpbcDDpcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpcdmtmp;try rewrite HT2 in HOoBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpcdm3 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D :: Dp ::  de rang :  3 et 3 	 A : B :: Bp :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCBpbcDDpcdm4 : rk(C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HBBpDDpeq : rk(B :: Bp :: D :: Dp :: nil) = 3) by (apply LBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDDpMtmp : rk(B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HBBpDDpeq HBBpDDpM3).
	assert(HBCBpbcDDpcdeq : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LBCBpbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCBpbcDDpcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HBCBpbcDDpcdeq HBCBpbcDDpcdm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: cd :: nil) (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: cd :: nil) ((B :: Bp :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpcdmtmp;try rewrite HT2 in HBCBpbcDDpcdmtmp.
	assert(HT := rule_4 (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: cd :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HBCBpbcDDpcdmtmp HBpDDpmtmp HBBpDDpMtmp Hincl); apply HT.
}

assert(HCBpbcDDpcdM : rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpbcDDpcdm : rk(C :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCBpbcDDpcdeq HCBpbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpcd requis par la preuve de (?)OoABCApBpbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDDpcdeq HOoABCApBpbcDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAadcd *)
(* dans constructLemma(), requis par LACpDpadcd *)
(* dans la couche 0 *)
Lemma LACpDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpDDpadcd requis par la preuve de (?)ACpDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpDDpadcd requis par la preuve de (?)ACpDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpDDpadcd requis par la preuve de (?)ACpDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpadcdm2 : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpadcdm3 : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACpDeq : rk(A :: Cp :: D :: nil) = 3) by (apply LACpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDmtmp : rk(A :: Cp :: D :: nil) >= 3) by (solve_hyps_min HACpDeq HACpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil) 3 3 HACpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpadcdm4 : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HACpDDpeq : rk(A :: Cp :: D :: Dp :: nil) = 4) by (apply LACpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpmtmp : rk(A :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HACpDDpeq HACpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: Dp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: Dp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil) 4 4 HACpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HACpDDpadcdM : rk(A :: Cp :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpDDpadcdm : rk(A :: Cp :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACpDDpadcdeq HACpDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpDpadcd requis par la preuve de (?)ACpDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpDpadcd requis par la preuve de (?)ACpDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpDpadcd requis par la preuve de (?)ACpDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDpadcdm2 : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDpadcdm3 : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACpDpeq : rk(A :: Cp :: Dp :: nil) = 3) by (apply LACpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDpmtmp : rk(A :: Cp :: Dp :: nil) >= 3) by (solve_hyps_min HACpDpeq HACpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: Dp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: Dp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil) 3 3 HACpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Cp :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HACpDpadcdm4 : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACpDDpadcdeq : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LACpDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpadcdmtmp : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACpDDpadcdeq HACpDDpadcdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: D :: ad :: nil) (A :: Cp :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: D :: Dp :: ad :: cd :: nil) (A :: D :: ad :: A :: Cp :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: Cp :: Dp :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: Cp :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpDDpadcdmtmp;try rewrite HT2 in HACpDDpadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: Cp :: Dp :: ad :: cd :: nil) (A :: ad :: nil) 4 2 2 HACpDDpadcdmtmp HAadmtmp HADadMtmp Hincl); apply HT.
}

assert(HACpDpadcdM : rk(A :: Cp :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpDpadcdm : rk(A :: Cp :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACpDpadcdeq HACpDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Aadcd requis par la preuve de (?)Aadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCadcd requis par la preuve de (?)Aadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCadcd requis par la preuve de (?)OoABCadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCadcdm4 : rk(Oo :: A :: B :: C :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Aadcd requis par la preuve de (?)Aadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HAadcdm2 : rk(A :: ad :: cd :: nil) >= 2).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCadcdmtmp : rk(Oo :: A :: B :: C :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCadcdeq HOoABCadcdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ad :: cd :: nil) (Oo :: A :: B :: C :: ad :: A :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: ad :: cd :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCadcdmtmp;try rewrite HT2 in HOoABCadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: ad :: cd :: nil) (A :: ad :: nil) 4 2 4 HOoABCadcdmtmp HAadmtmp HOoABCadMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: Cp :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : Cp :: Dp :: cd ::   de rang : 2 et 2 *)
assert(HAadcdm3 : rk(A :: ad :: cd :: nil) >= 3).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HACpDpadcdeq : rk(A :: Cp :: Dp :: ad :: cd :: nil) = 4) by (apply LACpDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDpadcdmtmp : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACpDpadcdeq HACpDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (Cp :: Dp :: cd :: nil) (A :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Dp :: ad :: cd :: nil) (Cp :: Dp :: cd :: A :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Dp :: cd :: A :: ad :: cd :: nil) ((Cp :: Dp :: cd :: nil) ++ (A :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpDpadcdmtmp;try rewrite HT2 in HACpDpadcdmtmp.
	assert(HT := rule_4 (Cp :: Dp :: cd :: nil) (A :: ad :: cd :: nil) (cd :: nil) 4 1 2 HACpDpadcdmtmp Hcdmtmp HCpDpcdMtmp Hincl); apply HT.
}

assert(HAadcdM : rk(A :: ad :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAadcdeq HAadcdM3).
assert(HAadcdm : rk(A :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAadcdeq HAadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABadcd *)
(* dans la couche 0 *)
Lemma LABDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDadcd requis par la preuve de (?)ABDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABDadcd requis par la preuve de (?)ABDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)ABDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)OoABApDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)OoABApDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadcdm2 : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadcdm3 : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDadcd requis par la preuve de (?)ABDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDadcdm2 : rk(A :: B :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDadcdmtmp : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApDadcdeq HOoABApDadcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDadcdmtmp;try rewrite HT2 in HOoABApDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: ad :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApDadcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadcdm3 : rk(A :: B :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: ad :: cd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadcdm4 : rk(A :: B :: D :: ad :: cd :: nil) >= 4).
{
	assert(HABDcdeq : rk(A :: B :: D :: cd :: nil) = 4) by (apply LABDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDcdmtmp : rk(A :: B :: D :: cd :: nil) >= 4) by (solve_hyps_min HABDcdeq HABDcdm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: cd :: nil) (A :: B :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: cd :: nil) (A :: B :: D :: ad :: cd :: nil) 4 4 HABDcdmtmp Hcomp Hincl);apply HT.
}

assert(HABDadcdM : rk(A :: B :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDadcdm : rk(A :: B :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABDadcdeq HABDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABadcd *)
(* dans la couche 0 *)
Lemma LADadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadcdm2 : rk(A :: D :: ad :: cd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: ad :: cd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HADadcdM3 : rk(A :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (cd :: nil) (nil) 2 1 0 HADadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadcdm3 : rk(A :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}

assert(HADadcdM : rk(A :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadcdm : rk(A :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HADadcdeq HADadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABadcd requis par la preuve de (?)ABadcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABadcd requis par la preuve de (?)ABadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)ABadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)OoABApadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)OoABApadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadcdm2 : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadcdm3 : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABadcd requis par la preuve de (?)ABadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABadcdm2 : rk(A :: B :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadcdmtmp : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApadcdeq HOoABApadcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadcdmtmp;try rewrite HT2 in HOoABApadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApadcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABadcdm3 : rk(A :: B :: ad :: cd :: nil) >= 3).
{
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ad :: nil) (A :: B :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ad :: nil) (A :: B :: ad :: cd :: nil) 3 3 HABadmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABadcdm4 : rk(A :: B :: ad :: cd :: nil) >= 4).
{
	assert(HADadcdeq : rk(A :: D :: ad :: cd :: nil) = 3) by (apply LADadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadcdMtmp : rk(A :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HADadcdeq HADadcdM3).
	assert(HABDadcdeq : rk(A :: B :: D :: ad :: cd :: nil) = 4) by (apply LABDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDadcdmtmp : rk(A :: B :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABDadcdeq HABDadcdm4).
	assert(HAadcdeq : rk(A :: ad :: cd :: nil) = 3) by (apply LAadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadcdmtmp : rk(A :: ad :: cd :: nil) >= 3) by (solve_hyps_min HAadcdeq HAadcdm3).
	assert(Hincl : incl (A :: ad :: cd :: nil) (list_inter (A :: B :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: cd :: nil) (A :: B :: ad :: cd :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ad :: cd :: A :: D :: ad :: cd :: nil) ((A :: B :: ad :: cd :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDadcdmtmp;try rewrite HT2 in HABDadcdmtmp.
	assert(HT := rule_2 (A :: B :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil) (A :: ad :: cd :: nil) 4 3 3 HABDadcdmtmp HAadcdmtmp HADadcdMtmp Hincl);apply HT.
}

assert(HABadcdM : rk(A :: B :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABadcdm : rk(A :: B :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABadcdeq HABadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABadcd requis par la preuve de (?)OoABadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpadcd requis par la preuve de (?)OoABadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpadcd requis par la preuve de (?)OoABCCpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABadcd requis par la preuve de (?)OoABadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)OoABadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)OoABApadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)OoABApadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadcdm2 : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadcdm3 : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABadcd requis par la preuve de (?)OoABadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABadcdm2 : rk(Oo :: A :: B :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadcdmtmp : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApadcdeq HOoABApadcdm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadcdmtmp;try rewrite HT2 in HOoABApadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ad :: cd :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApadcdmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABadcdm3 : rk(Oo :: A :: B :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpadcdmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCCpadcdeq HOoABCCpadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: cd :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadcdmtmp;try rewrite HT2 in HOoABCCpadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCCpadcdmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABadcdm4 : rk(Oo :: A :: B :: ad :: cd :: nil) >= 4).
{
	assert(HOoABadeq : rk(Oo :: A :: B :: ad :: nil) = 4) by (apply LOoABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABadmtmp : rk(Oo :: A :: B :: ad :: nil) >= 4) by (solve_hyps_min HOoABadeq HOoABadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ad :: nil) (Oo :: A :: B :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ad :: nil) (Oo :: A :: B :: ad :: cd :: nil) 4 4 HOoABadmtmp Hcomp Hincl);apply HT.
}

assert(HOoABadcdM : rk(Oo :: A :: B :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABadcdm : rk(Oo :: A :: B :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABadcdeq HOoABadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCadcd requis par la preuve de (?)OoABCadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCadcdm4 : rk(Oo :: A :: B :: C :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCadcdM : rk(Oo :: A :: B :: C :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCadcdm : rk(Oo :: A :: B :: C :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCadcdeq HOoABCadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpadcd requis par la preuve de (?)OoABCCpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpadcdM : rk(Oo :: A :: B :: C :: Cp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpadcdm : rk(Oo :: A :: B :: C :: Cp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCCpadcdeq HOoABCCpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LAacadcd *)
(* dans la couche 0 *)
Lemma LAacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadcdmtmp;try rewrite HT2 in HABCApacDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApacDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadcdm2 : rk(A :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDadcdm3 : rk(A :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAacDadcdM3 : rk(A :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HAacDcdeq : rk(A :: ac :: D :: cd :: nil) = 3) by (apply LAacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacDcdMtmp : rk(A :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HAacDcdeq HAacDcdM3).
	assert(HADadcdeq : rk(A :: D :: ad :: cd :: nil) = 3) by (apply LADadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadcdMtmp : rk(A :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HADadcdeq HADadcdM3).
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hincl : incl (A :: D :: cd :: nil) (list_inter (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil) ((A :: ac :: D :: cd :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) (A :: D :: cd :: nil) 3 3 3 HAacDcdMtmp HADadcdMtmp HADcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAacDadcdM : rk(A :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDadcdm : rk(A :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAacDadcdeq HAacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aacadcd requis par la preuve de (?)Aacadcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACpacDpadcd requis par la preuve de (?)Aacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACpacDDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpacDDpadcd requis par la preuve de (?)OoABCBpCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpacDDpadcdm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDDpadcd requis par la preuve de (?)OoABCApCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpacDDpadcdm2 : rk(Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDDpadcdeq HOoABCApCpacDDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApCpacDDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpacDDpadcdm3 : rk(Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCBpCpacDDpadcdeq HOoABCBpCpacDDpadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpacDDpadcdmtmp;try rewrite HT2 in HOoABCBpCpacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpacDDpadcdmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ABCApCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ABCApCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacDDpadcdm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacDDpadcdm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDDpadcdeq HOoABCApCpacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACCpacDDpadcdm2 : rk(A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApCpacDDpadcdmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApCpacDDpadcdeq HABCApCpacDDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacDDpadcdmtmp;try rewrite HT2 in HABCApCpacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HABCApCpacDDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HACCpacDDpadcdm3 : rk(A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoACCpacDDpadcdmtmp : rk(Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoACCpacDDpadcdeq HOoACCpacDDpadcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: C :: Cp :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpacDDpadcdmtmp;try rewrite HT2 in HOoACCpacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoACCpacDDpadcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpacDDpadcdm2 : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HACpacDDpadcdm3 : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACCpacDDpadcdmtmp : rk(A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACCpacDDpadcdeq HACCpacDDpadcdm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpacDDpadcdmtmp;try rewrite HT2 in HACCpacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: ac :: nil) 3 2 2 HACCpacDDpadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpacDDpadcdm4 : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HACpDDpeq : rk(A :: Cp :: D :: Dp :: nil) = 4) by (apply LACpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpmtmp : rk(A :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HACpDDpeq HACpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: Dp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: Dp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HACpDDpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpacDpadcd requis par la preuve de (?)OoABCBpCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpacDpadcdm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpadcd requis par la preuve de (?)OoABCApCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpacDpadcdm2 : rk(Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpadcdeq HOoABCApCpacDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApCpacDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpacDpadcdm3 : rk(Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpacDpadcdmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCBpCpacDpadcdeq HOoABCBpCpacDpadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpacDpadcdmtmp;try rewrite HT2 in HOoABCBpCpacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpacDpadcdmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ABCApCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ABCApCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacDpadcdm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacDpadcdm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpadcdeq HOoABCApCpacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACCpacDpadcdm2 : rk(A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApCpacDpadcdmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApCpacDpadcdeq HABCApCpacDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacDpadcdmtmp;try rewrite HT2 in HABCApCpacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HABCApCpacDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HACCpacDpadcdm3 : rk(A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoACCpacDpadcdmtmp : rk(Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoACCpacDpadcdeq HOoACCpacDpadcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: C :: Cp :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpacDpadcdmtmp;try rewrite HT2 in HOoACCpacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoACCpacDpadcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpacDpadcdm2 : rk(A :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HACpacDpadcdm3 : rk(A :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACCpacDpadcdmtmp : rk(A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACCpacDpadcdeq HACCpacDpadcdm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: A :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: Cp :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpacDpadcdmtmp;try rewrite HT2 in HACCpacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: ac :: nil) 3 2 2 HACCpacDpadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HACpacDpadcdm4 : rk(A :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACpacDDpadcdmtmp : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACpacDDpadcdeq HACpacDDpadcdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: D :: ad :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: D :: ad :: A :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: Cp :: ac :: Dp :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpacDDpadcdmtmp;try rewrite HT2 in HACpacDDpadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: ad :: nil) 4 2 2 HACpacDDpadcdmtmp HAadmtmp HADadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aacadcd requis par la preuve de (?)Aacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacadcd requis par la preuve de (?)Aacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ACacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacadcd requis par la preuve de (?)OoABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacadcdm2 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacadcdm4 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacadcdeq HOoABCApacadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadcdmtmp;try rewrite HT2 in HOoABCApacadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacadcd requis par la preuve de (?)ACacadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacadcdm2 : rk(A :: C :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacadcdmtmp : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacadcdeq HABCApacadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacadcdmtmp;try rewrite HT2 in HABCApacadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: ad :: cd :: nil) (nil) 4 0 2 HABCApacadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aacadcd requis par la preuve de (?)Aacadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacadcdm2 : rk(A :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacadcdmtmp : rk(A :: C :: ac :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacadcdeq HACacadcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacadcdmtmp;try rewrite HT2 in HACacadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : Cp :: Dp :: cd ::   de rang : 2 et 2 *)
assert(HAacadcdm3 : rk(A :: ac :: ad :: cd :: nil) >= 3).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HACpacDpadcdmtmp : rk(A :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACpacDpadcdeq HACpacDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (Cp :: Dp :: cd :: nil) (A :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: ac :: Dp :: ad :: cd :: nil) (Cp :: Dp :: cd :: A :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Dp :: cd :: A :: ac :: ad :: cd :: nil) ((Cp :: Dp :: cd :: nil) ++ (A :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpacDpadcdmtmp;try rewrite HT2 in HACpacDpadcdmtmp.
	assert(HT := rule_4 (Cp :: Dp :: cd :: nil) (A :: ac :: ad :: cd :: nil) (cd :: nil) 4 1 2 HACpacDpadcdmtmp Hcdmtmp HCpDpcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacadcdM3 : rk(A :: ac :: ad :: cd :: nil) <= 3).
{
	assert(HAacDadcdeq : rk(A :: ac :: D :: ad :: cd :: nil) = 3) by (apply LAacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacDadcdMtmp : rk(A :: ac :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HAacDadcdeq HAacDadcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ac :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HAacDadcdMtmp Hcomp Hincl);apply HT.
}

assert(HAacadcdM : rk(A :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacadcdm : rk(A :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAacadcdeq HAacadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LApacDpadcd *)
(* dans constructLemma(), requis par LApDpadcd *)
(* dans constructLemma(), requis par LCApDDpadcd *)
(* dans constructLemma(), requis par LACApDDpadcd *)
(* dans la couche 0 *)
Lemma LOoACApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApDDpadcd requis par la preuve de (?)OoACApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpadcdm2 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApDDpadcdm3 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpadcdm4 : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApDDpadcdM : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApDDpadcdm : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApDDpadcd requis par la preuve de (?)ACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDDpadcd requis par la preuve de (?)ACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)ABCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApDDpadcd requis par la preuve de (?)ABCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDDpadcd requis par la preuve de (?)ABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDDpadcdm2 : rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDDpadcdm4 : rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApDDpadcd requis par la preuve de (?)ACApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApDDpadcd requis par la preuve de (?)ACApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApDDpadcdm2 : rk(A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApDDpadcdm3 : rk(A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApDDpadcdmtmp : rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApDDpadcdeq HABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDDpadcdmtmp;try rewrite HT2 in HABCApDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HACApDDpadcdm4 : rk(A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApDDpadcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: D :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpadcdmtmp;try rewrite HT2 in HOoACApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoACApDDpadcdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HACApDDpadcdM : rk(A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApDDpadcdm : rk(A :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACApDDpadcdeq HACApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)BCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApDDpadcd requis par la preuve de (?)BCApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApDDpadcdm3 : rk(B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApDDpadcdm2 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApDDpadcdmtmp : rk(B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HBCApDDpadcdeq HBCApDDpadcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApDDpadcdmtmp;try rewrite HT2 in HBCApDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 3 1 2 HBCApDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HCApDDpadcdm3 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApDDpadcdeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApDDpadcdeq HOoACApDDpadcdm4).
	assert(HApDeq : rk(Ap :: D :: nil) = 2) by (apply LApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDmtmp : rk(Ap :: D :: nil) >= 2) by (solve_hyps_min HApDeq HApDm2).
	assert(Hincl : incl (Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: D :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpadcdmtmp;try rewrite HT2 in HOoACApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: D :: nil) 4 2 3 HOoACApDDpadcdmtmp HApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCApDDpadcdm4 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HACApDDpadcdeq : rk(A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LACApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApDDpadcdmtmp : rk(A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACApDDpadcdeq HACApDDpadcdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApDDpadcdmtmp;try rewrite HT2 in HACApDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HACApDDpadcdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HCApDDpadcdM : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpadcdm : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApDpadcdm2 : rk(Ap :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HApDpeq : rk(Ap :: Dp :: nil) = 2) by (apply LApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpmtmp : rk(Ap :: Dp :: nil) >= 2) by (solve_hyps_min HApDpeq HApDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil) 2 2 HApDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApDpadcdM3 : rk(Ap :: Dp :: ad :: cd :: nil) <= 3).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: cd :: nil) ((Ap :: Dp :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (cd :: nil) (nil) 2 1 0 HApDpadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpadcdm3 : rk(Ap :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApDDpadcdeq : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApDDpadcdmtmp : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpadcdmtmp;try rewrite HT2 in HCApDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HApDpadcdM : rk(Ap :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadcdm : rk(Ap :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApDpadcdeq HApDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpadcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDDpadcdeq HABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDDpadcdmtmp;try rewrite HT2 in HABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm4 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApacDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpadcdmtmp;try rewrite HT2 in HOoACApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoACApacDDpadcdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApacDDpadcd requis par la preuve de (?)BCApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApacDDpadcdm3 : rk(B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm2 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApacDDpadcdmtmp : rk(B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HBCApacDDpadcdeq HBCApacDDpadcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApacDDpadcdmtmp;try rewrite HT2 in HBCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 3 1 2 HBCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm3 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCApacDDpadcdm4 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HACApacDDpadcdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpadcdm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpadcdm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpadcdeq HABCApacDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpadcdmtmp;try rewrite HT2 in HABCApacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpadcdm2 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApacDpadcdm3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApacDDpadcdmtmp : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApacDDpadcdmtmp;try rewrite HT2 in HCApacDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCApacDDpadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApacDpadcdM3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3).
{
	assert(HApacDpcdeq : rk(Ap :: ac :: Dp :: cd :: nil) = 3) by (apply LApacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDpcdMtmp : rk(Ap :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApacDpcdeq HApacDpcdM3).
	assert(HApDpadcdeq : rk(Ap :: Dp :: ad :: cd :: nil) = 3) by (apply LApDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpadcdMtmp : rk(Ap :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApDpadcdeq HApDpadcdM3).
	assert(HApDpcdeq : rk(Ap :: Dp :: cd :: nil) = 3) by (apply LApDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpcdmtmp : rk(Ap :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HApDpcdeq HApDpcdm3).
	assert(Hincl : incl (Ap :: Dp :: cd :: nil) (list_inter (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil) ((Ap :: ac :: Dp :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: cd :: nil) 3 3 3 HApacDpcdMtmp HApDpadcdMtmp HApDpcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApacDpadcdM : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpadcdm : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpadcdeq HApacDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans la couche 0 *)
Lemma LAApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpadcdm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpadcdm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpadcdeq HABCApacDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpadcdmtmp;try rewrite HT2 in HABCApacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApacDpadcdm2 : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAApacDpadcdm3 : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: A :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: ac :: nil) 3 2 2 HACApacDpadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAApacDpadcdm4 : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HAApDpcdeq : rk(A :: Ap :: Dp :: cd :: nil) = 4) by (apply LAApDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDpcdmtmp : rk(A :: Ap :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HAApDpcdeq HAApDpcdm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Dp :: cd :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Dp :: cd :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HAApDpcdmtmp Hcomp Hincl);apply HT.
}

assert(HAApacDpadcdM : rk(A :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApacDpadcdm : rk(A :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAApacDpadcdeq HAApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: ad :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CacDadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadcdmtmp;try rewrite HT2 in HABCApacDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApacDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Hacadcdm2 : rk(ac :: ad :: cd :: nil) >= 2).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCacDadcdmtmp : rk(C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HCacDadcdeq HCacDadcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: D :: cd :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ac :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCacDadcdmtmp;try rewrite HT2 in HCacDadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ac :: ad :: cd :: nil) (cd :: nil) 3 1 2 HCacDadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HacadcdM2 : rk(ac :: ad :: cd :: nil) <= 2).
{
	assert(HAacadcdeq : rk(A :: ac :: ad :: cd :: nil) = 3) by (apply LAacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacadcdMtmp : rk(A :: ac :: ad :: cd :: nil) <= 3) by (solve_hyps_max HAacadcdeq HAacadcdM3).
	assert(HApacDpadcdeq : rk(Ap :: ac :: Dp :: ad :: cd :: nil) = 3) by (apply LApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDpadcdMtmp : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApacDpadcdeq HApacDpadcdM3).
	assert(HAApacDpadcdeq : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) = 4) by (apply LAApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApacDpadcdmtmp : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HAApacDpadcdeq HAApacDpadcdm4).
	assert(Hincl : incl (ac :: ad :: cd :: nil) (list_inter (A :: ac :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: ac :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: ac :: ad :: cd :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApacDpadcdmtmp;try rewrite HT2 in HAApacDpadcdmtmp.
	assert(HT := rule_3 (A :: ac :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: ad :: cd :: nil) 3 3 4 HAacadcdMtmp HApacDpadcdMtmp HAApacDpadcdmtmp Hincl);apply HT.
}


assert(HacadcdM : rk(ac :: ad :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hacadcdeq HacadcdM3).
assert(Hacadcdm : rk(ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Hacadcdeq Hacadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacadcd *)
(* dans la couche 0 *)
Lemma LOoABCApacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacadcd requis par la preuve de (?)OoABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacadcdeq HOoABCApacadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacadcdm2 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacadcdm4 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacadcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) = 4) by (apply LOoABCApacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacadcdeq HOoABCApacadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadcdmtmp;try rewrite HT2 in HOoABCApacadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacadcdM : rk(A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacadcdm : rk(A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacadcdeq HABCApacadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABabacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpabacbcadcd requis par la preuve de (?)OoABCCpabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpabacbcadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABApabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcadcdm2 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcadcdm3 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABabacbcadcdm2 : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabacbcadcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabacbcadcdeq HOoABApabacbcadcdm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabacbcadcdmtmp;try rewrite HT2 in HOoABApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApabacbcadcdmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABabacbcadcdm3 : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCCpabacbcadcdeq HOoABCCpabacbcadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpabacbcadcdmtmp;try rewrite HT2 in HOoABCCpabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCCpabacbcadcdmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabacbcadcdm4 : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabacbcadcdm2 : rk(A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabacbcadcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabacbcadcdeq HOoABApabacbcadcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabacbcadcdmtmp;try rewrite HT2 in HOoABApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApabacbcadcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabacbcadcdm3 : rk(A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABaceq : rk(A :: B :: ac :: nil) = 3) by (apply LABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABacmtmp : rk(A :: B :: ac :: nil) >= 3) by (solve_hyps_min HABaceq HABacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ac :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ac :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil) 3 3 HABacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: B :: ad :: cd ::  de rang :  4 et 4 	 A : Oo :: A :: B :: ad :: cd ::   de rang : 4 et 4 *)
assert(HABabacbcadcdm4 : rk(A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABadcdeq : rk(Oo :: A :: B :: ad :: cd :: nil) = 4) by (apply LOoABadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABadcdMtmp : rk(Oo :: A :: B :: ad :: cd :: nil) <= 4) by (solve_hyps_max HOoABadcdeq HOoABadcdM4).
	assert(HOoABabacbcadcdmtmp : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABabacbcadcdeq HOoABabacbcadcdm4).
	assert(HABadcdeq : rk(A :: B :: ad :: cd :: nil) = 4) by (apply LABadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadcdmtmp : rk(A :: B :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABadcdeq HABadcdm4).
	assert(Hincl : incl (A :: B :: ad :: cd :: nil) (list_inter (Oo :: A :: B :: ad :: cd :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: ad :: cd :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ad :: cd :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: ad :: cd :: nil) ++ (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabacbcadcdmtmp;try rewrite HT2 in HOoABabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: ad :: cd :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ad :: cd :: nil) 4 4 4 HOoABabacbcadcdmtmp HABadcdmtmp HOoABadcdMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcadcdmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApabacbcadcdeq HABCApabacbcadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcadcdmtmp;try rewrite HT2 in HABCApabacbcadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (nil) 4 0 2 HABCApabacbcadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadcdm2 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadcdmtmp;try rewrite HT2 in HACabacbcadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(Habacbcadcdm3 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabacbcadcdmtmp : rk(A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABabacbcadcdeq HABabacbcadcdm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabacbcadcdmtmp;try rewrite HT2 in HABabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ab :: nil) 4 1 2 HABabacbcadcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -2*)
assert(HabacbcadcdM3 : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3).
{
	assert(Habacbceq : rk(ab :: ac :: bc :: nil) = 2) by (apply Labacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabacbcMtmp : rk(ab :: ac :: bc :: nil) <= 2) by (solve_hyps_max Habacbceq HabacbcM2).
	assert(Hacadcdeq : rk(ac :: ad :: cd :: nil) = 2) by (apply Lacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HacadcdMtmp : rk(ac :: ad :: cd :: nil) <= 2) by (solve_hyps_max Hacadcdeq HacadcdM2).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ac :: bc :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ac :: bc :: ac :: ad :: cd :: nil) ((ab :: ac :: bc :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil) (ac :: nil) 2 2 1 HabacbcMtmp HacadcdMtmp Hacmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HabacbcadcdM : rk(ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadcdm : rk(ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadcdeq Habacbcadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABabacbcadcd *)
(* dans la couche 0 *)
Lemma LOoABabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpabacbcadcd requis par la preuve de (?)OoABCCpabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpabacbcadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABApabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcadcdm2 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcadcdm3 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABabacbcadcd requis par la preuve de (?)OoABabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABabacbcadcdm2 : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabacbcadcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabacbcadcdeq HOoABApabacbcadcdm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabacbcadcdmtmp;try rewrite HT2 in HOoABApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApabacbcadcdmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABabacbcadcdm3 : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCCpabacbcadcdeq HOoABCCpabacbcadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpabacbcadcdmtmp;try rewrite HT2 in HOoABCCpabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCCpabacbcadcdmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabacbcadcdm4 : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

assert(HOoABabacbcadcdM : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABabacbcadcdm : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABabacbcadcdeq HOoABabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABApabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabacbcadcd requis par la preuve de (?)OoABApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcadcdm2 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcadcdm3 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabacbcadcd requis par la preuve de (?)ABabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabacbcadcdm2 : rk(A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabacbcadcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabacbcadcdeq HOoABApabacbcadcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabacbcadcdmtmp;try rewrite HT2 in HOoABApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApabacbcadcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabacbcadcdm3 : rk(A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABaceq : rk(A :: B :: ac :: nil) = 3) by (apply LABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABacmtmp : rk(A :: B :: ac :: nil) >= 3) by (solve_hyps_min HABaceq HABacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ac :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ac :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil) 3 3 HABacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: B :: ad :: cd ::  de rang :  4 et 4 	 A : Oo :: A :: B :: ad :: cd ::   de rang : 4 et 4 *)
assert(HABabacbcadcdm4 : rk(A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABadcdeq : rk(Oo :: A :: B :: ad :: cd :: nil) = 4) by (apply LOoABadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABadcdMtmp : rk(Oo :: A :: B :: ad :: cd :: nil) <= 4) by (solve_hyps_max HOoABadcdeq HOoABadcdM4).
	assert(HOoABabacbcadcdeq : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LOoABabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABabacbcadcdmtmp : rk(Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABabacbcadcdeq HOoABabacbcadcdm4).
	assert(HABadcdeq : rk(A :: B :: ad :: cd :: nil) = 4) by (apply LABadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadcdmtmp : rk(A :: B :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABadcdeq HABadcdm4).
	assert(Hincl : incl (A :: B :: ad :: cd :: nil) (list_inter (Oo :: A :: B :: ad :: cd :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: B :: ad :: cd :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ad :: cd :: A :: B :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: B :: ad :: cd :: nil) ++ (A :: B :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabacbcadcdmtmp;try rewrite HT2 in HOoABabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: ad :: cd :: nil) (A :: B :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ad :: cd :: nil) 4 4 4 HOoABabacbcadcdmtmp HABadcdmtmp HOoABadcdMtmp Hincl); apply HT.
}

assert(HABabacbcadcdM : rk(A :: B :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabacbcadcdm : rk(A :: B :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABabacbcadcdeq HABabacbcadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbcadcd *)
(* dans la couche 0 *)
Lemma LOoABCApabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcadcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LOoABCApabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabacbcadcdM : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcadcdm : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabacbcadcdeq HABCApabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpabacbcadcd requis par la preuve de (?)OoABCCpabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpabacbcadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpabacbcadcdM : rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpabacbcadcdm : rk(Oo :: A :: B :: C :: Cp :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCCpabacbcadcdeq HOoABCCpabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour ACacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadcdmtmp;try rewrite HT2 in HABCApacDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApacDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CacDadcd requis par la preuve de (?)CacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCacDadcdm2 : rk(C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: nil) 2 2 2 HACacDadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  3 et 3 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCacDadcdm3 : rk(C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACacDadcdeq HACacDadcdm3).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ac :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ac :: D :: ad :: cd :: nil) (D :: ad :: nil) 3 2 2 HACacDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCacDadcdM3 : rk(C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HCacDadeq : rk(C :: ac :: D :: ad :: nil) = 3) by (apply LCacDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacDadMtmp : rk(C :: ac :: D :: ad :: nil) <= 3) by (solve_hyps_max HCacDadeq HCacDadM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ac :: D :: ad :: cd :: nil) (C :: ac :: D :: ad :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: D :: ad :: C :: D :: cd :: nil) ((C :: ac :: D :: ad :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: ac :: D :: ad :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCacDadMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HCacDadcdM : rk(C :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCacDadcdm : rk(C :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCacDadcdeq HCacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadcdmtmp;try rewrite HT2 in HABCApacDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApacDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDadcdm3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HACacDadcdM3 : rk(A :: C :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: C :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (A :: C :: ac :: D :: cd :: nil) (A :: D :: nil) 2 3 2 HADadMtmp HACacDcdMtmp HADmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACacDadcdM : rk(A :: C :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDadcdm : rk(A :: C :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACacDadcdeq HACacDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDadcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) = 4) by (apply LOoABCApacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDadcdM : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDadcdm : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDpadcdM : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDpadcdm : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDpadcdeq HABCApacDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpacDpadcd *)
(* dans la couche 0 *)
Lemma LACpacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpacDDpadcd requis par la preuve de (?)OoABCBpCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpacDDpadcdm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDDpadcd requis par la preuve de (?)OoABCApCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpacDDpadcd requis par la preuve de (?)OoACCpacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpacDDpadcdm2 : rk(Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDDpadcdeq HOoABCApCpacDDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApCpacDDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpacDDpadcdm3 : rk(Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCBpCpacDDpadcdeq HOoABCBpCpacDDpadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpacDDpadcdmtmp;try rewrite HT2 in HOoABCBpCpacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpacDDpadcdmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ABCApCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ABCApCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacDDpadcdm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacDDpadcdm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDDpadcdeq HOoABCApCpacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpacDDpadcd requis par la preuve de (?)ACCpacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACCpacDDpadcdm2 : rk(A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApCpacDDpadcdmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApCpacDDpadcdeq HABCApCpacDDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacDDpadcdmtmp;try rewrite HT2 in HABCApCpacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HABCApCpacDDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HACCpacDDpadcdm3 : rk(A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoACCpacDDpadcdmtmp : rk(Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoACCpacDDpadcdeq HOoACCpacDDpadcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: C :: Cp :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpacDDpadcdmtmp;try rewrite HT2 in HOoACCpacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoACCpacDDpadcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpacDDpadcd requis par la preuve de (?)ACpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpacDDpadcdm2 : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HACpacDDpadcdm3 : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACCpacDDpadcdmtmp : rk(A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACCpacDDpadcdeq HACCpacDDpadcdm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpacDDpadcdmtmp;try rewrite HT2 in HACCpacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: ac :: nil) 3 2 2 HACCpacDDpadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpacDDpadcdm4 : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HACpDDpeq : rk(A :: Cp :: D :: Dp :: nil) = 4) by (apply LACpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpmtmp : rk(A :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HACpDDpeq HACpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: Dp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: Dp :: nil) (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HACpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HACpacDDpadcdM : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpacDDpadcdm : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACpacDDpadcdeq HACpacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACCpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpacDpadcd requis par la preuve de (?)OoABCBpCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpacDpadcdm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpadcd requis par la preuve de (?)OoABCApCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpacDpadcd requis par la preuve de (?)OoACCpacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpacDpadcdm2 : rk(Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpadcdeq HOoABCApCpacDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApCpacDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpacDpadcdm3 : rk(Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpacDpadcdmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCBpCpacDpadcdeq HOoABCBpCpacDpadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpacDpadcdmtmp;try rewrite HT2 in HOoABCBpCpacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpacDpadcdmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ABCApCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ABCApCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacDpadcdm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacDpadcdm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpadcdeq HOoABCApCpacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACCpacDpadcd requis par la preuve de (?)ACCpacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACCpacDpadcdm2 : rk(A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApCpacDpadcdmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApCpacDpadcdeq HABCApCpacDpadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacDpadcdmtmp;try rewrite HT2 in HABCApCpacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (nil) 4 0 2 HABCApCpacDpadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HACCpacDpadcdm3 : rk(A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoACCpacDpadcdmtmp : rk(Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoACCpacDpadcdeq HOoACCpacDpadcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: C :: Cp :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpacDpadcdmtmp;try rewrite HT2 in HOoACCpacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoACCpacDpadcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpacDpadcd requis par la preuve de (?)ACpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpacDpadcdm2 : rk(A :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HACpacDpadcdm3 : rk(A :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACCpacDpadcdmtmp : rk(A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACCpacDpadcdeq HACCpacDpadcdm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: A :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: Cp :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACCpacDpadcdmtmp;try rewrite HT2 in HACCpacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: ac :: nil) 3 2 2 HACCpacDpadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HACpacDpadcdm4 : rk(A :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACpacDDpadcdeq : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LACpacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpacDDpadcdmtmp : rk(A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACpacDDpadcdeq HACpacDDpadcdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: D :: ad :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: D :: ad :: A :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: Cp :: ac :: Dp :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpacDDpadcdmtmp;try rewrite HT2 in HACpacDDpadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: ad :: nil) 4 2 2 HACpacDDpadcdmtmp HAadmtmp HADadMtmp Hincl); apply HT.
}

assert(HACpacDpadcdM : rk(A :: Cp :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpacDpadcdm : rk(A :: Cp :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACpacDpadcdeq HACpacDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApCpacDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApCpacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDpadcd requis par la preuve de (?)OoABCApCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacDpadcdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacDpadcdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacDpadcdeq HOoABCApCpacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ABCApCpacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacDpadcd requis par la preuve de (?)ABCApCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacDpadcdm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacDpadcdm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApCpacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDpadcdeq HOoABCApCpacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpacDpadcdM : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpacDpadcdm : rk(A :: B :: C :: Ap :: Cp :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApCpacDpadcdeq HABCApCpacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpacDpadcd requis par la preuve de (?)OoABCBpCpacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpacDpadcdm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpacDpadcdM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpacDpadcdm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpacDpadcdeq HOoABCBpCpacDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApDDpadcd requis par la preuve de (?)ABCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDDpadcd requis par la preuve de (?)ABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDDpadcdm2 : rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDDpadcdm4 : rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApDDpadcdM : rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDDpadcdm : rk(A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApDDpadcdeq HABCApDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApacDDpadcd *)
(* dans constructLemma(), requis par LACApacDDpadcd *)
(* dans la couche 0 *)
Lemma LOoACApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApacDDpadcd requis par la preuve de (?)OoACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm2 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApacDDpadcdm3 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApacDDpadcdm4 : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApacDDpadcdM : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApacDDpadcdm : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDDpadcdeq HABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDDpadcdmtmp;try rewrite HT2 in HABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: D ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: D ::   de rang : 3 et 3 *)
assert(HACApacDDpadcdm4 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApDeq : rk(Oo :: A :: Ap :: D :: nil) = 3) by (apply LOoAApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDMtmp : rk(Oo :: A :: Ap :: D :: nil) <= 3) by (solve_hyps_max HOoAApDeq HOoAApDM3).
	assert(HOoACApacDDpadcdeq : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApacDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApacDDpadcdeq HOoACApacDDpadcdm4).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hincl : incl (A :: Ap :: D :: nil) (list_inter (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: D :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: D :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApacDDpadcdmtmp;try rewrite HT2 in HOoACApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: D :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: D :: nil) 4 3 3 HOoACApacDDpadcdmtmp HAApDmtmp HOoAApDMtmp Hincl); apply HT.
}

assert(HACApacDDpadcdM : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacDDpadcdm : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDDpadcd requis par la preuve de (?)ACApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDDpadcdm2 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDDpadcdm3 : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDDpadcdeq HABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDDpadcdmtmp;try rewrite HT2 in HABCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApacDDpadcd requis par la preuve de (?)BCApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApacDDpadcdm3 : rk(B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApacDDpadcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApacDDpadcd requis par la preuve de (?)CApacDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm2 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApacDDpadcdmtmp : rk(B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HBCApacDDpadcdeq HBCApacDDpadcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApacDDpadcdmtmp;try rewrite HT2 in HBCApacDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 3 1 2 HBCApacDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCApacDDpadcdm3 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (C :: ac :: nil) 3 2 2 HACApacDDpadcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: D :: Dp ::  de rang :  3 et 3 	 A : A :: Ap :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCApacDDpadcdm4 : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HAApDDpeq : rk(A :: Ap :: D :: Dp :: nil) = 3) by (apply LAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDDpMtmp : rk(A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HAApDDpeq HAApDDpM3).
	assert(HACApacDDpadcdeq : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LACApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApacDDpadcdmtmp : rk(A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACApacDDpadcdeq HACApacDDpadcdm4).
	assert(HApDDpmtmp : rk(Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HApDDpeq HApDDpm3).
	assert(Hincl : incl (Ap :: D :: Dp :: nil) (list_inter (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: D :: Dp :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: D :: Dp :: nil) ++ (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDDpadcdmtmp;try rewrite HT2 in HACApacDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: D :: Dp :: nil) (C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Ap :: D :: Dp :: nil) 4 3 3 HACApacDDpadcdmtmp HApDDpmtmp HAApDDpMtmp Hincl); apply HT.
}

assert(HCApacDDpadcdM : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApacDDpadcdm : rk(C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCApacDDpadcdeq HCApacDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDpadcd requis par la preuve de (?)OoABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDDpadcd requis par la preuve de (?)ABCApacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpadcdeq HOoABCApacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpadcdmtmp;try rewrite HT2 in HOoABCApacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDDpadcdM : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDDpadcdm : rk(A :: B :: C :: Ap :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDDpadcdeq HABCApacDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApCpacDDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApCpacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacDDpadcd requis par la preuve de (?)OoABCApCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacDDpadcdeq HOoABCApCpacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ABCApCpacDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacDDpadcd requis par la preuve de (?)ABCApCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacDDpadcdm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacDDpadcdm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApCpacDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpacDDpadcdeq HOoABCApCpacDDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacDDpadcdmtmp;try rewrite HT2 in HOoABCApCpacDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacDDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpacDDpadcdM : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpacDDpadcdm : rk(A :: B :: C :: Ap :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApCpacDDpadcdeq HABCApCpacDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpacDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpacDDpadcd requis par la preuve de (?)OoABCBpCpacDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpacDDpadcdm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpacDDpadcdM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpacDDpadcdm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ac :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpacDDpadcdeq HOoABCBpCpacDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBbcbdcd *)
(* dans constructLemma(), requis par LBbcDbdcd *)
(* dans la couche 0 *)
Lemma LBDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm2 : rk(B :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: bd :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBDbdcdM3 : rk(B :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: D :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: D :: bd :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBDbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm3 : rk(B :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

assert(HBDbdcdM : rk(B :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBDbdcdm : rk(B :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBDbdcdeq HBDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDbdcdm2 : rk(B :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDbdcdm3 : rk(B :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBbcDbdcdM3 : rk(B :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBbcDcdeq : rk(B :: bc :: D :: cd :: nil) = 3) by (apply LBbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcDcdMtmp : rk(B :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBbcDcdeq HBbcDcdM3).
	assert(HBDbdcdeq : rk(B :: D :: bd :: cd :: nil) = 3) by (apply LBDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDbdcdMtmp : rk(B :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBDbdcdeq HBDbdcdM3).
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hincl : incl (B :: D :: cd :: nil) (list_inter (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil) ((B :: bc :: D :: cd :: nil) ++ (B :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) (B :: D :: cd :: nil) 3 3 3 HBbcDcdMtmp HBDbdcdMtmp HBDcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBbcDbdcdM : rk(B :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDbdcdm : rk(B :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDbdcdeq HBbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Bbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCpbcDpbdcd requis par la preuve de (?)Bbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCpbcDDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpbcDDpbdcd requis par la preuve de (?)BCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpbcDDpbdcd requis par la preuve de (?)OoBCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbcDDpbdcd requis par la preuve de (?)OoABCApCpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpbcDDpbdcd requis par la preuve de (?)OoBCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpbcDDpbdcd requis par la preuve de (?)OoBCCpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDDpbdcdm2 : rk(Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDDpbdcdeq HOoABCApCpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDDpbdcdm3 : rk(Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDDpbdcdeq HOoABCApCpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApCpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCCpbcDDpbdcd requis par la preuve de (?)BCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCCpbcDDpbdcd requis par la preuve de (?)BCCpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCCpbcDDpbdcdm2 : rk(B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDDpbdcdeq HOoABCApCpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCCpbcDDpbdcdm3 : rk(B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoBCCpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCCpbcDDpbdcdeq HOoBCCpbcDDpbdcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: C :: Cp :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCCpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoBCCpbcDDpbdcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpbcDDpbdcdm2 : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) 2 2 HBCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBCpbcDDpbdcdm3 : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCCpbcDDpbdcdmtmp : rk(B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCCpbcDDpbdcdeq HBCCpbcDDpbdcdm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCCpbcDDpbdcdmtmp;try rewrite HT2 in HBCCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: bc :: nil) 3 2 2 HBCCpbcDDpbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpbcDDpbdcdm4 : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBCpDDpeq : rk(B :: Cp :: D :: Dp :: nil) = 4) by (apply LBCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpDDpmtmp : rk(B :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HBCpDDpeq HBCpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: D :: Dp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: D :: Dp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HBCpDDpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpbcDpbdcd requis par la preuve de (?)BCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpbcDpbdcd requis par la preuve de (?)OoBCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbcDpbdcd requis par la preuve de (?)OoABCApCpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpbcDpbdcd requis par la preuve de (?)OoBCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpbcDpbdcd requis par la preuve de (?)OoBCCpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDpbdcdm2 : rk(Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDpbdcdeq HOoABCApCpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDpbdcdm3 : rk(Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDpbdcdeq HOoABCApCpbcDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApCpbcDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCCpbcDpbdcd requis par la preuve de (?)BCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCCpbcDpbdcd requis par la preuve de (?)BCCpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCCpbcDpbdcdm2 : rk(B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDpbdcdeq HOoABCApCpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCCpbcDpbdcdm3 : rk(B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoBCCpbcDpbdcdmtmp : rk(Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCCpbcDpbdcdeq HOoBCCpbcDpbdcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: C :: Cp :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCCpbcDpbdcdmtmp;try rewrite HT2 in HOoBCCpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoBCCpbcDpbdcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpbcDpbdcdm2 : rk(B :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil) 2 2 HBCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBCpbcDpbdcdm3 : rk(B :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCCpbcDpbdcdmtmp : rk(B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCCpbcDpbdcdeq HBCCpbcDpbdcdm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (B :: C :: bc :: B :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: Cp :: bc :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCCpbcDpbdcdmtmp;try rewrite HT2 in HBCCpbcDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil) (B :: bc :: nil) 3 2 2 HBCCpbcDpbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HBCpbcDpbdcdm4 : rk(B :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCpbcDDpbdcdmtmp : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCpbcDDpbdcdeq HBCpbcDDpbdcdm4).
	assert(HBbdeq : rk(B :: bd :: nil) = 2) by (apply LBbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbdmtmp : rk(B :: bd :: nil) >= 2) by (solve_hyps_min HBbdeq HBbdm2).
	assert(Hincl : incl (B :: bd :: nil) (list_inter (B :: D :: bd :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: D :: bd :: B :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: Cp :: bc :: Dp :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCpbcDDpbdcdmtmp;try rewrite HT2 in HBCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil) (B :: bd :: nil) 4 2 2 HBCpbcDDpbdcdmtmp HBbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Bbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)OoABCApbcbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcbdcdm2 : rk(B :: C :: bc :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcbdcdeq HOoABCApbcbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcbdcdmtmp;try rewrite HT2 in HOoABCApbcbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Bbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcbdcdm2 : rk(B :: bc :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcbdcdmtmp : rk(B :: C :: bc :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcbdcdeq HBCbcbdcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcbdcdmtmp;try rewrite HT2 in HBCbcbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : Cp :: Dp :: cd ::   de rang : 2 et 2 *)
assert(HBbcbdcdm3 : rk(B :: bc :: bd :: cd :: nil) >= 3).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HBCpbcDpbdcdmtmp : rk(B :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCpbcDpbdcdeq HBCpbcDpbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (Cp :: Dp :: cd :: nil) (B :: bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: bc :: Dp :: bd :: cd :: nil) (Cp :: Dp :: cd :: B :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Dp :: cd :: B :: bc :: bd :: cd :: nil) ((Cp :: Dp :: cd :: nil) ++ (B :: bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCpbcDpbdcdmtmp;try rewrite HT2 in HBCpbcDpbdcdmtmp.
	assert(HT := rule_4 (Cp :: Dp :: cd :: nil) (B :: bc :: bd :: cd :: nil) (cd :: nil) 4 1 2 HBCpbcDpbdcdmtmp Hcdmtmp HCpDpcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcbdcdM3 : rk(B :: bc :: bd :: cd :: nil) <= 3).
{
	assert(HBbcDbdcdeq : rk(B :: bc :: D :: bd :: cd :: nil) = 3) by (apply LBbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcDbdcdMtmp : rk(B :: bc :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBbcDbdcdeq HBbcDbdcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: bc :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: bc :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBbcDbdcdMtmp Hcomp Hincl);apply HT.
}

assert(HBbcbdcdM : rk(B :: bc :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcbdcdm : rk(B :: bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBbcbdcdeq HBbcbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBpbcDpbdcd *)
(* dans constructLemma(), requis par LBpDpbdcd *)
(* dans constructLemma(), requis par LCBpDDpbdcd *)
(* dans constructLemma(), requis par LBCBpDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoBCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm2 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpDDpbdcdM : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpDDpbdcdm : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpDDpbdcd requis par la preuve de (?)BCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)BCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm2 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpDDpbdcd requis par la preuve de (?)BCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpDDpbdcd requis par la preuve de (?)BCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpDDpbdcdm2 : rk(B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpDDpbdcdm3 : rk(B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: Bp :: D ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HBCBpDDpbdcdm4 : rk(B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpDDpbdcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm4).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hincl : incl (B :: Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: D :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: D :: nil) 4 3 3 HOoBCBpDDpbdcdmtmp HBBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

assert(HBCBpDDpbdcdM : rk(B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpDDpbdcdm : rk(B :: C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCBpDDpbdcdeq HBCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpDDpbdcd requis par la preuve de (?)OoBCBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm2 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpDDpbdcd requis par la preuve de (?)CBpDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpDDpbdcdm2 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D ::  de rang :  2 et 2 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HCBpDDpbdcdm3 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpDDpbdcdeq : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpDDpbdcdeq HOoBCBpDDpbdcdm4).
	assert(HBpDeq : rk(Bp :: D :: nil) = 2) by (apply LBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDmtmp : rk(Bp :: D :: nil) >= 2) by (solve_hyps_min HBpDeq HBpDm2).
	assert(Hincl : incl (Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: D :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpDDpbdcdmtmp;try rewrite HT2 in HOoBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (Bp :: D :: nil) 4 2 3 HOoBCBpDDpbdcdmtmp HBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D :: Dp ::  de rang :  3 et 3 	 A : B :: Bp :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCBpDDpbdcdm4 : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBBpDDpeq : rk(B :: Bp :: D :: Dp :: nil) = 3) by (apply LBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDDpMtmp : rk(B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HBBpDDpeq HBBpDDpM3).
	assert(HBCBpDDpbdcdeq : rk(B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LBCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCBpDDpbdcdmtmp : rk(B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCBpDDpbdcdeq HBCBpDDpbdcdm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (B :: Bp :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: D :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: D :: Dp :: C :: Bp :: D :: Dp :: bd :: cd :: nil) ((B :: Bp :: D :: Dp :: nil) ++ (C :: Bp :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpDDpbdcdmtmp;try rewrite HT2 in HBCBpDDpbdcdmtmp.
	assert(HT := rule_4 (B :: Bp :: D :: Dp :: nil) (C :: Bp :: D :: Dp :: bd :: cd :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HBCBpDDpbdcdmtmp HBpDDpmtmp HBBpDDpMtmp Hincl); apply HT.
}

assert(HCBpDDpbdcdM : rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpDDpbdcdm : rk(C :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCBpDDpbdcdeq HCBpDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpDpbdcd requis par la preuve de (?)BpDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDpbdcdm2 : rk(Bp :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: Dp :: nil) (Bp :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: Dp :: nil) (Bp :: Dp :: bd :: cd :: nil) 2 2 HBpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBpDpbdcdM3 : rk(Bp :: Dp :: bd :: cd :: nil) <= 3).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: Dp :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: Dp :: bd :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Dp :: bd :: cd :: nil) ((Bp :: Dp :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: Dp :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBpDpbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpDpbdcdm3 : rk(Bp :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpDDpbdcdeq : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LCBpDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpDDpbdcdmtmp : rk(C :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpDDpbdcdeq HCBpDDpbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpDDpbdcdmtmp;try rewrite HT2 in HCBpDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCBpDDpbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HBpDpbdcdM : rk(Bp :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpDpbdcdm : rk(Bp :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpDpbdcdeq HBpDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: bc :: Dp :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: Bp :: D ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HBCBpbcDDpbdcdm4 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm4).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hincl : incl (B :: Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: D :: nil) 4 3 3 HOoBCBpbcDDpbdcdmtmp HBBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm2 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm3 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D :: Dp ::  de rang :  3 et 3 	 A : B :: Bp :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCBpbcDDpbdcdm4 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBBpDDpeq : rk(B :: Bp :: D :: Dp :: nil) = 3) by (apply LBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDDpMtmp : rk(B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HBBpDDpeq HBBpDDpM3).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: Bp :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HBCBpbcDDpbdcdmtmp HBpDDpmtmp HBBpDDpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoABCApBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpbdcdm2 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm2 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm3 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDpbdcdeq HOoBCBpbcDpbdcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpbcDpbdcd requis par la preuve de (?)BpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBpbcDpbdcdm2 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDpbdcdmtmp : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDpbdcdeq HBCBpbcDpbdcdm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: C :: bc :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Bp :: bc :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDpbdcdmtmp;try rewrite HT2 in HBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (bc :: nil) 3 1 2 HBCBpbcDpbdcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HBpbcDpbdcdm3 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCBpbcDDpbdcdmtmp : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: D :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpbcDDpbdcdmtmp;try rewrite HT2 in HCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCBpbcDDpbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBpbcDpbdcdM3 : rk(Bp :: bc :: Dp :: bd :: cd :: nil) <= 3).
{
	assert(HBpbcDpcdeq : rk(Bp :: bc :: Dp :: cd :: nil) = 3) by (apply LBpbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpbcDpcdMtmp : rk(Bp :: bc :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HBpbcDpcdeq HBpbcDpcdM3).
	assert(HBpDpbdcdeq : rk(Bp :: Dp :: bd :: cd :: nil) = 3) by (apply LBpDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpbdcdMtmp : rk(Bp :: Dp :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBpDpbdcdeq HBpDpbdcdM3).
	assert(HBpDpcdeq : rk(Bp :: Dp :: cd :: nil) = 3) by (apply LBpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpcdmtmp : rk(Bp :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBpDpcdeq HBpDpcdm3).
	assert(Hincl : incl (Bp :: Dp :: cd :: nil) (list_inter (Bp :: bc :: Dp :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: bc :: Dp :: bd :: cd :: nil) (Bp :: bc :: Dp :: cd :: Bp :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: bc :: Dp :: cd :: Bp :: Dp :: bd :: cd :: nil) ((Bp :: bc :: Dp :: cd :: nil) ++ (Bp :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: bc :: Dp :: cd :: nil) (Bp :: Dp :: bd :: cd :: nil) (Bp :: Dp :: cd :: nil) 3 3 3 HBpbcDpcdMtmp HBpDpbdcdMtmp HBpDpcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBpbcDpbdcdM : rk(Bp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpbcDpbdcdm : rk(Bp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBpbcDpbdcdeq HBpbcDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans la couche 0 *)
Lemma LBBpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: bc :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BBpbcDpbdcd requis par la preuve de (?)BBpbcDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoABCApBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDpbdcd requis par la preuve de (?)OoBCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpbdcdm2 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDpbdcd requis par la preuve de (?)BCBpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm2 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDpbdcdm3 : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDpbdcdeq HOoBCBpbcDpbdcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BBpbcDpbdcd requis par la preuve de (?)BBpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpbcDpbdcd requis par la preuve de (?)BBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpbcDpbdcdm2 : rk(B :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: bc :: Dp :: bd :: cd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBBpbcDpbdcdm3 : rk(B :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDpbdcdmtmp : rk(B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDpbdcdeq HBCBpbcDpbdcdm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: C :: bc :: B :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: Bp :: bc :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDpbdcdmtmp;try rewrite HT2 in HBCBpbcDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: bc :: nil) 3 2 2 HBCBpbcDpbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBBpbcDpbdcdm4 : rk(B :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBBpDpcdeq : rk(B :: Bp :: Dp :: cd :: nil) = 4) by (apply LBBpDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDpcdmtmp : rk(B :: Bp :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HBBpDpcdeq HBBpDpcdm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Dp :: cd :: nil) (B :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Dp :: cd :: nil) (B :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HBBpDpcdmtmp Hcomp Hincl);apply HT.
}

assert(HBBpbcDpbdcdM : rk(B :: Bp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpbcDpbdcdm : rk(B :: Bp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBBpbcDpbdcdeq HBBpbcDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bc :: bd :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CbcDbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Hbcbdcdm2 : rk(bc :: bd :: cd :: nil) >= 2).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCbcDbdcdmtmp : rk(C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: D :: cd :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: bc :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCbcDbdcdmtmp;try rewrite HT2 in HCbcDbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (bc :: bd :: cd :: nil) (cd :: nil) 3 1 2 HCbcDbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HbcbdcdM2 : rk(bc :: bd :: cd :: nil) <= 2).
{
	assert(HBbcbdcdeq : rk(B :: bc :: bd :: cd :: nil) = 3) by (apply LBbcbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcbdcdMtmp : rk(B :: bc :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBbcbdcdeq HBbcbdcdM3).
	assert(HBpbcDpbdcdeq : rk(Bp :: bc :: Dp :: bd :: cd :: nil) = 3) by (apply LBpbcDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpbcDpbdcdMtmp : rk(Bp :: bc :: Dp :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBpbcDpbdcdeq HBpbcDpbdcdM3).
	assert(HBBpbcDpbdcdeq : rk(B :: Bp :: bc :: Dp :: bd :: cd :: nil) = 4) by (apply LBBpbcDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpbcDpbdcdmtmp : rk(B :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBBpbcDpbdcdeq HBBpbcDpbdcdm4).
	assert(Hincl : incl (bc :: bd :: cd :: nil) (list_inter (B :: bc :: bd :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: bc :: Dp :: bd :: cd :: nil) (B :: bc :: bd :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: bd :: cd :: Bp :: bc :: Dp :: bd :: cd :: nil) ((B :: bc :: bd :: cd :: nil) ++ (Bp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpbcDpbdcdmtmp;try rewrite HT2 in HBBpbcDpbdcdmtmp.
	assert(HT := rule_3 (B :: bc :: bd :: cd :: nil) (Bp :: bc :: Dp :: bd :: cd :: nil) (bc :: bd :: cd :: nil) 3 3 4 HBbcbdcdMtmp HBpbcDpbdcdMtmp HBBpbcDpbdcdmtmp Hincl);apply HT.
}


assert(HbcbdcdM : rk(bc :: bd :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hbcbdcdeq HbcbdcdM3).
assert(Hbcbdcdm : rk(bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Hbcbdcdeq Hbcbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)OoABCApbcbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcbdcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcbdcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcbdcdeq HOoABCApbcbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HCbcDbdcdM : rk(C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdcdm : rk(C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBCbcDbdcdM : rk(B :: C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdcdm : rk(B :: C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDbdcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDpbdcd requis par la preuve de (?)OoABCApBpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDpbdcdeq HOoABCApBpbcDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCpbcDpbdcd *)
(* dans la couche 0 *)
Lemma LBCpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Cp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpbcDDpbdcd requis par la preuve de (?)BCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpbcDDpbdcd requis par la preuve de (?)OoBCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbcDDpbdcd requis par la preuve de (?)OoABCApCpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpbcDDpbdcd requis par la preuve de (?)OoBCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpbcDDpbdcd requis par la preuve de (?)OoBCCpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDDpbdcdm2 : rk(Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDDpbdcdeq HOoABCApCpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDDpbdcdm3 : rk(Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDDpbdcdeq HOoABCApCpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApCpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCCpbcDDpbdcd requis par la preuve de (?)BCCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCCpbcDDpbdcd requis par la preuve de (?)BCCpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCCpbcDDpbdcdm2 : rk(B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDDpbdcdeq HOoABCApCpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCCpbcDDpbdcdm3 : rk(B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoBCCpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCCpbcDDpbdcdeq HOoBCCpbcDDpbdcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: C :: Cp :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCCpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoBCCpbcDDpbdcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpbcDDpbdcd requis par la preuve de (?)BCpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpbcDDpbdcdm2 : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) 2 2 HBCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBCpbcDDpbdcdm3 : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCCpbcDDpbdcdmtmp : rk(B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCCpbcDDpbdcdeq HBCCpbcDDpbdcdm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCCpbcDDpbdcdmtmp;try rewrite HT2 in HBCCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: bc :: nil) 3 2 2 HBCCpbcDDpbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpbcDDpbdcdm4 : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBCpDDpeq : rk(B :: Cp :: D :: Dp :: nil) = 4) by (apply LBCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpDDpmtmp : rk(B :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HBCpDDpeq HBCpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: D :: Dp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: D :: Dp :: nil) (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HBCpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HBCpbcDDpbdcdM : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpbcDDpbdcdm : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCpbcDDpbdcdeq HBCpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Cp :: bc :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpbcDpbdcd requis par la preuve de (?)BCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpbcDpbdcd requis par la preuve de (?)OoBCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbcDpbdcd requis par la preuve de (?)OoABCApCpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpbcDpbdcd requis par la preuve de (?)OoBCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpbcDpbdcd requis par la preuve de (?)OoBCCpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDpbdcdm2 : rk(Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDpbdcdeq HOoABCApCpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpbcDpbdcdm3 : rk(Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDpbdcdeq HOoABCApCpbcDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApCpbcDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCCpbcDpbdcd requis par la preuve de (?)BCCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCCpbcDpbdcd requis par la preuve de (?)BCCpbcDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCCpbcDpbdcdm2 : rk(B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbcDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApCpbcDpbdcdeq HOoABCApCpbcDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcDpbdcdmtmp;try rewrite HT2 in HOoABCApCpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApCpbcDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HBCCpbcDpbdcdm3 : rk(B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoBCCpbcDpbdcdmtmp : rk(Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCCpbcDpbdcdeq HOoBCCpbcDpbdcdm3).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (Oo :: C :: Cp :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCCpbcDpbdcdmtmp;try rewrite HT2 in HOoBCCpbcDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (C :: Cp :: nil) 3 2 2 HOoBCCpbcDpbdcdmtmp HCCpmtmp HOoCCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCpbcDpbdcd requis par la preuve de (?)BCpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCpbcDpbdcdm2 : rk(B :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HBCpeq : rk(B :: Cp :: nil) = 2) by (apply LBCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpmtmp : rk(B :: Cp :: nil) >= 2) by (solve_hyps_min HBCpeq HBCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Cp :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Cp :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil) 2 2 HBCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Cp :: bc :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBCpbcDpbdcdm3 : rk(B :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCCpbcDpbdcdmtmp : rk(B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCCpbcDpbdcdeq HBCCpbcDpbdcdm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Cp :: bc :: Dp :: bd :: cd :: nil) (B :: C :: bc :: B :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: Cp :: bc :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCCpbcDpbdcdmtmp;try rewrite HT2 in HBCCpbcDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil) (B :: bc :: nil) 3 2 2 HBCCpbcDpbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: Cp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HBCpbcDpbdcdm4 : rk(B :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCpbcDDpbdcdeq : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LBCpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCpbcDDpbdcdmtmp : rk(B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCpbcDDpbdcdeq HBCpbcDDpbdcdm4).
	assert(HBbdeq : rk(B :: bd :: nil) = 2) by (apply LBbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbdmtmp : rk(B :: bd :: nil) >= 2) by (solve_hyps_min HBbdeq HBbdm2).
	assert(Hincl : incl (B :: bd :: nil) (list_inter (B :: D :: bd :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: D :: bd :: B :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: Cp :: bc :: Dp :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: Cp :: bc :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCpbcDDpbdcdmtmp;try rewrite HT2 in HBCpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (B :: Cp :: bc :: Dp :: bd :: cd :: nil) (B :: bd :: nil) 4 2 2 HBCpbcDDpbdcdmtmp HBbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HBCpbcDpbdcdM : rk(B :: Cp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCpbcDpbdcdm : rk(B :: Cp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCpbcDpbdcdeq HBCpbcDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpbcDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbcDpbdcd requis par la preuve de (?)OoABCApCpbcDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpbcDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpbcDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpbcDpbdcdeq HOoABCApCpbcDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDpbdcd requis par la preuve de (?)OoABCApBpDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpbdcdeq HOoABCApBpDDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCBpbcDDpbdcd *)
(* dans constructLemma(), requis par LBCBpbcDDpbdcd *)
(* dans la couche 0 *)
Lemma LOoBCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBCBpbcDDpbdcdm4 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDmtmp : rk(Oo :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HOoBCDeq HOoBCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: C :: D :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoBCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBCBpbcDDpbdcdM : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpbcDDpbdcdm : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: Bp :: D ::  de rang :  3 et 3 	 A : Oo :: B :: Bp :: D ::   de rang : 3 et 3 *)
assert(HBCBpbcDDpbdcdm4 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBCBpbcDDpbdcdeq : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LOoBCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm4).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(Hincl : incl (B :: Bp :: D :: nil) (list_inter (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: D :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: D :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: D :: nil) 4 3 3 HOoBCBpbcDDpbdcdmtmp HBBpDmtmp HOoBBpDMtmp Hincl); apply HT.
}

assert(HBCBpbcDDpbdcdM : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCBpbcDDpbdcdm : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpbcDDpbdcd requis par la preuve de (?)OoBCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm2 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpbcDDpbdcdm3 : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApBpbcDDpbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCBpbcDDpbdcd requis par la preuve de (?)BCBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm2 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpbcDDpbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcDDpbdcdmtmp;try rewrite HT2 in HOoABCApBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApBpbcDDpbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: Bp ::  de rang :  2 et 2 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HBCBpbcDDpbdcdm3 : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hincl : incl (B :: Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: nil) 3 2 2 HOoBCBpbcDDpbdcdmtmp HBBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpbcDDpbdcd requis par la preuve de (?)CBpbcDDpbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm2 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpbcDDpbdcdmtmp : rk(Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoBCBpbcDDpbdcdeq HOoBCBpbcDDpbdcdm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpbcDDpbdcdmtmp;try rewrite HT2 in HOoBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: nil) 3 1 2 HOoBCBpbcDDpbdcdmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCBpbcDDpbdcdm3 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCBpbcDDpbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : B :: C :: Bp :: bc :: D :: Dp :: bd :: cd ::  de rang :  4 et 4 	 AiB : Bp :: D :: Dp ::  de rang :  3 et 3 	 A : B :: Bp :: D :: Dp ::   de rang : 3 et 3 *)
assert(HCBpbcDDpbdcdm4 : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HBBpDDpeq : rk(B :: Bp :: D :: Dp :: nil) = 3) by (apply LBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDDpMtmp : rk(B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HBBpDDpeq HBBpDDpM3).
	assert(HBCBpbcDDpbdcdeq : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) = 4) by (apply LBCBpbcDDpbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCBpbcDDpbdcdmtmp : rk(B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCBpbcDDpbdcdeq HBCBpbcDDpbdcdm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: D :: Dp :: C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) ((B :: Bp :: D :: Dp :: nil) ++ (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpbcDDpbdcdmtmp;try rewrite HT2 in HBCBpbcDDpbdcdmtmp.
	assert(HT := rule_4 (B :: Bp :: D :: Dp :: nil) (C :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HBCBpbcDDpbdcdmtmp HBpDDpmtmp HBBpDDpMtmp Hincl); apply HT.
}

assert(HCBpbcDDpbdcdM : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpbcDDpbdcdm : rk(C :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCBpbcDDpbdcdeq HCBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbcDDpbdcd requis par la preuve de (?)OoABCApBpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcDDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcDDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbcDDpbdcdeq HOoABCApBpbcDDpbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpbcDDpbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbcDDpbdcd requis par la preuve de (?)OoABCApCpbcDDpbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcDDpbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpbcDDpbdcdM : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpbcDDpbdcdm : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: D :: Dp :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApCpbcDDpbdcdeq HOoABCApCpbcDDpbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbcadbdcd *)
(* dans la couche 0 *)
Lemma LOoABCApabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)OoABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadbdcd requis par la preuve de (?)ABCApabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadbdcd requis par la preuve de (?)ABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabacbcadbdcdM : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcadbdcdm : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabacbcadbdcdeq HABCApabacbcadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCabacbcDadbdcd *)
(* dans constructLemma(), requis par LBCabacbcDadbdcd *)
(* dans la couche 0 *)
Lemma LABCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCabacbcDadbdcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: D :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HABCDmtmp Hcomp Hincl);apply HT.
}

assert(HABCabacbcDadbdcdM : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabacbcDadbdcdm : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabacbcDadbdcd requis par la preuve de (?)BCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm2 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabacbcDadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm3 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HBCabacbcDadbdcdm4 : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABCabacbcDadbdcdeq : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LABCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HABCabacbcDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

assert(HBCabacbcDadbdcdM : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCabacbcDadbdcdm : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCabacbcDadbdcdeq HBCabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcDadbdcd requis par la preuve de (?)ABCabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcDadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcDadbdcd requis par la preuve de (?)ABCApabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcDadbdcd requis par la preuve de (?)ABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcDadbdcd requis par la preuve de (?)ACabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcDadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcDadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabacbcDadbdcdeq HABCApabacbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcDadbdcdmtmp;try rewrite HT2 in HABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabacbcDadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcDadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabacbcDadbdcd requis par la preuve de (?)CabacbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm2 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcDadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcDadbdcdeq HABCabacbcDadbdcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcDadbdcdmtmp;try rewrite HT2 in HABCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabacbcDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm3 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcDadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcDadbdcdeq HACabacbcDadbdcdm3).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcDadbdcdmtmp;try rewrite HT2 in HACabacbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (C :: ac :: nil) 3 2 2 HACabacbcDadbdcdmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCabacbcDadbdcdm4 : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCabacbcDadbdcdeq : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LBCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCabacbcDadbdcdmtmp : rk(B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBCabacbcDadbdcdeq HBCabacbcDadbdcdm4).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabacbcDadbdcdmtmp;try rewrite HT2 in HBCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (D :: bd :: nil) 4 2 2 HBCabacbcDadbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HCabacbcDadbdcdM : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCabacbcDadbdcdm : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCabacbcDadbdcdeq HCabacbcDadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbcDadbdcd *)
(* dans la couche 0 *)
Lemma LOoABCApabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcDadbdcd requis par la preuve de (?)OoABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcDadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcDadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcDadbdcd requis par la preuve de (?)ABCApabacbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcDadbdcd requis par la preuve de (?)ABCApabacbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcDadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcDadbdcdeq HOoABCApabacbcDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabacbcDadbdcdM : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcDadbdcdm : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabacbcDadbdcdeq HABCApabacbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcadbdcdeq : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApabacbcadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabacbcadbdcdeq HABCApabacbcadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcadbdcdmtmp;try rewrite HT2 in HABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabacbcadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadbdcdeq HABCabacbcadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadbdcdmtmp;try rewrite HT2 in HABCabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadbdcdm2 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadbdcdeq HACabacbcadbdcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadbdcdmtmp;try rewrite HT2 in HACabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadbdcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: ab :: ac :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Habacbcadbdcdm3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCabacbcDadbdcdeq : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LCabacbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCabacbcDadbdcdmtmp : rk(C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCabacbcDadbdcdeq HCabacbcDadbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ab :: ac :: bc :: D :: ad :: bd :: cd :: nil) (C :: D :: cd :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCabacbcDadbdcdmtmp;try rewrite HT2 in HCabacbcDadbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCabacbcDadbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HabacbcadbdcdM3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) <= 3).
{
	assert(Habadbdeq : rk(ab :: ad :: bd :: nil) = 2) by (apply Labadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabadbdMtmp : rk(ab :: ad :: bd :: nil) <= 2) by (solve_hyps_max Habadbdeq HabadbdM2).
	assert(Habacbcadcdeq : rk(ab :: ac :: bc :: ad :: cd :: nil) = 3) by (apply Labacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabacbcadcdMtmp : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3) by (solve_hyps_max Habacbcadcdeq HabacbcadcdM3).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil) ((ab :: ad :: bd :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ad :: nil) 2 3 2 HabadbdMtmp HabacbcadcdMtmp Habadmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HabacbcadbdcdM : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadbdcdm : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadbdcdeq Habacbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Theorem def_Conclusion : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 4 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> 
	 rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 3  /\ 
	 rk(bc :: bd :: cd ::  nil) = 2  /\ 
	 rk(ac :: ad :: cd ::  nil) = 2  /\ 
	 rk(ab :: ad :: bd ::  nil) = 2  /\ 
	 rk(ab :: ac :: bc ::  nil) = 2  .
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.
repeat split.

	apply Labacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Lbcbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Lacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Labadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Labacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.
Qed .
