Load "preamble3D.v".


(* dans la couche 0 *)
Lemma LAB : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AB requis par la preuve de (?)AB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HABm2 : rk(A :: B :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: B :: nil) (A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: nil) (A :: B :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: A :: Ap :: nil) ((A :: B :: nil) ++ (A :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApmtmp;try rewrite HT2 in HABApmtmp.
	assert(HT := rule_2 (A :: B :: nil) (A :: Ap :: nil) (A :: nil) 3 1 2 HABApmtmp HAmtmp HAApMtmp Hincl);apply HT.
}

assert(HABM : rk(A :: B ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABeq HABM2).
assert(HABm : rk(A :: B ::  nil) >= 1) by (solve_hyps_min HABeq HABm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAC : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AC requis par la preuve de (?)AC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HACm2 : rk(A :: C :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: C :: nil) (A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: nil) (A :: C :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: A :: Ap :: nil) ((A :: C :: nil) ++ (A :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApmtmp;try rewrite HT2 in HACApmtmp.
	assert(HT := rule_2 (A :: C :: nil) (A :: Ap :: nil) (A :: nil) 3 1 2 HACApmtmp HAmtmp HAApMtmp Hincl);apply HT.
}

assert(HACM : rk(A :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACeq HACM2).
assert(HACm : rk(A :: C ::  nil) >= 1) by (solve_hyps_min HACeq HACm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBC : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BC requis par la preuve de (?)BC pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et -4*)
assert(HBCm2 : rk(B :: C :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 3) by (solve_hyps_min HBCBpeq HBCBpm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: nil) (B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: nil) (B :: C :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: B :: Bp :: nil) ((B :: C :: nil) ++ (B :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpmtmp;try rewrite HT2 in HBCBpmtmp.
	assert(HT := rule_2 (B :: C :: nil) (B :: Bp :: nil) (B :: nil) 3 1 2 HBCBpmtmp HBmtmp HBBpMtmp Hincl);apply HT.
}

assert(HBCM : rk(B :: C ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBCeq HBCM2).
assert(HBCm : rk(B :: C ::  nil) >= 1) by (solve_hyps_min HBCeq HBCm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BAp requis par la preuve de (?)BAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HBApm2 : rk(B :: Ap :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (B :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: nil) (A :: Ap :: B :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: B :: Ap :: nil) ((A :: Ap :: nil) ++ (B :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApmtmp;try rewrite HT2 in HABApmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (B :: Ap :: nil) (Ap :: nil) 3 1 2 HABApmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HBApM : rk(B :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBApeq HBApM2).
assert(HBApm : rk(B :: Ap ::  nil) >= 1) by (solve_hyps_min HBApeq HBApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABAp requis par la preuve de (?)OoABAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABApM3 : rk(Oo :: A :: B :: Ap :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: nil) (B :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Oo :: A :: Ap :: nil) ((B :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HBMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApm2 : rk(Oo :: A :: B :: Ap :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: Ap :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApm3 : rk(Oo :: A :: B :: Ap :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApM : rk(Oo :: A :: B :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApm : rk(Oo :: A :: B :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABApeq HOoABApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CAp requis par la preuve de (?)CAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HCApm2 : rk(C :: Ap :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HACApmtmp : rk(A :: C :: Ap :: nil) >= 3) by (solve_hyps_min HACApeq HACApm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: nil) (A :: Ap :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: C :: Ap :: nil) ((A :: Ap :: nil) ++ (C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApmtmp;try rewrite HT2 in HACApmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (C :: Ap :: nil) (Ap :: nil) 3 1 2 HACApmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HCApM : rk(C :: Ap ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCApeq HCApM2).
assert(HCApm : rk(C :: Ap ::  nil) >= 1) by (solve_hyps_min HCApeq HCApm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACAp *)
(* dans la couche 0 *)
Lemma LOoABCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCAp requis par la preuve de (?)OoABCAp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApm4 : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApM : rk(Oo :: A :: B :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApm : rk(Oo :: A :: B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoABCApeq HOoABCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACAp requis par la preuve de (?)OoACAp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoACApM3 : rk(Oo :: A :: C :: Ap :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: A :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: nil) (C :: Oo :: A :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: A :: Ap :: nil) ((C :: nil) ++ (Oo :: A :: Ap :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: A :: Ap :: nil) (nil) 1 2 0 HCMtmp HOoAApMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACApm2 : rk(Oo :: A :: C :: Ap :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: Ap :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: Ap :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApm3 : rk(Oo :: A :: C :: Ap :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

assert(HOoACApM : rk(Oo :: A :: C :: Ap ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApm : rk(Oo :: A :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HOoACApeq HOoACApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCAp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCAp requis par la preuve de (?)BCAp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApm3 : rk(B :: C :: Ap :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApeq : rk(Oo :: A :: B :: C :: Ap :: nil) = 4) by (apply LOoABCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApmtmp : rk(Oo :: A :: B :: C :: Ap :: nil) >= 4) by (solve_hyps_min HOoABCApeq HOoABCApm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApmtmp;try rewrite HT2 in HOoABCApmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: nil) (Ap :: nil) 4 1 2 HOoABCApmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HBCApM : rk(B :: C :: Ap ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCApeq HBCApM3).
assert(HBCApm : rk(B :: C :: Ap ::  nil) >= 1) by (solve_hyps_min HBCApeq HBCApm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ABp requis par la preuve de (?)ABp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HABpm2 : rk(A :: Bp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Ap :: nil) (A :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: nil) (A :: Ap :: A :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: A :: Bp :: nil) ((A :: Ap :: nil) ++ (A :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpmtmp;try rewrite HT2 in HAApBpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (A :: Bp :: nil) (A :: nil) 3 1 2 HAApBpmtmp HAmtmp HAApMtmp Hincl); apply HT.
}

assert(HABpM : rk(A :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HABpeq HABpM2).
assert(HABpm : rk(A :: Bp ::  nil) >= 1) by (solve_hyps_min HABpeq HABpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CBp requis par la preuve de (?)CBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Bp ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpm2 : rk(C :: Bp :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBCBpmtmp : rk(B :: C :: Bp :: nil) >= 3) by (solve_hyps_min HBCBpeq HBCBpm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Bp :: nil) (B :: Bp :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: C :: Bp :: nil) ((B :: Bp :: nil) ++ (C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCBpmtmp;try rewrite HT2 in HBCBpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (C :: Bp :: nil) (Bp :: nil) 3 1 2 HBCBpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

assert(HCBpM : rk(C :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCBpeq HCBpM2).
assert(HCBpm : rk(C :: Bp ::  nil) >= 1) by (solve_hyps_min HCBpeq HCBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCBp *)
(* dans la couche 0 *)
Lemma LOoABCApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBp requis par la preuve de (?)OoABCApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpM : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpm : rk(Oo :: A :: B :: C :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBp requis par la preuve de (?)OoBCBp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBCBpM3 : rk(Oo :: B :: C :: Bp :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: nil) (C :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Oo :: B :: Bp :: nil) ((C :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Oo :: B :: Bp :: nil) (nil) 1 2 0 HCMtmp HOoBBpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCBpm2 : rk(Oo :: B :: C :: Bp :: nil) >= 2).
{
	assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: Bp :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpm3 : rk(Oo :: B :: C :: Bp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) = 4) by (apply LOoABCApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: nil) >= 4) by (solve_hyps_min HOoABCApBpeq HOoABCApBpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpmtmp;try rewrite HT2 in HOoABCApBpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: nil) (Oo :: nil) 4 1 2 HOoABCApBpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCBpM : rk(Oo :: B :: C :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpm : rk(Oo :: B :: C :: Bp ::  nil) >= 1) by (solve_hyps_min HOoBCBpeq HOoBCBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApBp requis par la preuve de (?)ApBp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Bp ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HApBpm2 : rk(Ap :: Bp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Ap :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: nil) (A :: Ap :: Ap :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Ap :: Bp :: nil) ((A :: Ap :: nil) ++ (Ap :: Bp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpmtmp;try rewrite HT2 in HAApBpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Ap :: Bp :: nil) (Ap :: nil) 3 1 2 HAApBpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HApBpM : rk(Ap :: Bp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApBpeq HApBpM2).
assert(HApBpm : rk(Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HApBpeq HApBpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApBp *)
(* dans la couche 0 *)
Lemma LOoABApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBp requis par la preuve de (?)OoABApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpm2 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABApBpM3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Oo :: B :: Bp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: Bp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: Bp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: B :: Bp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoBBpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpm3 : rk(Oo :: A :: B :: Ap :: Bp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApBpM : rk(Oo :: A :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApBpm : rk(Oo :: A :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HOoABApBpeq HOoABApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApBp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Bp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApBp requis par la preuve de (?)ABApBp pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApBp requis par la preuve de (?)ABApBp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApBp requis par la preuve de (?)ABApBp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApBpm2 : rk(A :: B :: Ap :: Bp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Bp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApBpm3 : rk(A :: B :: Ap :: Bp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Bp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApBpM3 : rk(A :: B :: Ap :: Bp :: nil) <= 3).
{
	assert(HOoABApBpeq : rk(Oo :: A :: B :: Ap :: Bp :: nil) = 3) by (apply LOoABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApBpMtmp : rk(Oo :: A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HOoABApBpeq HOoABApBpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Bp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: B :: Ap :: Bp :: nil) 3 3 HOoABApBpMtmp Hcomp Hincl);apply HT.
}

assert(HABApBpM : rk(A :: B :: Ap :: Bp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApBpm : rk(A :: B :: Ap :: Bp ::  nil) >= 1) by (solve_hyps_min HABApBpeq HABApBpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ACp requis par la preuve de (?)ACp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Cp ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HACpm2 : rk(A :: Cp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Ap :: nil) (A :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: nil) (A :: Ap :: A :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: A :: Cp :: nil) ((A :: Ap :: nil) ++ (A :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpmtmp;try rewrite HT2 in HAApCpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (A :: Cp :: nil) (A :: nil) 3 1 2 HAApCpmtmp HAmtmp HAApMtmp Hincl); apply HT.
}

assert(HACpM : rk(A :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HACpeq HACpM2).
assert(HACpm : rk(A :: Cp ::  nil) >= 1) by (solve_hyps_min HACpeq HACpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCp *)
(* dans la couche 0 *)
Lemma LOoABCCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCp requis par la preuve de (?)OoABCCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpm4 : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpM : rk(Oo :: A :: B :: C :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpm : rk(Oo :: A :: B :: C :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCCpeq HOoABCCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCp requis par la preuve de (?)OoABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpm2 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpm3 : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCp requis par la preuve de (?)ABCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCpm2 : rk(A :: B :: Cp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HOoABApCpeq HOoABApCpm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpmtmp;try rewrite HT2 in HOoABApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: nil) (A :: B :: nil) 3 2 3 HOoABApCpmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HABCpm3 : rk(A :: B :: Cp :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpeq : rk(Oo :: A :: B :: C :: Cp :: nil) = 4) by (apply LOoABCCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpmtmp : rk(Oo :: A :: B :: C :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCCpeq HOoABCCpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: nil) (A :: B :: Cp :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: Oo :: C :: Cp :: nil) ((A :: B :: Cp :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpmtmp;try rewrite HT2 in HOoABCCpmtmp.
	assert(HT := rule_2 (A :: B :: Cp :: nil) (Oo :: C :: Cp :: nil) (Cp :: nil) 4 1 2 HOoABCCpmtmp HCpmtmp HOoCCpMtmp Hincl);apply HT.
}

assert(HABCpM : rk(A :: B :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABCpeq HABCpM3).
assert(HABCpm : rk(A :: B :: Cp ::  nil) >= 1) by (solve_hyps_min HABCpeq HABCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour ApCp requis par la preuve de (?)ApCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: Cp ::  de rang :  3 et 3 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HApCpm2 : rk(Ap :: Cp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: nil) (A :: Ap :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Ap :: Cp :: nil) ((A :: Ap :: nil) ++ (Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpmtmp;try rewrite HT2 in HAApCpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Ap :: Cp :: nil) (Ap :: nil) 3 1 2 HAApCpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

assert(HApCpM : rk(Ap :: Cp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApCpeq HApCpM2).
assert(HApCpm : rk(Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HApCpeq HApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApCp *)
(* dans la couche 0 *)
Lemma LOoABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCp requis par la preuve de (?)OoABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpM : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpm : rk(Oo :: A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBApCp *)
(* dans la couche 0 *)
Lemma LOoACApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApCp requis par la preuve de (?)OoACApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApCpm2 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoACApCpM3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: C :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: C :: Cp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoCCpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApCpm3 : rk(Oo :: A :: C :: Ap :: Cp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (Ap :: nil) 4 1 2 HOoABCApCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

assert(HOoACApCpM : rk(Oo :: A :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApCpm : rk(Oo :: A :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApCpeq HOoACApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApCp requis par la preuve de (?)BApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApCp requis par la preuve de (?)BApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApCpm2 : rk(B :: Ap :: Cp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: Cp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HBApCpm3 : rk(B :: Ap :: Cp :: nil) >= 3).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: Cp :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_2 (B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (Ap :: Cp :: nil) 4 2 3 HOoABCApCpmtmp HApCpmtmp HOoACApCpMtmp Hincl);apply HT.
}

assert(HBApCpM : rk(B :: Ap :: Cp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApCpeq HBApCpM3).
assert(HBApCpm : rk(B :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HBApCpeq HBApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCp requis par la preuve de (?)ABApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpm2 : rk(A :: B :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpm3 : rk(A :: B :: Ap :: Cp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HABApCpm4 : rk(A :: B :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (list_inter (A :: B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Cp :: Oo :: A :: C :: Ap :: Cp :: nil) ((A :: B :: Ap :: Cp :: nil) ++ (Oo :: A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) (A :: Ap :: Cp :: nil) 4 3 3 HOoABCApCpmtmp HAApCpmtmp HOoACApCpMtmp Hincl);apply HT.
}

assert(HABApCpM : rk(A :: B :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpm : rk(A :: B :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABApCpeq HABApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpm2 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApCp requis par la preuve de (?)ACApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApCpm2 : rk(A :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApCpm3 : rk(A :: C :: Ap :: Cp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApCpmtmp : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABCApCpeq HABCApCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: nil) (B :: Ap :: A :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Cp :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpmtmp;try rewrite HT2 in HABCApCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Cp :: nil) (Ap :: nil) 4 1 2 HABCApCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApCpM3 : rk(A :: C :: Ap :: Cp :: nil) <= 3).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: Ap :: Cp :: nil) (Oo :: A :: C :: Ap :: Cp :: nil) 3 3 HOoACApCpMtmp Hcomp Hincl);apply HT.
}

assert(HACApCpM : rk(A :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApCpm : rk(A :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HACApCpeq HACApCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCp requis par la preuve de (?)ABCApCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpm2 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpm4 : rk(A :: B :: C :: Ap :: Cp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpeq : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) = 4) by (apply LOoABCApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApCpeq HOoABCApCpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpmtmp;try rewrite HT2 in HOoABCApCpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpM : rk(A :: B :: C :: Ap :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpm : rk(A :: B :: C :: Ap :: Cp ::  nil) >= 1) by (solve_hyps_min HABCApCpeq HABCApCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCBpCp *)
(* dans constructLemma(), requis par LOoACApBpCp *)
(* dans la couche 0 *)
Lemma LOoABCApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCp requis par la preuve de (?)OoABCApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCp requis par la preuve de (?)OoACApBpCp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpM : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpm : rk(Oo :: A :: C :: Ap :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpCp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: Cp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCBpCp requis par la preuve de (?)OoCBpCp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpCp requis par la preuve de (?)OoCBpCp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpCp requis par la preuve de (?)OoCBpCp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpCpm2 : rk(Oo :: C :: Bp :: Cp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpCpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoABCApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpeq HOoABCApBpCpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Cp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpmtmp;try rewrite HT2 in HOoABCApBpCpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Cp :: nil) (Oo :: nil) 4 1 3 HOoABCApBpCpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoCBpCpM3 : rk(Oo :: C :: Bp :: Cp :: nil) <= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (Oo :: C :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: Cp :: nil) (Bp :: Oo :: C :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: Oo :: C :: Cp :: nil) ((Bp :: nil) ++ (Oo :: C :: Cp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (Oo :: C :: Cp :: nil) (nil) 1 2 0 HBpMtmp HOoCCpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp ::  de rang :  4 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCBpCpm3 : rk(Oo :: C :: Bp :: Cp :: nil) >= 3).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) = 4) by (apply LOoACApBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpCpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: nil) >= 4) by (solve_hyps_min HOoACApBpCpeq HOoACApBpCpm4).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Bp :: Cp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Bp :: Cp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Bp :: Cp :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Bp :: Cp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpmtmp;try rewrite HT2 in HOoACApBpCpmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Bp :: Cp :: nil) (C :: Cp :: nil) 4 2 3 HOoACApBpCpmtmp HCCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HOoCBpCpM : rk(Oo :: C :: Bp :: Cp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpCpm : rk(Oo :: C :: Bp :: Cp ::  nil) >= 1) by (solve_hyps_min HOoCBpCpeq HOoCBpCpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoab *)
(* dans constructLemma(), requis par LOoABab *)
(* dans la couche 0 *)
Lemma LOoABCCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpab requis par la preuve de (?)OoABCCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpabm4 : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpabM : rk(Oo :: A :: B :: C :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpabm : rk(Oo :: A :: B :: C :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCCpabeq HOoABCCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ab ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABabm3 : rk(Oo :: A :: B :: ab :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpabeq : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) = 4) by (apply LOoABCCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpabmtmp : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCCpabeq HOoABCCpabm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ab :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ab :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpabmtmp;try rewrite HT2 in HOoABCCpabmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ab :: nil) (Oo :: nil) 4 1 2 HOoABCCpabmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

assert(HOoABabM : rk(Oo :: A :: B :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABabm : rk(Oo :: A :: B :: ab ::  nil) >= 1) by (solve_hyps_min HOoABabeq HOoABabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ooab requis par la preuve de (?)Ooab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoabm2 : rk(Oo :: ab :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabeq : rk(Oo :: A :: B :: ab :: nil) = 3) by (apply LOoABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoABabeq HOoABabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (Oo :: ab :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: ab :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: ab :: A :: B :: ab :: nil) ((Oo :: ab :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: ab :: nil) (A :: B :: ab :: nil) (ab :: nil) 3 1 2 HOoABabmtmp Habmtmp HABabMtmp Hincl);apply HT.
}

assert(HOoabM : rk(Oo :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoabeq HOoabM2).
assert(HOoabm : rk(Oo :: ab ::  nil) >= 1) by (solve_hyps_min HOoabeq HOoabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAab *)
(* dans la couche 0 *)
Lemma LAApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApBpab requis par la preuve de (?)AApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApBpab requis par la preuve de (?)AApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpab requis par la preuve de (?)AApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApBpabM3 : rk(A :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: nil) (A :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: ab :: nil) ((A :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HAMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpabm2 : rk(A :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpabm3 : rk(A :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ab :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

assert(HAApBpabM : rk(A :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpabm : rk(A :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HAApBpabeq HAApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aab requis par la preuve de (?)Aab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAabm2 : rk(A :: ab :: nil) >= 2).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HAApBpabeq : rk(A :: Ap :: Bp :: ab :: nil) = 3) by (apply LAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpabmtmp : rk(A :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HAApBpabeq HAApBpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: nil) (A :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: Ap :: Bp :: ab :: nil) ((A :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabmtmp;try rewrite HT2 in HAApBpabmtmp.
	assert(HT := rule_2 (A :: ab :: nil) (Ap :: Bp :: ab :: nil) (ab :: nil) 3 1 2 HAApBpabmtmp Habmtmp HApBpabMtmp Hincl);apply HT.
}

assert(HAabM : rk(A :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAabeq HAabM2).
assert(HAabm : rk(A :: ab ::  nil) >= 1) by (solve_hyps_min HAabeq HAabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAab requis par la preuve de (?)OoAab pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpab requis par la preuve de (?)OoAab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpab requis par la preuve de (?)OoABCBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpabm4 : rk(Oo :: A :: B :: C :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAab requis par la preuve de (?)OoAab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoAabm2 : rk(Oo :: A :: ab :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpabmtmp : rk(Oo :: A :: B :: C :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCBpabeq HOoABCBpabm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ab :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: ab :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpabmtmp;try rewrite HT2 in HOoABCBpabmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ab :: nil) (Oo :: nil) 4 1 3 HOoABCBpabmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoAabm3 : rk(Oo :: A :: ab :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabeq : rk(Oo :: A :: B :: ab :: nil) = 3) by (apply LOoABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoABabeq HOoABabm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (Oo :: A :: ab :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: ab :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: ab :: A :: B :: ab :: nil) ((Oo :: A :: ab :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: ab :: nil) (A :: B :: ab :: nil) (A :: ab :: nil) 3 2 2 HOoABabmtmp HAabmtmp HABabMtmp Hincl);apply HT.
}

assert(HOoAabM : rk(Oo :: A :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAabeq HOoAabM3).
assert(HOoAabm : rk(Oo :: A :: ab ::  nil) >= 1) by (solve_hyps_min HOoAabeq HOoAabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBab *)
(* dans la couche 0 *)
Lemma LBApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApBpab requis par la preuve de (?)BApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBApBpabM3 : rk(B :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Bp :: ab :: nil) ((B :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HBMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApBpabm2 : rk(B :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: Bp :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBApBpabm3 : rk(B :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HBApBpmtmp : rk(B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HBApBpeq HBApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Bp :: nil) (B :: Ap :: Bp :: ab :: nil) 3 3 HBApBpmtmp Hcomp Hincl);apply HT.
}

assert(HBApBpabM : rk(B :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApBpabm : rk(B :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HBApBpabeq HBApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bab requis par la preuve de (?)Bab pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBabm2 : rk(B :: ab :: nil) >= 2).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBApBpabeq : rk(B :: Ap :: Bp :: ab :: nil) = 3) by (apply LBApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApBpabmtmp : rk(B :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HBApBpabeq HBApBpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (B :: ab :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: Bp :: ab :: nil) (B :: ab :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: ab :: Ap :: Bp :: ab :: nil) ((B :: ab :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApBpabmtmp;try rewrite HT2 in HBApBpabmtmp.
	assert(HT := rule_2 (B :: ab :: nil) (Ap :: Bp :: ab :: nil) (ab :: nil) 3 1 2 HBApBpabmtmp Habmtmp HApBpabMtmp Hincl);apply HT.
}

assert(HBabM : rk(B :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBabeq HBabM2).
assert(HBabm : rk(B :: ab ::  nil) >= 1) by (solve_hyps_min HBabeq HBabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBab requis par la preuve de (?)OoBab pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApab requis par la preuve de (?)OoBab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApab requis par la preuve de (?)OoABCApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBab requis par la preuve de (?)OoBab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBabm2 : rk(Oo :: B :: ab :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApabmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApabeq HOoABCApabm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: ab :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabmtmp;try rewrite HT2 in HOoABCApabmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ab :: nil) (Oo :: nil) 4 1 3 HOoABCApabmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoBabm3 : rk(Oo :: B :: ab :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabeq : rk(Oo :: A :: B :: ab :: nil) = 3) by (apply LOoABab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoABabeq HOoABabm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (Oo :: B :: ab :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: B :: ab :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: ab :: A :: B :: ab :: nil) ((Oo :: B :: ab :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: B :: ab :: nil) (A :: B :: ab :: nil) (B :: ab :: nil) 3 2 2 HOoABabmtmp HBabmtmp HABabMtmp Hincl);apply HT.
}

assert(HOoBabM : rk(Oo :: B :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBabeq HOoBabM3).
assert(HOoBabm : rk(Oo :: B :: ab ::  nil) >= 1) by (solve_hyps_min HOoBabeq HOoBabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApab *)
(* dans la couche 0 *)
Lemma LABApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABApab requis par la preuve de (?)ABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABApab requis par la preuve de (?)ABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApab requis par la preuve de (?)ABApab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABApabM3 : rk(A :: B :: Ap :: ab :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: nil) (Ap :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: B :: ab :: nil) ((Ap :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HApMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabm2 : rk(A :: B :: Ap :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabm3 : rk(A :: B :: Ap :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HABApabM : rk(A :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabm : rk(A :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HABApabeq HABApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apab requis par la preuve de (?)Apab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab ::  de rang :  3 et 3 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabm2 : rk(Ap :: ab :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabeq : rk(A :: B :: Ap :: ab :: nil) = 3) by (apply LABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApabmtmp : rk(A :: B :: Ap :: ab :: nil) >= 3) by (solve_hyps_min HABApabeq HABApabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: nil) (A :: B :: ab :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabmtmp;try rewrite HT2 in HABApabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: nil) (ab :: nil) 3 1 2 HABApabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

assert(HApabM : rk(Ap :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApabeq HApabM2).
assert(HApabm : rk(Ap :: ab ::  nil) >= 1) by (solve_hyps_min HApabeq HApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApab requis par la preuve de (?)OoAApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApab requis par la preuve de (?)OoAApab pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApab requis par la preuve de (?)OoAApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApabm2 : rk(Oo :: A :: Ap :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApabM3 : rk(Oo :: A :: Ap :: ab :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HabMtmp : rk(ab :: nil) <= 1) by (solve_hyps_max Habeq HabM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Ap :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (ab :: nil) (nil) 2 1 0 HOoAApMtmp HabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApabm3 : rk(Oo :: A :: Ap :: ab :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Ap :: ab :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApabM : rk(Oo :: A :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApabm : rk(Oo :: A :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoAApabeq HOoAApabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApab *)
(* dans la couche 0 *)
Lemma LOoABApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApab requis par la preuve de (?)OoABApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabm2 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoABApabM3 : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: nil) (Oo :: A :: Ap :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: B :: ab :: nil) (A :: nil) 2 2 1 HOoAApMtmp HABabMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabm3 : rk(Oo :: A :: B :: Ap :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApabM : rk(Oo :: A :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApabm : rk(Oo :: A :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoABApabeq HOoABApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApab requis par la preuve de (?)OoBApab pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApab requis par la preuve de (?)OoBApab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApab requis par la preuve de (?)OoBApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApabm2 : rk(Oo :: B :: Ap :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: ab :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApabm3 : rk(Oo :: B :: Ap :: ab :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Ap :: ab :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApabM3 : rk(Oo :: B :: Ap :: ab :: nil) <= 3).
{
	assert(HOoABApabeq : rk(Oo :: A :: B :: Ap :: ab :: nil) = 3) by (apply LOoABApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApabMtmp : rk(Oo :: A :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoABApabeq HOoABApabM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Ap :: ab :: nil) (Oo :: A :: B :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: Ap :: ab :: nil) (Oo :: A :: B :: Ap :: ab :: nil) 3 3 HOoABApabMtmp Hcomp Hincl);apply HT.
}

assert(HOoBApabM : rk(Oo :: B :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApabm : rk(Oo :: B :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoBApabeq HOoBApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApab requis par la preuve de (?)OoABCApab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabM : rk(Oo :: A :: B :: C :: Ap :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabm : rk(Oo :: A :: B :: C :: Ap :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApabeq HOoABCApabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpab requis par la preuve de (?)OoABCBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpabm4 : rk(Oo :: A :: B :: C :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpabM : rk(Oo :: A :: B :: C :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpabm : rk(Oo :: A :: B :: C :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCBpabeq HOoABCBpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpab *)
(* dans constructLemma(), requis par LOoCApBpCpab *)
(* dans constructLemma(), requis par LOoACApBpCpab *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpab requis par la preuve de (?)OoABCApBpCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpabM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpab requis par la preuve de (?)OoACApBpCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpab requis par la preuve de (?)OoACApBpCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpab requis par la preuve de (?)OoACApBpCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpabm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpabm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoABCApBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabmtmp;try rewrite HT2 in HOoABCApBpCpabmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpabmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpabm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoABCApBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabmtmp;try rewrite HT2 in HOoABCApBpCpabmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpabmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpabM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpabm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpabeq HOoACApBpCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpab requis par la preuve de (?)OoCApBpCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpab requis par la preuve de (?)OoCApBpCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpab requis par la preuve de (?)OoCApBpCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpab requis par la preuve de (?)OoBCApBpCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpabm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoABCApBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabmtmp;try rewrite HT2 in HOoABCApBpCpabmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpabmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpab requis par la preuve de (?)OoCApBpCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpabm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpabmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpabeq HOoBCApBpCpabm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpabmtmp;try rewrite HT2 in HOoBCApBpCpabmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpabmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoABCApBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabeq HOoABCApBpCpabm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabmtmp;try rewrite HT2 in HOoABCApBpCpabmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpabmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: ab ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpabeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoACApBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpCpabmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoACApBpCpabeq HOoACApBpCpabm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpabmtmp;try rewrite HT2 in HOoACApBpCpabmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpabmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HOoCApBpCpabM : rk(Oo :: C :: Ap :: Bp :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpabm : rk(Oo :: C :: Ap :: Bp :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpabeq HOoCApBpCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApBpab *)
(* dans la couche 0 *)
Lemma LOoCCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpab requis par la preuve de (?)OoCCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpab requis par la preuve de (?)OoCCpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpab requis par la preuve de (?)OoCCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpab requis par la preuve de (?)OoABCApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpab requis par la preuve de (?)OoCCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpabm2 : rk(Oo :: C :: Cp :: ab :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApCpabeq HOoABCApCpabm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabmtmp;try rewrite HT2 in HOoABCApCpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: ab :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoCCpabM3 : rk(Oo :: C :: Cp :: ab :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HabMtmp : rk(ab :: nil) <= 1) by (solve_hyps_max Habeq HabM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: ab :: nil) (Oo :: C :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: ab :: nil) ((Oo :: C :: Cp :: nil) ++ (ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (ab :: nil) (nil) 2 1 0 HOoCCpMtmp HabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ab ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoCCpabm3 : rk(Oo :: C :: Cp :: ab :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCCpabeq : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) = 4) by (apply LOoABCCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpabmtmp : rk(Oo :: A :: B :: C :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCCpabeq HOoABCCpabm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: C :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ab :: nil) (A :: B :: ab :: Oo :: C :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: C :: Cp :: ab :: nil) ((A :: B :: ab :: nil) ++ (Oo :: C :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpabmtmp;try rewrite HT2 in HOoABCCpabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: C :: Cp :: ab :: nil) (ab :: nil) 4 1 2 HOoABCCpabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoCCpabM : rk(Oo :: C :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpabm : rk(Oo :: C :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoCCpabeq HOoCCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApBpab requis par la preuve de (?)OoApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoApBpabM3 : rk(Oo :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Bp :: ab :: nil) (Oo :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: ab :: nil) ((Oo :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HOoMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApBpabm2 : rk(Oo :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Oo :: Ap :: Bp :: ab :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApBpabm3 : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoCCpabeq : rk(Oo :: C :: Cp :: ab :: nil) = 3) by (apply LOoCCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpabMtmp : rk(Oo :: C :: Cp :: ab :: nil) <= 3) by (solve_hyps_max HOoCCpabeq HOoCCpabM3).
	assert(HOoCApBpCpabeq : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) = 4) by (apply LOoCApBpCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApBpCpabmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoCApBpCpabeq HOoCApBpCpabm4).
	assert(HOoabeq : rk(Oo :: ab :: nil) = 2) by (apply LOoab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoabmtmp : rk(Oo :: ab :: nil) >= 2) by (solve_hyps_min HOoabeq HOoabm2).
	assert(Hincl : incl (Oo :: ab :: nil) (list_inter (Oo :: Ap :: Bp :: ab :: nil) (Oo :: C :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: ab :: nil) (Oo :: Ap :: Bp :: ab :: Oo :: C :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Bp :: ab :: Oo :: C :: Cp :: ab :: nil) ((Oo :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpabmtmp;try rewrite HT2 in HOoCApBpCpabmtmp.
	assert(HT := rule_2 (Oo :: Ap :: Bp :: ab :: nil) (Oo :: C :: Cp :: ab :: nil) (Oo :: ab :: nil) 4 2 3 HOoCApBpCpabmtmp HOoabmtmp HOoCCpabMtmp Hincl);apply HT.
}

assert(HOoApBpabM : rk(Oo :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApBpabm : rk(Oo :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoApBpabeq HOoApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApBpab requis par la preuve de (?)OoAApBpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpab requis par la preuve de (?)OoAApBpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpab requis par la preuve de (?)OoAApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpabm2 : rk(Oo :: A :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoAApBpabM3 : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: A :: Ap :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Ap :: Bp :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Ap :: Bp :: ab :: nil) (Ap :: nil) 2 2 1 HOoAApMtmp HApBpabMtmp HApmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpabm3 : rk(Oo :: A :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpabM : rk(Oo :: A :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpabm : rk(Oo :: A :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoAApBpabeq HOoAApBpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCApBpab *)
(* dans constructLemma(), requis par LABCApBpab *)
(* dans la couche 0 *)
Lemma LOoABCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpab requis par la preuve de (?)OoABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpab requis par la preuve de (?)ABCApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpab requis par la preuve de (?)ABCApBpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpabm2 : rk(A :: B :: C :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpabm4 : rk(A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoABCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ab :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpabmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpabM : rk(A :: B :: C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpabm : rk(A :: B :: C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HABCApBpabeq HABCApBpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApBpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: Bp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApBpab requis par la preuve de (?)BCApBpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApBpabm3 : rk(B :: C :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpabeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LOoABCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HOoABCApBpabeq HOoABCApBpabm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Bp :: ab :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabmtmp;try rewrite HT2 in HOoABCApBpabmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Bp :: ab :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApBpab requis par la preuve de (?)CApBpab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCApBpabM3 : rk(C :: Ap :: Bp :: ab :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Bp :: ab :: nil) (C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: nil) ((C :: nil) ++ (Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: Bp :: ab :: nil) (nil) 1 2 0 HCMtmp HApBpabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Bp :: ab ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApBpabm2 : rk(C :: Ap :: Bp :: ab :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApBpabmtmp : rk(B :: C :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HBCApBpabeq HBCApBpabm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Bp :: ab :: nil) (B :: Ap :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: Bp :: ab :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApBpabmtmp;try rewrite HT2 in HBCApBpabmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: Bp :: ab :: nil) (Ap :: nil) 3 1 2 HBCApBpabmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ab ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HCApBpabm3 : rk(C :: Ap :: Bp :: ab :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpabeq : rk(A :: B :: C :: Ap :: Bp :: ab :: nil) = 4) by (apply LABCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpabmtmp : rk(A :: B :: C :: Ap :: Bp :: ab :: nil) >= 4) by (solve_hyps_min HABCApBpabeq HABCApBpabm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (C :: Ap :: Bp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ab :: nil) (A :: B :: Ap :: Bp :: C :: Ap :: Bp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: C :: Ap :: Bp :: ab :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (C :: Ap :: Bp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpabmtmp;try rewrite HT2 in HABCApBpabmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (C :: Ap :: Bp :: ab :: nil) (Ap :: Bp :: nil) 4 2 3 HABCApBpabmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HCApBpabM : rk(C :: Ap :: Bp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApBpabm : rk(C :: Ap :: Bp :: ab ::  nil) >= 1) by (solve_hyps_min HCApBpabeq HCApBpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCpab *)
(* dans la couche 0 *)
Lemma LABCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Cp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCpab requis par la preuve de (?)ABCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCpab requis par la preuve de (?)ABCpab pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)ABCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCpab requis par la preuve de (?)ABCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABCpabm2 : rk(A :: B :: Cp :: ab :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: nil) (Oo :: A :: B :: Ap :: A :: B :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Cp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabmtmp;try rewrite HT2 in HOoABApCpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Cp :: ab :: nil) (A :: B :: nil) 3 2 3 HOoABApCpabmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCpabM3 : rk(A :: B :: Cp :: ab :: nil) <= 3).
{
	assert(HCpMtmp : rk(Cp :: nil) <= 1) by (solve_hyps_max HCpeq HCpM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Cp :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: ab :: nil) (Cp :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: A :: B :: ab :: nil) ((Cp :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Cp :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HCpMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCpabm3 : rk(A :: B :: Cp :: ab :: nil) >= 3).
{
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (A :: B :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (A :: B :: Cp :: ab :: nil) 3 3 HABCpmtmp Hcomp Hincl);apply HT.
}

assert(HABCpabM : rk(A :: B :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCpabm : rk(A :: B :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HABCpabeq HABCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: ab ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cpab requis par la preuve de (?)Cpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Cp :: ab ::  de rang :  3 et 3 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCpabm2 : rk(Cp :: ab :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCpabeq : rk(A :: B :: Cp :: ab :: nil) = 3) by (apply LABCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpabmtmp : rk(A :: B :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HABCpabeq HABCpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Cp :: ab :: nil) (A :: B :: ab :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Cp :: ab :: nil) ((A :: B :: ab :: nil) ++ (Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCpabmtmp;try rewrite HT2 in HABCpabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Cp :: ab :: nil) (ab :: nil) 3 1 2 HABCpabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

assert(HCpabM : rk(Cp :: ab ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpabeq HCpabM2).
assert(HCpabm : rk(Cp :: ab ::  nil) >= 1) by (solve_hyps_min HCpabeq HCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpab *)
(* dans constructLemma(), requis par LOoAApCpab *)
(* dans la couche 0 *)
Lemma LOoABApCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabM : rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabm : rk(Oo :: A :: B :: Ap :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpab requis par la preuve de (?)OoAApCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpab requis par la preuve de (?)OoAApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpab requis par la preuve de (?)OoAApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabm2 : rk(Oo :: A :: Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabm3 : rk(Oo :: A :: Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabm4 : rk(Oo :: A :: Ap :: Cp :: ab :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) = 4) by (apply LOoABApCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabmtmp;try rewrite HT2 in HOoABApCpabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoAApCpabM : rk(Oo :: A :: Ap :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpabm : rk(Oo :: A :: Ap :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoAApCpabeq HOoAApCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpab requis par la preuve de (?)OoCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpab requis par la preuve de (?)OoCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpab requis par la preuve de (?)OoABCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpab requis par la preuve de (?)OoABApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpab requis par la preuve de (?)OoABCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABCpabm2 : rk(Oo :: A :: B :: Cp :: ab :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HOoABApCpabeq HOoABApCpabm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Cp :: ab :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabmtmp;try rewrite HT2 in HOoABApCpabmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Cp :: ab :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApCpabmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpabm3 : rk(Oo :: A :: B :: Cp :: ab :: nil) >= 3).
{
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: ab :: nil) 3 3 HABCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpab requis par la preuve de (?)OoCpab pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: ab ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoCpabm2 : rk(Oo :: Cp :: ab :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCpabmtmp : rk(Oo :: A :: B :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HOoABCpabeq HOoABCpabm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: ab :: nil) (A :: B :: ab :: Oo :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: Cp :: ab :: nil) ((A :: B :: ab :: nil) ++ (Oo :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpabmtmp;try rewrite HT2 in HOoABCpabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: Cp :: ab :: nil) (ab :: nil) 3 1 2 HOoABCpabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab ::  de rang :  4 et 4 	 AiB : Oo :: ab ::  de rang :  2 et 2 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoCpabm3 : rk(Oo :: Cp :: ab :: nil) >= 3).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabeq : rk(Oo :: A :: Ap :: Cp :: ab :: nil) = 4) by (apply LOoAApCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpabmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HOoAApCpabeq HOoAApCpabm4).
	assert(HOoabeq : rk(Oo :: ab :: nil) = 2) by (apply LOoab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoabmtmp : rk(Oo :: ab :: nil) >= 2) by (solve_hyps_min HOoabeq HOoabm2).
	assert(Hincl : incl (Oo :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: nil) (Oo :: A :: Ap :: ab :: Oo :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: Cp :: ab :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabmtmp;try rewrite HT2 in HOoAApCpabmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: ab :: nil) (Oo :: ab :: nil) 4 2 3 HOoAApCpabmtmp HOoabmtmp HOoAApabMtmp Hincl); apply HT.
}

assert(HOoCpabM : rk(Oo :: Cp :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpabeq HOoCpabM3).
assert(HOoCpabm : rk(Oo :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoCpabeq HOoCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpab *)
(* dans la couche 0 *)
Lemma LABApCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpab requis par la preuve de (?)ABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpab requis par la preuve de (?)ABApCpab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpab requis par la preuve de (?)ABApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabm2 : rk(A :: B :: Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabm3 : rk(A :: B :: Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabm4 : rk(A :: B :: Ap :: Cp :: ab :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabM : rk(A :: B :: Ap :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabm : rk(A :: B :: Ap :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HABApCpabeq HABApCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpab requis par la preuve de (?)ApCpab pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpab requis par la preuve de (?)ApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabm2 : rk(Ap :: Cp :: ab :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ab :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabm3 : rk(Ap :: Cp :: ab :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabeq : rk(A :: B :: Ap :: Cp :: ab :: nil) = 4) by (apply LABApCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpabmtmp : rk(A :: B :: Ap :: Cp :: ab :: nil) >= 4) by (solve_hyps_min HABApCpabeq HABApCpabm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabmtmp;try rewrite HT2 in HABApCpabmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: nil) (ab :: nil) 4 1 2 HABApCpabmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

assert(HApCpabM : rk(Ap :: Cp :: ab ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpabeq HApCpabM3).
assert(HApCpabm : rk(Ap :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HApCpabeq HApCpabm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpab : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpab requis par la preuve de (?)OoABCApCpab pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabeq HOoABCApCpabm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoac *)
(* dans constructLemma(), requis par LOoACac *)
(* dans la couche 0 *)
Lemma LOoABCBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpac requis par la preuve de (?)OoABCBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpacm4 : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpacM : rk(Oo :: A :: B :: C :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpacm : rk(Oo :: A :: B :: C :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoACac requis par la preuve de (?)OoACac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoACac requis par la preuve de (?)OoACac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACac requis par la preuve de (?)OoACac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoACacM3 : rk(Oo :: A :: C :: ac :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: ac :: nil) (Oo :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: ac :: nil) ((Oo :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HOoMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACacm2 : rk(Oo :: A :: C :: ac :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (Oo :: A :: C :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (Oo :: A :: C :: ac :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACacm3 : rk(Oo :: A :: C :: ac :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpaceq : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) = 4) by (apply LOoABCBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpacmtmp : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ac :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: ac :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpacmtmp;try rewrite HT2 in HOoABCBpacmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ac :: nil) (Oo :: nil) 4 1 2 HOoABCBpacmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HOoACacM : rk(Oo :: A :: C :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACacm : rk(Oo :: A :: C :: ac ::  nil) >= 1) by (solve_hyps_min HOoACaceq HOoACacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ooac requis par la preuve de (?)Ooac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoacm2 : rk(Oo :: ac :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACaceq : rk(Oo :: A :: C :: ac :: nil) = 3) by (apply LOoACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACacmtmp : rk(Oo :: A :: C :: ac :: nil) >= 3) by (solve_hyps_min HOoACaceq HOoACacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (Oo :: ac :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: ac :: nil) (Oo :: ac :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: ac :: A :: C :: ac :: nil) ((Oo :: ac :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACacmtmp;try rewrite HT2 in HOoACacmtmp.
	assert(HT := rule_2 (Oo :: ac :: nil) (A :: C :: ac :: nil) (ac :: nil) 3 1 2 HOoACacmtmp Hacmtmp HACacMtmp Hincl);apply HT.
}

assert(HOoacM : rk(Oo :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoaceq HOoacM2).
assert(HOoacm : rk(Oo :: ac ::  nil) >= 1) by (solve_hyps_min HOoaceq HOoacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAac *)
(* dans la couche 0 *)
Lemma LAApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpac requis par la preuve de (?)AApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApCpacM3 : rk(A :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Cp :: ac :: nil) ((A :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HAMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpacm2 : rk(A :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpacm3 : rk(A :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ac :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

assert(HAApCpacM : rk(A :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpacm : rk(A :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HAApCpaceq HAApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aac requis par la preuve de (?)Aac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAacm2 : rk(A :: ac :: nil) >= 2).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HAApCpaceq : rk(A :: Ap :: Cp :: ac :: nil) = 3) by (apply LAApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpacmtmp : rk(A :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HAApCpaceq HAApCpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: nil) (A :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: Ap :: Cp :: ac :: nil) ((A :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpacmtmp;try rewrite HT2 in HAApCpacmtmp.
	assert(HT := rule_2 (A :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HAApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HAacM : rk(A :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAaceq HAacM2).
assert(HAacm : rk(A :: ac ::  nil) >= 1) by (solve_hyps_min HAaceq HAacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAac requis par la preuve de (?)OoAac pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAac requis par la preuve de (?)OoAac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoAacm2 : rk(Oo :: A :: ac :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpaceq : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) = 4) by (apply LOoABCBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpacmtmp : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ac :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: ac :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpacmtmp;try rewrite HT2 in HOoABCBpacmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: ac :: nil) (Oo :: nil) 4 1 3 HOoABCBpacmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoAacm3 : rk(Oo :: A :: ac :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACaceq : rk(Oo :: A :: C :: ac :: nil) = 3) by (apply LOoACac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACacmtmp : rk(Oo :: A :: C :: ac :: nil) >= 3) by (solve_hyps_min HOoACaceq HOoACacm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (Oo :: A :: ac :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: ac :: nil) (Oo :: A :: ac :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: ac :: A :: C :: ac :: nil) ((Oo :: A :: ac :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACacmtmp;try rewrite HT2 in HOoACacmtmp.
	assert(HT := rule_2 (Oo :: A :: ac :: nil) (A :: C :: ac :: nil) (A :: ac :: nil) 3 2 2 HOoACacmtmp HAacmtmp HACacMtmp Hincl);apply HT.
}

assert(HOoAacM : rk(Oo :: A :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAaceq HOoAacM3).
assert(HOoAacm : rk(Oo :: A :: ac ::  nil) >= 1) by (solve_hyps_min HOoAaceq HOoAacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBac *)
(* dans la couche 0 *)
Lemma LOoABCac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCac requis par la preuve de (?)OoABCac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCacm4 : rk(Oo :: A :: B :: C :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCacM : rk(Oo :: A :: B :: C :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCacm : rk(Oo :: A :: B :: C :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCaceq HOoABCacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBac requis par la preuve de (?)OoBac pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoBac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBac requis par la preuve de (?)OoBac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBacm2 : rk(Oo :: B :: ac :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApacmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApaceq HOoABCApacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: ac :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacmtmp;try rewrite HT2 in HOoABCApacmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ac :: nil) (Oo :: nil) 4 1 3 HOoABCApacmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoBacm3 : rk(Oo :: B :: ac :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoABCaceq : rk(Oo :: A :: B :: C :: ac :: nil) = 4) by (apply LOoABCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCacmtmp : rk(Oo :: A :: B :: C :: ac :: nil) >= 4) by (solve_hyps_min HOoABCaceq HOoABCacm4).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (Oo :: B :: ac :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: nil) (Oo :: B :: ac :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: ac :: A :: C :: ac :: nil) ((Oo :: B :: ac :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacmtmp;try rewrite HT2 in HOoABCacmtmp.
	assert(HT := rule_2 (Oo :: B :: ac :: nil) (A :: C :: ac :: nil) (ac :: nil) 4 1 2 HOoABCacmtmp Hacmtmp HACacMtmp Hincl);apply HT.
}

assert(HOoBacM : rk(Oo :: B :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBaceq HOoBacM3).
assert(HOoBacm : rk(Oo :: B :: ac ::  nil) >= 1) by (solve_hyps_min HOoBaceq HOoBacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABac requis par la preuve de (?)OoABac pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpac requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpac requis par la preuve de (?)OoABCCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABac requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApac requis par la preuve de (?)OoABApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacm2 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacm3 : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABac requis par la preuve de (?)OoABac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABacm2 : rk(Oo :: A :: B :: ac :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacmtmp : rk(Oo :: A :: B :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoABApaceq HOoABApacm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacmtmp;try rewrite HT2 in HOoABApacmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApacmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABacm3 : rk(Oo :: A :: B :: ac :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpacmtmp : rk(Oo :: A :: B :: C :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCCpaceq HOoABCCpacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ac :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ac :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpacmtmp;try rewrite HT2 in HOoABCCpacmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: nil) (Oo :: nil) 4 1 2 HOoABCCpacmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoABacm4 : rk(Oo :: A :: B :: ac :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoABCaceq : rk(Oo :: A :: B :: C :: ac :: nil) = 4) by (apply LOoABCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCacmtmp : rk(Oo :: A :: B :: C :: ac :: nil) >= 4) by (solve_hyps_min HOoABCaceq HOoABCacm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (Oo :: A :: B :: ac :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: nil) (Oo :: A :: B :: ac :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ac :: A :: C :: ac :: nil) ((Oo :: A :: B :: ac :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacmtmp;try rewrite HT2 in HOoABCacmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: ac :: nil) (A :: C :: ac :: nil) (A :: ac :: nil) 4 2 2 HOoABCacmtmp HAacmtmp HACacMtmp Hincl);apply HT.
}

assert(HOoABacM : rk(Oo :: A :: B :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABacm : rk(Oo :: A :: B :: ac ::  nil) >= 1) by (solve_hyps_min HOoABaceq HOoABacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCac *)
(* dans la couche 0 *)
Lemma LCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpac requis par la preuve de (?)BCApCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacm3 : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacmtmp;try rewrite HT2 in HOoABCApCpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApCpac requis par la preuve de (?)CApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCApCpacM3 : rk(C :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Cp :: ac :: nil) ((C :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HCMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApCpacm2 : rk(C :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApCpacmtmp : rk(B :: C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HBCApCpaceq HBCApCpacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: nil) (B :: Ap :: C :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacmtmp;try rewrite HT2 in HBCApCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: Cp :: ac :: nil) (Ap :: nil) 3 1 2 HBCApCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HCApCpacm3 : rk(C :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: Cp :: nil) (C :: Ap :: Cp :: ac :: nil) 3 3 HCApCpmtmp Hcomp Hincl);apply HT.
}

assert(HCApCpacM : rk(C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApCpacm : rk(C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HCApCpaceq HCApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cac requis par la preuve de (?)Cac pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCacm2 : rk(C :: ac :: nil) >= 2).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HCApCpaceq : rk(C :: Ap :: Cp :: ac :: nil) = 3) by (apply LCApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApCpacmtmp : rk(C :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HCApCpaceq HCApCpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (C :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: Cp :: ac :: nil) (C :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: ac :: Ap :: Cp :: ac :: nil) ((C :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApCpacmtmp;try rewrite HT2 in HCApCpacmtmp.
	assert(HT := rule_2 (C :: ac :: nil) (Ap :: Cp :: ac :: nil) (ac :: nil) 3 1 2 HCApCpacmtmp Hacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HCacM : rk(C :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCaceq HCacM2).
assert(HCacm : rk(C :: ac ::  nil) >= 1) by (solve_hyps_min HCaceq HCacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApac *)
(* dans constructLemma(), requis par LACApac *)
(* dans constructLemma(), requis par LABCApac *)
(* dans la couche 0 *)
Lemma LOoABCApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApac requis par la preuve de (?)OoABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacM : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacm : rk(Oo :: A :: B :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApaceq HOoABCApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApac requis par la preuve de (?)ABCApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApac requis par la preuve de (?)ABCApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacm2 : rk(A :: B :: C :: Ap :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacm4 : rk(A :: B :: C :: Ap :: ac :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApaceq : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) = 4) by (apply LOoABCApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApaceq HOoABCApacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacmtmp;try rewrite HT2 in HOoABCApacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacM : rk(A :: B :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacm : rk(A :: B :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HABCApaceq HABCApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACApac requis par la preuve de (?)ACApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACApac requis par la preuve de (?)ACApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApac requis par la preuve de (?)ACApac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACApacM3 : rk(A :: C :: Ap :: ac :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: nil) (Ap :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: C :: ac :: nil) ((Ap :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HApMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacm2 : rk(A :: C :: Ap :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacm3 : rk(A :: C :: Ap :: ac :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApaceq : rk(A :: B :: C :: Ap :: ac :: nil) = 4) by (apply LABCApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApacmtmp : rk(A :: B :: C :: Ap :: ac :: nil) >= 4) by (solve_hyps_min HABCApaceq HABCApacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: nil) (B :: Ap :: A :: C :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacmtmp;try rewrite HT2 in HABCApacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: nil) (Ap :: nil) 4 1 2 HABCApacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

assert(HACApacM : rk(A :: C :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacm : rk(A :: C :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HACApaceq HACApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apac requis par la preuve de (?)Apac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac ::  de rang :  3 et 3 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacm2 : rk(Ap :: ac :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApaceq : rk(A :: C :: Ap :: ac :: nil) = 3) by (apply LACApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApacmtmp : rk(A :: C :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HACApaceq HACApacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: nil) (A :: C :: ac :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacmtmp;try rewrite HT2 in HACApacmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: nil) (ac :: nil) 3 1 2 HACApacmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

assert(HApacM : rk(Ap :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApaceq HApacM2).
assert(HApacm : rk(Ap :: ac ::  nil) >= 1) by (solve_hyps_min HApaceq HApacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApac *)
(* dans constructLemma(), requis par LOoApCpac *)
(* dans constructLemma(), requis par LOoApCpabac *)
(* dans constructLemma(), requis par LOoCApCpabac *)
(* dans constructLemma(), requis par LOoCApBpCpabac *)
(* dans constructLemma(), requis par LOoACApBpCpabac *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabac requis par la preuve de (?)OoABCApBpCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabacm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpabacM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabacm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabaceq HOoABCApBpCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpabac requis par la preuve de (?)OoACApBpCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpabac requis par la preuve de (?)OoACApBpCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpabac requis par la preuve de (?)OoACApBpCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpabacm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpabacm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpabaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) = 4) by (apply LOoABCApBpCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabaceq HOoABCApBpCpabacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabacmtmp;try rewrite HT2 in HOoABCApBpCpabacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpabacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpabacm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpabaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) = 4) by (apply LOoABCApBpCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabaceq HOoABCApBpCpabacm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabacmtmp;try rewrite HT2 in HOoABCApBpCpabacmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpabacmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpabacM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpabacm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpabaceq HOoACApBpCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpabac requis par la preuve de (?)OoCApBpCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpabac requis par la preuve de (?)OoCApBpCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpabac requis par la preuve de (?)OoCApBpCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpabac requis par la preuve de (?)OoBCApBpCpabac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpabacm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpabaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) = 4) by (apply LOoABCApBpCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabaceq HOoABCApBpCpabacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabacmtmp;try rewrite HT2 in HOoABCApBpCpabacmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpabacmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpabac requis par la preuve de (?)OoCApBpCpabac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpabacm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpabacmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpabaceq HOoBCApBpCpabacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpabacmtmp;try rewrite HT2 in HOoBCApBpCpabacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpabacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabacm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpabaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) = 4) by (apply LOoABCApBpCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabaceq HOoABCApBpCpabacm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabacmtmp;try rewrite HT2 in HOoABCApBpCpabacmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpabacmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpabacm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpabaceq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) = 4) by (apply LOoACApBpCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpCpabacmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoACApBpCpabaceq HOoACApBpCpabacm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpabacmtmp;try rewrite HT2 in HOoACApBpCpabacmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpabacmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HOoCApBpCpabacM : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpabacm : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpabaceq HOoCApBpCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApCpabac requis par la preuve de (?)OoCApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApCpabac requis par la preuve de (?)OoCApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApCpabac requis par la preuve de (?)OoCApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabac requis par la preuve de (?)OoBCApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabac requis par la preuve de (?)OoABCApCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApCpabac requis par la preuve de (?)OoBCApCpabac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApCpabacm3 : rk(Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpabacmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApCpabaceq HOoABCApCpabacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabacmtmp;try rewrite HT2 in HOoABCApCpabacmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApCpabacmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApCpabac requis par la preuve de (?)OoCApCpabac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Cp :: ab :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApCpabacm2 : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApCpabacmtmp : rk(Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil) >= 3) by (solve_hyps_min HOoBCApCpabaceq HOoBCApCpabacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Cp :: ab :: ac :: nil) (B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Cp :: ab :: ac :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApCpabacmtmp;try rewrite HT2 in HOoBCApCpabacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: nil) (Ap :: nil) 3 1 2 HOoBCApCpabacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoCApCpabacm3 : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: nil) 3 3 HCApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : Ap :: ab ::  de rang :  2 et 2 	 A : Ap :: Bp :: ab ::   de rang : 2 et 2 *)
assert(HOoCApCpabacm4 : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HOoCApBpCpabaceq : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) = 4) by (apply LOoCApBpCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApBpCpabacmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoCApBpCpabaceq HOoCApBpCpabacm4).
	assert(HApabeq : rk(Ap :: ab :: nil) = 2) by (apply LApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabmtmp : rk(Ap :: ab :: nil) >= 2) by (solve_hyps_min HApabeq HApabm2).
	assert(Hincl : incl (Ap :: ab :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: ab :: ac :: nil) (Ap :: Bp :: ab :: Oo :: C :: Ap :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Oo :: C :: Ap :: Cp :: ab :: ac :: nil) ((Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpabacmtmp;try rewrite HT2 in HOoCApBpCpabacmtmp.
	assert(HT := rule_4 (Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Cp :: ab :: ac :: nil) (Ap :: ab :: nil) 4 2 2 HOoCApBpCpabacmtmp HApabmtmp HApBpabMtmp Hincl); apply HT.
}

assert(HOoCApCpabacM : rk(Oo :: C :: Ap :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApCpabacm : rk(Oo :: C :: Ap :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HOoCApCpabaceq HOoCApCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApCpabac requis par la preuve de (?)OoApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabacm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabacm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApCpabac requis par la preuve de (?)OoApCpabac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpabac requis par la preuve de (?)OoApCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpabacm2 : rk(Oo :: Ap :: Cp :: ab :: ac :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Oo :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Oo :: Ap :: Cp :: ab :: ac :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoApCpabacm3 : rk(Oo :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabacmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoABApCpabaceq HOoABApCpabacm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: Ap :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) (A :: B :: ab :: Oo :: Ap :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: Ap :: Cp :: ab :: ac :: nil) ((A :: B :: ab :: nil) ++ (Oo :: Ap :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabacmtmp;try rewrite HT2 in HOoABApCpabacmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: Ap :: Cp :: ab :: ac :: nil) (ab :: nil) 4 1 2 HOoABApCpabacmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : Oo :: Cp :: ab ::  de rang :  3 et 3 	 A : Oo :: C :: Cp :: ab ::   de rang : 3 et 3 *)
assert(HOoApCpabacm4 : rk(Oo :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HOoCCpabeq : rk(Oo :: C :: Cp :: ab :: nil) = 3) by (apply LOoCCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpabMtmp : rk(Oo :: C :: Cp :: ab :: nil) <= 3) by (solve_hyps_max HOoCCpabeq HOoCCpabM3).
	assert(HOoCApCpabaceq : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: nil) = 4) by (apply LOoCApCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApCpabacmtmp : rk(Oo :: C :: Ap :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoCApCpabaceq HOoCApCpabacm4).
	assert(HOoCpabeq : rk(Oo :: Cp :: ab :: nil) = 3) by (apply LOoCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpabmtmp : rk(Oo :: Cp :: ab :: nil) >= 3) by (solve_hyps_min HOoCpabeq HOoCpabm3).
	assert(Hincl : incl (Oo :: Cp :: ab :: nil) (list_inter (Oo :: C :: Cp :: ab :: nil) (Oo :: Ap :: Cp :: ab :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Cp :: ab :: ac :: nil) (Oo :: C :: Cp :: ab :: Oo :: Ap :: Cp :: ab :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: ab :: Oo :: Ap :: Cp :: ab :: ac :: nil) ((Oo :: C :: Cp :: ab :: nil) ++ (Oo :: Ap :: Cp :: ab :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApCpabacmtmp;try rewrite HT2 in HOoCApCpabacmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: ab :: nil) (Oo :: Ap :: Cp :: ab :: ac :: nil) (Oo :: Cp :: ab :: nil) 4 3 3 HOoCApCpabacmtmp HOoCpabmtmp HOoCCpabMtmp Hincl); apply HT.
}

assert(HOoApCpabacM : rk(Oo :: Ap :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpabacm : rk(Oo :: Ap :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HOoApCpabaceq HOoApCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: Cp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApCpac requis par la preuve de (?)OoApCpac pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoApCpacM3 : rk(Oo :: Ap :: Cp :: ac :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: Cp :: ac :: nil) ((Oo :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (Ap :: Cp :: ac :: nil) (nil) 1 2 0 HOoMtmp HApCpacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoApCpacm2 : rk(Oo :: Ap :: Cp :: ac :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Oo :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Oo :: Ap :: Cp :: ac :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: Ap :: Cp :: ab :: ac ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : Ap :: Cp :: ab ::   de rang : 3 et 3 *)
assert(HOoApCpacm3 : rk(Oo :: Ap :: Cp :: ac :: nil) >= 3).
{
	assert(HApCpabeq : rk(Ap :: Cp :: ab :: nil) = 3) by (apply LApCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpabMtmp : rk(Ap :: Cp :: ab :: nil) <= 3) by (solve_hyps_max HApCpabeq HApCpabM3).
	assert(HOoApCpabaceq : rk(Oo :: Ap :: Cp :: ab :: ac :: nil) = 4) by (apply LOoApCpabac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApCpabacmtmp : rk(Oo :: Ap :: Cp :: ab :: ac :: nil) >= 4) by (solve_hyps_min HOoApCpabaceq HOoApCpabacm4).
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (Ap :: Cp :: ab :: nil) (Oo :: Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: ab :: ac :: nil) (Ap :: Cp :: ab :: Oo :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ab :: Oo :: Ap :: Cp :: ac :: nil) ((Ap :: Cp :: ab :: nil) ++ (Oo :: Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpabacmtmp;try rewrite HT2 in HOoApCpabacmtmp.
	assert(HT := rule_4 (Ap :: Cp :: ab :: nil) (Oo :: Ap :: Cp :: ac :: nil) (Ap :: Cp :: nil) 4 2 3 HOoApCpabacmtmp HApCpmtmp HApCpabMtmp Hincl); apply HT.
}

assert(HOoApCpacM : rk(Oo :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApCpacm : rk(Oo :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoApCpaceq HOoApCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApac requis par la preuve de (?)OoApac pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpCpac requis par la preuve de (?)OoApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpac requis par la preuve de (?)OoACApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpac requis par la preuve de (?)OoABCApBpCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpac requis par la preuve de (?)OoACApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpac requis par la preuve de (?)OoACApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpac requis par la preuve de (?)OoACApBpCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpacm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpacm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpacm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpacmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpac requis par la preuve de (?)OoBCApBpCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpacm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpacmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpacm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpacmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpaceq HOoBCApBpCpacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpacmtmp;try rewrite HT2 in HOoBCApBpCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpacm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpacmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpacm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpacmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoACApBpCpaceq HOoACApBpCpacm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpacmtmp;try rewrite HT2 in HOoACApBpCpacmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpacmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApac requis par la preuve de (?)OoApac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Bp :: Cp ::   de rang : 3 et 3 *)
assert(HOoApacm2 : rk(Oo :: Ap :: ac :: nil) >= 2).
{
	assert(HOoCBpCpeq : rk(Oo :: C :: Bp :: Cp :: nil) = 3) by (apply LOoCBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpCpMtmp : rk(Oo :: C :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoCBpCpeq HOoCBpCpM3).
	assert(HOoCApBpCpacmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoCApBpCpaceq HOoCApBpCpacm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Bp :: Cp :: nil) (Oo :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) (Oo :: C :: Bp :: Cp :: Oo :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Bp :: Cp :: Oo :: Ap :: ac :: nil) ((Oo :: C :: Bp :: Cp :: nil) ++ (Oo :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpacmtmp;try rewrite HT2 in HOoCApBpCpacmtmp.
	assert(HT := rule_4 (Oo :: C :: Bp :: Cp :: nil) (Oo :: Ap :: ac :: nil) (Oo :: nil) 4 1 3 HOoCApBpCpacmtmp HOomtmp HOoCBpCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoApacm3 : rk(Oo :: Ap :: ac :: nil) >= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HOoApCpaceq : rk(Oo :: Ap :: Cp :: ac :: nil) = 3) by (apply LOoApCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApCpacmtmp : rk(Oo :: Ap :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoApCpaceq HOoApCpacm3).
	assert(HApaceq : rk(Ap :: ac :: nil) = 2) by (apply LApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacmtmp : rk(Ap :: ac :: nil) >= 2) by (solve_hyps_min HApaceq HApacm2).
	assert(Hincl : incl (Ap :: ac :: nil) (list_inter (Oo :: Ap :: ac :: nil) (Ap :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: Cp :: ac :: nil) (Oo :: Ap :: ac :: Ap :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: ac :: Ap :: Cp :: ac :: nil) ((Oo :: Ap :: ac :: nil) ++ (Ap :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApCpacmtmp;try rewrite HT2 in HOoApCpacmtmp.
	assert(HT := rule_2 (Oo :: Ap :: ac :: nil) (Ap :: Cp :: ac :: nil) (Ap :: ac :: nil) 3 2 2 HOoApCpacmtmp HApacmtmp HApCpacMtmp Hincl);apply HT.
}

assert(HOoApacM : rk(Oo :: Ap :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApaceq HOoApacM3).
assert(HOoApacm : rk(Oo :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoApaceq HOoApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApac requis par la preuve de (?)OoAApac pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApac requis par la preuve de (?)OoAApac pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApac requis par la preuve de (?)OoAApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApacm2 : rk(Oo :: A :: Ap :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApacM3 : rk(Oo :: A :: Ap :: ac :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HacMtmp : rk(ac :: nil) <= 1) by (solve_hyps_max Haceq HacM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (ac :: nil) (nil) 2 1 0 HOoAApMtmp HacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApacm3 : rk(Oo :: A :: Ap :: ac :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Ap :: ac :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApacM : rk(Oo :: A :: Ap :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApacm : rk(Oo :: A :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HOoAApaceq HOoAApacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BApac requis par la preuve de (?)BApac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BApac requis par la preuve de (?)BApac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApacm2 : rk(B :: Ap :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: ac :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac ::  de rang :  4 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HBApacm3 : rk(B :: Ap :: ac :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HABCApaceq : rk(A :: B :: C :: Ap :: ac :: nil) = 4) by (apply LABCApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApacmtmp : rk(A :: B :: C :: Ap :: ac :: nil) >= 4) by (solve_hyps_min HABCApaceq HABCApacm4).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (B :: Ap :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: nil) (A :: C :: ac :: B :: Ap :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: B :: Ap :: ac :: nil) ((A :: C :: ac :: nil) ++ (B :: Ap :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacmtmp;try rewrite HT2 in HABCApacmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (B :: Ap :: ac :: nil) (ac :: nil) 4 1 2 HABCApacmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

assert(HBApacM : rk(B :: Ap :: ac ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBApaceq HBApacM3).
assert(HBApacm : rk(B :: Ap :: ac ::  nil) >= 1) by (solve_hyps_min HBApaceq HBApacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBpac *)
(* dans la couche 0 *)
Lemma LACBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Bp :: ac ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACBpac requis par la preuve de (?)ACBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACBpac requis par la preuve de (?)ACBpac pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ACBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpac requis par la preuve de (?)OoABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpacm2 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpacm4 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpaceq HOoABCApBpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacmtmp;try rewrite HT2 in HOoABCApBpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACBpac requis par la preuve de (?)ACBpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: ac ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACBpacm2 : rk(A :: C :: Bp :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpacmtmp : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HABCApBpaceq HABCApBpacm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: ac :: nil) (B :: Ap :: A :: C :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Bp :: ac :: nil) ((B :: Ap :: nil) ++ (A :: C :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpacmtmp;try rewrite HT2 in HABCApBpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Bp :: ac :: nil) (nil) 4 0 2 HABCApBpacmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACBpacM3 : rk(A :: C :: Bp :: ac :: nil) <= 3).
{
	assert(HBpMtmp : rk(Bp :: nil) <= 1) by (solve_hyps_max HBpeq HBpM1).
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Bp :: nil) (A :: C :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: ac :: nil) (Bp :: A :: C :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: A :: C :: ac :: nil) ((Bp :: nil) ++ (A :: C :: ac :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Bp :: nil) (A :: C :: ac :: nil) (nil) 1 2 0 HBpMtmp HACacMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ac ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HACBpacm3 : rk(A :: C :: Bp :: ac :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpaceq : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) = 4) by (apply LOoABCBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpacmtmp : rk(Oo :: A :: B :: C :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCBpaceq HOoABCBpacm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (A :: C :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ac :: nil) (Oo :: B :: Bp :: A :: C :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: A :: C :: Bp :: ac :: nil) ((Oo :: B :: Bp :: nil) ++ (A :: C :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpacmtmp;try rewrite HT2 in HOoABCBpacmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (A :: C :: Bp :: ac :: nil) (Bp :: nil) 4 1 2 HOoABCBpacmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

assert(HACBpacM : rk(A :: C :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACBpacm : rk(A :: C :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HACBpaceq HACBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: ac ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bpac requis par la preuve de (?)Bpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Bp :: ac ::  de rang :  3 et 3 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HBpacm2 : rk(Bp :: ac :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACBpaceq : rk(A :: C :: Bp :: ac :: nil) = 3) by (apply LACBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACBpacmtmp : rk(A :: C :: Bp :: ac :: nil) >= 3) by (solve_hyps_min HACBpaceq HACBpacm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Bp :: ac :: nil) (A :: C :: ac :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Bp :: ac :: nil) ((A :: C :: ac :: nil) ++ (Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACBpacmtmp;try rewrite HT2 in HACBpacmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Bp :: ac :: nil) (ac :: nil) 3 1 2 HACBpacmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

assert(HBpacM : rk(Bp :: ac ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpaceq HBpacM2).
assert(HBpacm : rk(Bp :: ac ::  nil) >= 1) by (solve_hyps_min HBpaceq HBpacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApBpac *)
(* dans la couche 0 *)
Lemma LOoABCApBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpac requis par la preuve de (?)OoABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpacM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpacm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApBpaceq HOoABCApBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpac requis par la preuve de (?)ABCApBpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpacm2 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpacm4 : rk(A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) = 4) by (apply LOoABCApBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpaceq HOoABCApBpacm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: ac :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacmtmp;try rewrite HT2 in HOoABCApBpacmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: ac :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpacmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpacM : rk(A :: B :: C :: Ap :: Bp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpacm : rk(A :: B :: C :: Ap :: Bp :: ac ::  nil) >= 1) by (solve_hyps_min HABCApBpaceq HABCApBpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpac requis par la preuve de (?)OoABCCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpacM : rk(Oo :: A :: B :: C :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpacm : rk(Oo :: A :: B :: C :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCCpaceq HOoABCCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpac requis par la preuve de (?)OoABCApCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApCpaceq HOoABCApCpacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpCpac *)
(* dans constructLemma(), requis par LOoACApBpCpac *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpac requis par la preuve de (?)OoABCApBpCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpacm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpacM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpacm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpac requis par la preuve de (?)OoACApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpac requis par la preuve de (?)OoACApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpac requis par la preuve de (?)OoACApBpCpac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpacm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpacm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) = 4) by (apply LOoABCApBpCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpacm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) = 4) by (apply LOoABCApBpCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpacmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpacM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpacm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpaceq HOoACApBpCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCpac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: Cp :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpac requis par la preuve de (?)OoBCApBpCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpacm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) = 4) by (apply LOoABCApBpCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpacmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpac requis par la preuve de (?)OoCApBpCpac pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpacm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpacmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpaceq HOoBCApBpCpacm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpacmtmp;try rewrite HT2 in HOoBCApBpCpacmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpacmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpacm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpaceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) = 4) by (apply LOoABCApBpCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpacmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpaceq HOoABCApBpCpacm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpacmtmp;try rewrite HT2 in HOoABCApBpCpacmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpacmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: ac ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpacm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpaceq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) = 4) by (apply LOoACApBpCpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpCpacmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) >= 4) by (solve_hyps_min HOoACApBpCpaceq HOoACApBpCpacm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: ac :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpacmtmp;try rewrite HT2 in HOoACApBpCpacmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: ac :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpacmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HOoCApBpCpacM : rk(Oo :: C :: Ap :: Bp :: Cp :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpacm : rk(Oo :: C :: Ap :: Bp :: Cp :: ac ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpaceq HOoCApBpCpacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABApCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabac requis par la preuve de (?)OoABApCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabacm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabacm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabacm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ac :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabacM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabacm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HOoABApCpabaceq HOoABApCpabacm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabac : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabac requis par la preuve de (?)OoABCApCpabac pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabacm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabacM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabacm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: ac ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabaceq HOoABCApCpabacm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOobc *)
(* dans constructLemma(), requis par LOoBCbc *)
(* dans la couche 0 *)
Lemma LOoABCApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbc requis par la preuve de (?)OoABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcM : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcm : rk(Oo :: A :: B :: C :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApbceq HOoABCApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBCbc requis par la preuve de (?)OoBCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBCbc requis par la preuve de (?)OoBCbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCbc requis par la preuve de (?)OoBCbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoBCbcM3 : rk(Oo :: B :: C :: bc :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: bc :: nil) (Oo :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: bc :: nil) ((Oo :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HOoMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCbcm2 : rk(Oo :: B :: C :: bc :: nil) >= 2).
{
	assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (Oo :: B :: C :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (Oo :: B :: C :: bc :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCbcm3 : rk(Oo :: B :: C :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

assert(HOoBCbcM : rk(Oo :: B :: C :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCbcm : rk(Oo :: B :: C :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCbceq HOoBCbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOobc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Oobc requis par la preuve de (?)Oobc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOobcm2 : rk(Oo :: bc :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HOoBCbceq : rk(Oo :: B :: C :: bc :: nil) = 3) by (apply LOoBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCbcmtmp : rk(Oo :: B :: C :: bc :: nil) >= 3) by (solve_hyps_min HOoBCbceq HOoBCbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (Oo :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: bc :: nil) (Oo :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: bc :: B :: C :: bc :: nil) ((Oo :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCbcmtmp;try rewrite HT2 in HOoBCbcmtmp.
	assert(HT := rule_2 (Oo :: bc :: nil) (B :: C :: bc :: nil) (bc :: nil) 3 1 2 HOoBCbcmtmp Hbcmtmp HBCbcMtmp Hincl);apply HT.
}

assert(HOobcM : rk(Oo :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOobceq HOobcM2).
assert(HOobcm : rk(Oo :: bc ::  nil) >= 1) by (solve_hyps_min HOobceq HOobcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAbc *)
(* dans la couche 0 *)
Lemma LOoABCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCbc requis par la preuve de (?)OoABCbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCbcm4 : rk(Oo :: A :: B :: C :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCbcM : rk(Oo :: A :: B :: C :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCbcm : rk(Oo :: A :: B :: C :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCbceq HOoABCbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAbc requis par la preuve de (?)OoAbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpbc requis par la preuve de (?)OoAbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpbc requis par la preuve de (?)OoABCBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpbcm4 : rk(Oo :: A :: B :: C :: Bp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAbc requis par la preuve de (?)OoAbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoAbcm2 : rk(Oo :: A :: bc :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpbcmtmp : rk(Oo :: A :: B :: C :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCBpbceq HOoABCBpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: bc :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: bc :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpbcmtmp;try rewrite HT2 in HOoABCBpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: bc :: nil) (Oo :: nil) 4 1 3 HOoABCBpbcmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoAbcm3 : rk(Oo :: A :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HOoABCbceq : rk(Oo :: A :: B :: C :: bc :: nil) = 4) by (apply LOoABCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCbcmtmp : rk(Oo :: A :: B :: C :: bc :: nil) >= 4) by (solve_hyps_min HOoABCbceq HOoABCbcm4).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (Oo :: A :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: bc :: nil) (Oo :: A :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: bc :: B :: C :: bc :: nil) ((Oo :: A :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCbcmtmp;try rewrite HT2 in HOoABCbcmtmp.
	assert(HT := rule_2 (Oo :: A :: bc :: nil) (B :: C :: bc :: nil) (bc :: nil) 4 1 2 HOoABCbcmtmp Hbcmtmp HBCbcMtmp Hincl);apply HT.
}

assert(HOoAbcM : rk(Oo :: A :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoAbceq HOoAbcM3).
assert(HOoAbcm : rk(Oo :: A :: bc ::  nil) >= 1) by (solve_hyps_min HOoAbceq HOoAbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbc *)
(* dans la couche 0 *)
Lemma LBBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpCpbc requis par la preuve de (?)BBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBBpCpbcM3 : rk(B :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Cp :: bc :: nil) ((B :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HBMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpbcm2 : rk(B :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Cp :: bc :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpCpbcm3 : rk(B :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HBBpCpmtmp : rk(B :: Bp :: Cp :: nil) >= 3) by (solve_hyps_min HBBpCpeq HBBpCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Cp :: nil) (B :: Bp :: Cp :: bc :: nil) 3 3 HBBpCpmtmp Hcomp Hincl);apply HT.
}

assert(HBBpCpbcM : rk(B :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpCpbcm : rk(B :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBBpCpbceq HBBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bbc requis par la preuve de (?)Bbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBbcm2 : rk(B :: bc :: nil) >= 2).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HBBpCpbceq : rk(B :: Bp :: Cp :: bc :: nil) = 3) by (apply LBBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpCpbcmtmp : rk(B :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HBBpCpbceq HBBpCpbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Cp :: bc :: nil) (B :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: Bp :: Cp :: bc :: nil) ((B :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpCpbcmtmp;try rewrite HT2 in HBBpCpbcmtmp.
	assert(HT := rule_2 (B :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HBBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}

assert(HBbcM : rk(B :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBbceq HBbcM2).
assert(HBbcm : rk(B :: bc ::  nil) >= 1) by (solve_hyps_min HBbceq HBbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBbc requis par la preuve de (?)OoBbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBbc requis par la preuve de (?)OoBbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBbcm2 : rk(Oo :: B :: bc :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: bc :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: bc :: nil) (Oo :: nil) 4 1 3 HOoABCApbcmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoBbcm3 : rk(Oo :: B :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HOoBCbceq : rk(Oo :: B :: C :: bc :: nil) = 3) by (apply LOoBCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCbcmtmp : rk(Oo :: B :: C :: bc :: nil) >= 3) by (solve_hyps_min HOoBCbceq HOoBCbcm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (Oo :: B :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: bc :: nil) (Oo :: B :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: bc :: B :: C :: bc :: nil) ((Oo :: B :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCbcmtmp;try rewrite HT2 in HOoBCbcmtmp.
	assert(HT := rule_2 (Oo :: B :: bc :: nil) (B :: C :: bc :: nil) (B :: bc :: nil) 3 2 2 HOoBCbcmtmp HBbcmtmp HBCbcMtmp Hincl);apply HT.
}

assert(HOoBbcM : rk(Oo :: B :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBbceq HOoBbcM3).
assert(HOoBbcm : rk(Oo :: B :: bc ::  nil) >= 1) by (solve_hyps_min HOoBbceq HOoBbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABbc *)
(* dans la couche 0 *)
Lemma LABCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCbc requis par la preuve de (?)ABCbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABCbcM3 : rk(A :: B :: C :: bc :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: bc :: nil) ((A :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HAMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCbcm2 : rk(A :: B :: C :: bc :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: C :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: C :: bc :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCbcm3 : rk(A :: B :: C :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: bc :: nil) (A :: nil) 4 1 2 HOoABCApbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCbcM : rk(A :: B :: C :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCbcm : rk(A :: B :: C :: bc ::  nil) >= 1) by (solve_hyps_min HABCbceq HABCbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABbc requis par la preuve de (?)ABbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApbc requis par la preuve de (?)ABbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApbc requis par la preuve de (?)OoABApbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApbc requis par la preuve de (?)OoABApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApbcm2 : rk(Oo :: A :: B :: Ap :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApbcm3 : rk(Oo :: A :: B :: Ap :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABbc requis par la preuve de (?)ABbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: bc ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABbcm2 : rk(A :: B :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApbcmtmp : rk(Oo :: A :: B :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoABApbceq HOoABApbcm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApbcmtmp;try rewrite HT2 in HOoABApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: bc :: nil) (A :: B :: nil) 3 2 3 HOoABApbcmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABbcm3 : rk(A :: B :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HABCbceq : rk(A :: B :: C :: bc :: nil) = 3) by (apply LABCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCbcmtmp : rk(A :: B :: C :: bc :: nil) >= 3) by (solve_hyps_min HABCbceq HABCbcm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (A :: B :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: B :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: bc :: B :: C :: bc :: nil) ((A :: B :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCbcmtmp;try rewrite HT2 in HABCbcmtmp.
	assert(HT := rule_2 (A :: B :: bc :: nil) (B :: C :: bc :: nil) (B :: bc :: nil) 3 2 2 HABCbcmtmp HBbcmtmp HBCbcMtmp Hincl);apply HT.
}

assert(HABbcM : rk(A :: B :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABbceq HABbcM3).
assert(HABbcm : rk(A :: B :: bc ::  nil) >= 1) by (solve_hyps_min HABbceq HABbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbc *)
(* dans constructLemma(), requis par LCBpCpbc *)
(* dans constructLemma(), requis par LACApBpCpbc *)
(* dans constructLemma(), requis par LABCApBpCpbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpbc requis par la preuve de (?)OoABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpbc requis par la preuve de (?)ABCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpbc requis par la preuve de (?)ABCApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpbcm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpbcm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpCpbcM : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpbcm : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HABCApBpCpbceq HABCApBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpbc requis par la preuve de (?)ACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpbc requis par la preuve de (?)ACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpbc requis par la preuve de (?)ACApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpbcm2 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpbcm3 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpbceq HABCApBpCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcmtmp;try rewrite HT2 in HABCApBpCpbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HABCApBpCpbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpbcm4 : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpbceq HABCApBpCpbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpbcmtmp;try rewrite HT2 in HABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HACApBpCpbcM : rk(A :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpCpbcm : rk(A :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HACApBpCpbceq HACApBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Bp :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpCpbc requis par la preuve de (?)OoBCBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm2 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (nil) 4 0 2 HOoABCApBpCpbcmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpCpbcm3 : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: nil) 4 1 2 HOoABCApBpCpbcmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CBpCpbc requis par la preuve de (?)CBpCpbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCBpCpbcM3 : rk(C :: Bp :: Cp :: bc :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Bp :: Cp :: bc :: nil) ((C :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (Bp :: Cp :: bc :: nil) (nil) 1 2 0 HCMtmp HBpCpbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HCBpCpbcm2 : rk(C :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoBCBpCpbcmtmp : rk(Oo :: B :: C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCBpCpbceq HOoBCBpCpbcm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: Cp :: bc :: nil) (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: C :: Bp :: Cp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCBpCpbcmtmp;try rewrite HT2 in HOoBCBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (C :: Bp :: Cp :: bc :: nil) (Bp :: nil) 3 1 2 HOoBCBpCpbcmtmp HBpmtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Cp ::  de rang :  2 et 2 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HCBpCpbcm3 : rk(C :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HACApBpCpbceq : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LACApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApBpCpbcmtmp : rk(A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HACApBpCpbceq HACApBpCpbcm4).
	assert(HCCpmtmp : rk(C :: Cp :: nil) >= 2) by (solve_hyps_min HCCpeq HCCpm2).
	assert(Hincl : incl (C :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: C :: Ap :: Cp :: C :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: C :: Bp :: Cp :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (C :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpbcmtmp;try rewrite HT2 in HACApBpCpbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (C :: Bp :: Cp :: bc :: nil) (C :: Cp :: nil) 4 2 3 HACApBpCpbcmtmp HCCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HCBpCpbcM : rk(C :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCBpCpbcm : rk(C :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HCBpCpbceq HCBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Cbc requis par la preuve de (?)Cbc pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HCbcm2 : rk(C :: bc :: nil) >= 2).
{
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HCBpCpbceq : rk(C :: Bp :: Cp :: bc :: nil) = 3) by (apply LCBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpCpbcmtmp : rk(C :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HCBpCpbceq HCBpCpbcm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (C :: bc :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Bp :: Cp :: bc :: nil) (C :: bc :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: Bp :: Cp :: bc :: nil) ((C :: bc :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCBpCpbcmtmp;try rewrite HT2 in HCBpCpbcmtmp.
	assert(HT := rule_2 (C :: bc :: nil) (Bp :: Cp :: bc :: nil) (bc :: nil) 3 1 2 HCBpCpbcmtmp Hbcmtmp HBpCpbcMtmp Hincl);apply HT.
}

assert(HCbcM : rk(C :: bc ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCbceq HCbcM2).
assert(HCbcm : rk(C :: bc ::  nil) >= 1) by (solve_hyps_min HCbceq HCbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ACbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApbcm2 : rk(A :: B :: C :: Ap :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApbcm4 : rk(A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACbc requis par la preuve de (?)ACbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACbcm2 : rk(A :: C :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApbcmtmp : rk(A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HABCApbceq HABCApbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: bc :: nil) (B :: Ap :: A :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApbcmtmp;try rewrite HT2 in HABCApbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: bc :: nil) (nil) 4 0 2 HABCApbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HACbcm3 : rk(A :: C :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HABCbceq : rk(A :: B :: C :: bc :: nil) = 3) by (apply LABCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCbcmtmp : rk(A :: B :: C :: bc :: nil) >= 3) by (solve_hyps_min HABCbceq HABCbcm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (A :: C :: bc :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: bc :: nil) (A :: C :: bc :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: bc :: B :: C :: bc :: nil) ((A :: C :: bc :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCbcmtmp;try rewrite HT2 in HABCbcmtmp.
	assert(HT := rule_2 (A :: C :: bc :: nil) (B :: C :: bc :: nil) (C :: bc :: nil) 3 2 2 HABCbcmtmp HCbcmtmp HBCbcMtmp Hincl);apply HT.
}

assert(HACbcM : rk(A :: C :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACbceq HACbcM3).
assert(HACbcm : rk(A :: C :: bc ::  nil) >= 1) by (solve_hyps_min HACbceq HACbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApbc *)
(* dans constructLemma(), requis par LOoBApBpbc *)
(* dans constructLemma(), requis par LOoBCApBpbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpbc requis par la preuve de (?)OoABCApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpbc requis par la preuve de (?)OoBCApBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpbcm3 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) = 4) by (apply LOoABCApBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: bc :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApBpbcmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : B :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoBCApBpbcm4 : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) = 4) by (apply LOoABCApBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(HBApBpmtmp : rk(B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HBApBpeq HBApBpm3).
	assert(Hincl : incl (B :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (A :: B :: Ap :: Bp :: Oo :: B :: C :: Ap :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: B :: C :: Ap :: Bp :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (B :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpbcmtmp HBApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoBCApBpbcM : rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApBpbcm : rk(Oo :: B :: C :: Ap :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBCApBpbceq HOoBCApBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApBpbc requis par la preuve de (?)OoBApBpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApBpbc requis par la preuve de (?)OoBApBpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApBpbc requis par la preuve de (?)OoBApBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApBpbcm2 : rk(Oo :: B :: Ap :: Bp :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Bp :: bc :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoBApBpbcm3 : rk(Oo :: B :: Ap :: Bp :: bc :: nil) >= 3).
{
	assert(HBApBpmtmp : rk(B :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HBApBpeq HBApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Bp :: nil) (Oo :: B :: Ap :: Bp :: bc :: nil) 3 3 HBApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HOoBApBpbcm4 : rk(Oo :: B :: Ap :: Bp :: bc :: nil) >= 4).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HOoBCApBpbceq : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) = 4) by (apply LOoBCApBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApBpbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoBCApBpbceq HOoBCApBpbcm4).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (Oo :: B :: Ap :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: bc :: nil) (B :: C :: bc :: Oo :: B :: Ap :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Oo :: B :: Ap :: Bp :: bc :: nil) ((B :: C :: bc :: nil) ++ (Oo :: B :: Ap :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpbcmtmp;try rewrite HT2 in HOoBCApBpbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Oo :: B :: Ap :: Bp :: bc :: nil) (B :: bc :: nil) 4 2 2 HOoBCApBpbcmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HOoBApBpbcM : rk(Oo :: B :: Ap :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApBpbcm : rk(Oo :: B :: Ap :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBApBpbceq HOoBApBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoApbc *)
(* dans la couche 0 *)
Lemma LOoBBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpbc requis par la preuve de (?)OoBBpbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpbc requis par la preuve de (?)OoBBpbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpbc requis par la preuve de (?)OoBBpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpbcm2 : rk(Oo :: B :: Bp :: bc :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) = 4) by (apply LOoABCApBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpbceq HOoABCApBpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: bc :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: bc :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpbcmtmp;try rewrite HT2 in HOoABCApBpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: bc :: nil) (Oo :: nil) 4 1 3 HOoABCApBpbcmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpbcM3 : rk(Oo :: B :: Bp :: bc :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: bc :: nil) (Oo :: B :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: bc :: nil) ((Oo :: B :: Bp :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (bc :: nil) (nil) 2 1 0 HOoBBpMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpbcm3 : rk(Oo :: B :: Bp :: bc :: nil) >= 3).
{
	assert(HOoBbceq : rk(Oo :: B :: bc :: nil) = 3) by (apply LOoBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBbcmtmp : rk(Oo :: B :: bc :: nil) >= 3) by (solve_hyps_min HOoBbceq HOoBbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: bc :: nil) (Oo :: B :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: bc :: nil) (Oo :: B :: Bp :: bc :: nil) 3 3 HOoBbcmtmp Hcomp Hincl);apply HT.
}

assert(HOoBBpbcM : rk(Oo :: B :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpbcm : rk(Oo :: B :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoBBpbceq HOoBBpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoApbc requis par la preuve de (?)OoApbc pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpCpbc requis par la preuve de (?)OoApbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpbc requis par la preuve de (?)OoACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpbc requis par la preuve de (?)OoACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpbc requis par la preuve de (?)OoACApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpbcm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpbcm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpbcm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpbc requis par la preuve de (?)OoBCApBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpbcm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpbcmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpbcm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpbceq HOoBCApBpCpbcm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpbcmtmp;try rewrite HT2 in HOoBCApBpCpbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpbcm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpbcmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpbcm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpbcmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoACApBpCpbceq HOoACApBpCpbcm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpbcmtmp;try rewrite HT2 in HOoACApBpCpbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpbcmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoApbc requis par la preuve de (?)OoApbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Bp :: Cp ::   de rang : 3 et 3 *)
assert(HOoApbcm2 : rk(Oo :: Ap :: bc :: nil) >= 2).
{
	assert(HOoCBpCpeq : rk(Oo :: C :: Bp :: Cp :: nil) = 3) by (apply LOoCBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpCpMtmp : rk(Oo :: C :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoCBpCpeq HOoCBpCpM3).
	assert(HOoCApBpCpbcmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoCApBpCpbceq HOoCApBpCpbcm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Bp :: Cp :: nil) (Oo :: Ap :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) (Oo :: C :: Bp :: Cp :: Oo :: Ap :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Bp :: Cp :: Oo :: Ap :: bc :: nil) ((Oo :: C :: Bp :: Cp :: nil) ++ (Oo :: Ap :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpbcmtmp;try rewrite HT2 in HOoCApBpCpbcmtmp.
	assert(HT := rule_4 (Oo :: C :: Bp :: Cp :: nil) (Oo :: Ap :: bc :: nil) (Oo :: nil) 4 1 3 HOoCApBpCpbcmtmp HOomtmp HOoCBpCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoApbcm3 : rk(Oo :: Ap :: bc :: nil) >= 3).
{
	assert(HOoBBpbceq : rk(Oo :: B :: Bp :: bc :: nil) = 3) by (apply LOoBBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpbcMtmp : rk(Oo :: B :: Bp :: bc :: nil) <= 3) by (solve_hyps_max HOoBBpbceq HOoBBpbcM3).
	assert(HOoBApBpbceq : rk(Oo :: B :: Ap :: Bp :: bc :: nil) = 4) by (apply LOoBApBpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApBpbcmtmp : rk(Oo :: B :: Ap :: Bp :: bc :: nil) >= 4) by (solve_hyps_min HOoBApBpbceq HOoBApBpbcm4).
	assert(HOobceq : rk(Oo :: bc :: nil) = 2) by (apply LOobc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOobcmtmp : rk(Oo :: bc :: nil) >= 2) by (solve_hyps_min HOobceq HOobcm2).
	assert(Hincl : incl (Oo :: bc :: nil) (list_inter (Oo :: Ap :: bc :: nil) (Oo :: B :: Bp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Bp :: bc :: nil) (Oo :: Ap :: bc :: Oo :: B :: Bp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Ap :: bc :: Oo :: B :: Bp :: bc :: nil) ((Oo :: Ap :: bc :: nil) ++ (Oo :: B :: Bp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApBpbcmtmp;try rewrite HT2 in HOoBApBpbcmtmp.
	assert(HT := rule_2 (Oo :: Ap :: bc :: nil) (Oo :: B :: Bp :: bc :: nil) (Oo :: bc :: nil) 4 2 3 HOoBApBpbcmtmp HOobcmtmp HOoBBpbcMtmp Hincl);apply HT.
}

assert(HOoApbcM : rk(Oo :: Ap :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoApbceq HOoApbcM3).
assert(HOoApbcm : rk(Oo :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HOoApbceq HOoApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApbc requis par la preuve de (?)OoAApbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApbc requis par la preuve de (?)OoAApbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApbc requis par la preuve de (?)OoAApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApbcm2 : rk(Oo :: A :: Ap :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoAApbcM3 : rk(Oo :: A :: Ap :: bc :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: bc :: nil) (Oo :: A :: Ap :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (bc :: nil) (nil) 2 1 0 HOoAApMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApbcm3 : rk(Oo :: A :: Ap :: bc :: nil) >= 3).
{
	assert(HOoAbceq : rk(Oo :: A :: bc :: nil) = 3) by (apply LOoAbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAbcmtmp : rk(Oo :: A :: bc :: nil) >= 3) by (solve_hyps_min HOoAbceq HOoAbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: bc :: nil) (Oo :: A :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: bc :: nil) (Oo :: A :: Ap :: bc :: nil) 3 3 HOoAbcmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApbcM : rk(Oo :: A :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApbcm : rk(Oo :: A :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HOoAApbceq HOoAApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCApbc requis par la preuve de (?)BCApbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApbc requis par la preuve de (?)BCApbc pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCApbcM3 : rk(B :: C :: Ap :: bc :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: bc :: nil) (Ap :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: B :: C :: bc :: nil) ((Ap :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (B :: C :: bc :: nil) (nil) 1 2 0 HApMtmp HBCbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApbcm3 : rk(B :: C :: Ap :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HBCApbcM : rk(B :: C :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApbcm : rk(B :: C :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HBCApbceq HBCApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApbc requis par la preuve de (?)ABCApbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApbcm2 : rk(A :: B :: C :: Ap :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApbcm4 : rk(A :: B :: C :: Ap :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbceq : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) = 4) by (apply LOoABCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApbceq HOoABCApbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcmtmp;try rewrite HT2 in HOoABCApbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApbcM : rk(A :: B :: C :: Ap :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApbcm : rk(A :: B :: C :: Ap :: bc ::  nil) >= 1) by (solve_hyps_min HABCApbceq HABCApbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpbc requis par la preuve de (?)OoABCBpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpbcm4 : rk(Oo :: A :: B :: C :: Bp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpbcM : rk(Oo :: A :: B :: C :: Bp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpbcm : rk(Oo :: A :: B :: C :: Bp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCBpbceq HOoABCBpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpbc *)
(* dans constructLemma(), requis par LBCApCpbc *)
(* dans constructLemma(), requis par LABCApCpbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpbc requis par la preuve de (?)OoABCApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpbc requis par la preuve de (?)ABCApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpbc requis par la preuve de (?)ABCApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpbcm2 : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpbcm4 : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpbcM : rk(A :: B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpbcm : rk(A :: B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HABCApCpbceq HABCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpbc requis par la preuve de (?)BCApCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpbcm3 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LOoABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpbceq HOoABCApCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpbcmtmp;try rewrite HT2 in HOoABCApCpbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBCApCpbcm4 : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HABCApCpbceq : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LABCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApCpbcmtmp : rk(A :: B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HABCApCpbceq HABCApCpbcm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: bc :: nil) (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpbcmtmp;try rewrite HT2 in HABCApCpbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: bc :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HABCApCpbcmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HBCApCpbcM : rk(B :: C :: Ap :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpbcm : rk(B :: C :: Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpbceq HBCApCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpbc requis par la preuve de (?)ApCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpbcm2 : rk(Ap :: Cp :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpbcm3 : rk(Ap :: Cp :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCApCpbceq : rk(B :: C :: Ap :: Cp :: bc :: nil) = 4) by (apply LBCApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApCpbcmtmp : rk(B :: C :: Ap :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpbceq HBCApCpbcm4).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpbcmtmp;try rewrite HT2 in HBCApCpbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HApCpbcM : rk(Ap :: Cp :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpbceq HApCpbcM3).
assert(HApCpbcm : rk(Ap :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HApCpbceq HApCpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpCpbc *)
(* dans la couche 0 *)
Lemma LOoACApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpbc requis par la preuve de (?)OoACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpbc requis par la preuve de (?)OoACApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpbc requis par la preuve de (?)OoACApBpCpbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpbcm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpbcm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpbcm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpbcM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpbcm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpbceq HOoACApBpCpbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCpbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: Cp :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpbc requis par la preuve de (?)OoBCApBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpbcm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpbcmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpbc requis par la preuve de (?)OoCApBpCpbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpbcm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpbcmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpbceq HOoBCApBpCpbcm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpbcmtmp;try rewrite HT2 in HOoBCApBpCpbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpbcm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoABCApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpbceq HOoABCApBpCpbcm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpbcmtmp;try rewrite HT2 in HOoABCApBpCpbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpbcmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: bc ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpbcm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpbceq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) = 4) by (apply LOoACApBpCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpCpbcmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) >= 4) by (solve_hyps_min HOoACApBpCpbceq HOoACApBpCpbcm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: bc :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpbcmtmp;try rewrite HT2 in HOoACApBpCpbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: bc :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpbcmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HOoCApBpCpbcM : rk(Oo :: C :: Ap :: Bp :: Cp :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpbcm : rk(Oo :: C :: Ap :: Bp :: Cp :: bc ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpbceq HOoCApBpCpbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACabbc *)
(* dans la couche 0 *)
Lemma LABCabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbc requis par la preuve de (?)ABCabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcm3 : rk(A :: B :: C :: ab :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABCabbcM3 : rk(A :: B :: C :: ab :: bc :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: B :: C :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: bc :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: C :: bc :: nil) (B :: nil) 2 2 1 HABabMtmp HBCbcMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HABCabbcM : rk(A :: B :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabbcm : rk(A :: B :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCabbceq HABCabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcm2 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcm4 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbc requis par la preuve de (?)ACabbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabbcm2 : rk(A :: C :: ab :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabbcmtmp : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApabbceq HABCApabbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: bc :: nil) (B :: Ap :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabbcmtmp;try rewrite HT2 in HABCApabbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: bc :: nil) (nil) 4 0 2 HABCApabbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc ::  de rang :  3 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcm3 : rk(A :: C :: ab :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcmtmp : rk(A :: B :: C :: ab :: bc :: nil) >= 3) by (solve_hyps_min HABCabbceq HABCabbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcmtmp;try rewrite HT2 in HABCabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACabbcM3 : rk(A :: C :: ab :: bc :: nil) <= 3).
{
	assert(HABCabbceq : rk(A :: B :: C :: ab :: bc :: nil) = 3) by (apply LABCabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcMtmp : rk(A :: B :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HABCabbceq HABCabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: C :: ab :: bc :: nil) (A :: B :: C :: ab :: bc :: nil) 3 3 HABCabbcMtmp Hcomp Hincl);apply HT.
}

assert(HACabbcM : rk(A :: C :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabbcm : rk(A :: C :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HACabbceq HACabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabbc *)
(* dans la couche 0 *)
Lemma LOoABCApabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbc requis par la preuve de (?)OoABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbc requis par la preuve de (?)ABCApabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcm2 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcm4 : rk(A :: B :: C :: Ap :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) = 4) by (apply LOoABCApabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabbceq HOoABCApabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcmtmp;try rewrite HT2 in HOoABCApabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabbcM : rk(A :: B :: C :: Ap :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabbcm : rk(A :: B :: C :: Ap :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCApabbceq HABCApabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpabbc *)
(* dans la couche 0 *)
Lemma LApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpabbcm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpabbcm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpabbcm2 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpabbcm3 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: nil) 4 1 2 HABCApBpCpabbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpabbcm4 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpabbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpCpabbc requis par la preuve de (?)ApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpCpabbcm2 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Ap :: Cp ::  de rang :  2 et 2 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HApBpCpabbcm3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HACApBpCpabbcmtmp : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HACApBpCpabbceq HACApBpCpabbcm4).
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hincl : incl (Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: C :: Ap :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApBpCpabbcmtmp;try rewrite HT2 in HACApBpCpabbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: Cp :: nil) 4 2 3 HACApBpCpabbcmtmp HApCpmtmp HACApCpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApBpCpabbcM3 : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBpCpbcMtmp : rk(Bp :: Cp :: bc :: nil) <= 2) by (solve_hyps_max HBpCpbceq HBpCpbcM2).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Cp :: bc :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Cp :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Cp :: bc :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpCpbcMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApBpCpabbcM : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpCpabbcm : rk(Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApBpCpabbceq HApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm2 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabbc requis par la preuve de (?)ApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabbcm2 : rk(Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ab :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabbcm3 : rk(Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabbceq HABApCpabbcm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabbcmtmp;try rewrite HT2 in HABApCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabbcM3 : rk(Ap :: Cp :: ab :: bc :: nil) <= 3).
{
	assert(HApBpCpabbceq : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) = 3) by (apply LApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpCpabbcMtmp : rk(Ap :: Bp :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApBpCpabbceq HApBpCpabbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Bp :: Cp :: ab :: bc :: nil) 3 3 HApBpCpabbcMtmp Hcomp Hincl);apply HT.
}

assert(HApCpabbcM : rk(Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabbcm : rk(Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabbceq HApCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabbc requis par la preuve de (?)ABApCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm2 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabbcm3 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabbcm4 : rk(A :: B :: Ap :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabbcM : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabbcm : rk(A :: B :: Ap :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabbceq HABApCpabbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApBpCpabbc *)
(* dans constructLemma(), requis par LABCApBpCpabbc *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpabbc requis par la preuve de (?)OoABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpabbcm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpabbcM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpabbcm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApBpCpabbc requis par la preuve de (?)ABCApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApBpCpabbcm2 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApBpCpabbcm4 : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpCpabbceq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LOoABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpabbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpabbceq HOoABCApBpCpabbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpabbcmtmp;try rewrite HT2 in HOoABCApBpCpabbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApBpCpabbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApBpCpabbcM : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApBpCpabbcm : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApBpCpabbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApBpCpabbc requis par la preuve de (?)ACApBpCpabbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApBpCpabbcm2 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApBpCpabbcm3 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApBpCpabbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (Ap :: nil) 4 1 2 HABCApBpCpabbcmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HACApBpCpabbcm4 : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HABCApBpCpabbceq : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) = 4) by (apply LABCApBpCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApBpCpabbcmtmp : rk(A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) >= 4) by (solve_hyps_min HABCApBpCpabbceq HABCApBpCpabbcm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApBpCpabbcmtmp;try rewrite HT2 in HABCApBpCpabbcmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (A :: C :: Ap :: Bp :: Cp :: ab :: bc :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HABCApBpCpabbcmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HACApBpCpabbcM : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApBpCpabbcm : rk(A :: C :: Ap :: Bp :: Cp :: ab :: bc ::  nil) >= 1) by (solve_hyps_min HACApBpCpabbceq HACApBpCpabbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacbcm2 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacbcm4 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacbcmtmp;try rewrite HT2 in HOoABCApacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacbc requis par la preuve de (?)ACacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacbcm2 : rk(A :: C :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacbcmtmp : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApacbceq HABCApacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: bc :: nil) (B :: Ap :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacbcmtmp;try rewrite HT2 in HABCApacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: bc :: nil) (nil) 4 0 2 HABCApacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HACacbcM3 : rk(A :: C :: ac :: bc :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (bc :: nil) (nil) 2 1 0 HACacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacbcm3 : rk(A :: C :: ac :: bc :: nil) >= 3).
{
	assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: bc :: nil) (A :: C :: ac :: bc :: nil) 3 3 HACbcmtmp Hcomp Hincl);apply HT.
}

assert(HACacbcM : rk(A :: C :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacbcm : rk(A :: C :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACacbceq HACacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacbc *)
(* dans la couche 0 *)
Lemma LOoABCApacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacbc requis par la preuve de (?)OoABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacbcM : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacbcm : rk(Oo :: A :: B :: C :: Ap :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacbc requis par la preuve de (?)ABCApacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacbcm2 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacbcm4 : rk(A :: B :: C :: Ap :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacbceq : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) = 4) by (apply LOoABCApacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApacbceq HOoABCApacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacbcmtmp;try rewrite HT2 in HOoABCApacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacbcM : rk(A :: B :: C :: Ap :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacbcm : rk(A :: B :: C :: Ap :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApacbceq HABCApacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpacbc *)
(* dans constructLemma(), requis par LBCApCpacbc *)
(* dans constructLemma(), requis par LABCApCpacbc *)
(* dans la couche 0 *)
Lemma LOoABCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpacbc requis par la preuve de (?)OoABCApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpacbcm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpacbcM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpacbcm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApCpacbc requis par la preuve de (?)ABCApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApCpacbc requis par la preuve de (?)ABCApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApCpacbcm2 : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApCpacbcm4 : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApCpacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApCpacbcM : rk(A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApCpacbcm : rk(A :: B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApCpacbceq HABCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApCpacbc requis par la preuve de (?)BCApCpacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApCpacbcm3 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpacbceq : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LOoABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApCpacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApCpacbceq HOoABCApCpacbcm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpacbcmtmp;try rewrite HT2 in HOoABCApCpacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (Ap :: nil) 4 1 2 HOoABCApCpacbcmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HBCApCpacbcm4 : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HABCApCpacbceq : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LABCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApCpacbcmtmp : rk(A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApCpacbceq HABCApCpacbcm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Cp :: ac :: bc :: nil) (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: B :: C :: Ap :: Cp :: ac :: bc :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (B :: C :: Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApCpacbcmtmp;try rewrite HT2 in HABCApCpacbcmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (B :: C :: Ap :: Cp :: ac :: bc :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HABCApCpacbcmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HBCApCpacbcM : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCApCpacbcm : rk(B :: C :: Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacbc requis par la preuve de (?)ApCpacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpacbcm2 : rk(Ap :: Cp :: ac :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ac :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApCpacbcM3 : rk(Ap :: Cp :: ac :: bc :: nil) <= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HbcMtmp : rk(bc :: nil) <= 1) by (solve_hyps_max Hbceq HbcM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Cp :: ac :: nil) (bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ac :: nil) ++ (bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (bc :: nil) (nil) 2 1 0 HApCpacMtmp HbcMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: C :: Ap :: Cp :: ac :: bc ::  de rang :  4 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HApCpacbcm3 : rk(Ap :: Cp :: ac :: bc :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCApCpacbceq : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) = 4) by (apply LBCApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApCpacbcmtmp : rk(B :: C :: Ap :: Cp :: ac :: bc :: nil) >= 4) by (solve_hyps_min HBCApCpacbceq HBCApCpacbcm4).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: Cp :: ac :: bc :: nil) (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: Ap :: Cp :: ac :: bc :: nil) ((B :: C :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApCpacbcmtmp;try rewrite HT2 in HBCApCpacbcmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (bc :: nil) 4 1 2 HBCApCpacbcmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HApCpacbcM : rk(Ap :: Cp :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacbcm : rk(Ap :: Cp :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpacbceq HApCpacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans constructLemma(), requis par LAabacbc *)
(* dans la couche 0 *)
Lemma LACabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HACabacbcM3 : rk(A :: C :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HACabbceq : rk(A :: C :: ab :: bc :: nil) = 3) by (apply LACabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabbcMtmp : rk(A :: C :: ab :: bc :: nil) <= 3) by (solve_hyps_max HACabbceq HACabbcM3).
	assert(HACacbceq : rk(A :: C :: ac :: bc :: nil) = 3) by (apply LACacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacbcMtmp : rk(A :: C :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACacbceq HACacbcM3).
	assert(HACbceq : rk(A :: C :: bc :: nil) = 3) by (apply LACbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACbcmtmp : rk(A :: C :: bc :: nil) >= 3) by (solve_hyps_min HACbceq HACbcm3).
	assert(Hincl : incl (A :: C :: bc :: nil) (list_inter (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ab :: bc :: A :: C :: ac :: bc :: nil) ((A :: C :: ab :: bc :: nil) ++ (A :: C :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ab :: bc :: nil) (A :: C :: ac :: bc :: nil) (A :: C :: bc :: nil) 3 3 3 HACabbcMtmp HACacbcMtmp HACbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HACabacbcM : rk(A :: C :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcm : rk(A :: C :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HACabacbceq HACabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabacbc requis par la preuve de (?)OoABApabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabacbc requis par la preuve de (?)OoABApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcm2 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabacbcm3 : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabacbc requis par la preuve de (?)ABabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabacbcm2 : rk(A :: B :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabacbcmtmp : rk(Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HOoABApabacbceq HOoABApabacbcm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ac :: bc :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabacbcmtmp;try rewrite HT2 in HOoABApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ac :: bc :: nil) (A :: B :: nil) 3 2 3 HOoABApabacbcmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aabacbc requis par la preuve de (?)Aabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ac :: bc ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabacbcm2 : rk(A :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabacbcmtmp : rk(A :: B :: ab :: ac :: bc :: nil) >= 2) by (solve_hyps_min HABabacbceq HABabacbcm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabacbcmtmp;try rewrite HT2 in HABabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ac :: bc :: nil) (A :: ab :: nil) 2 2 2 HABabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAabacbcm3 : rk(A :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: A :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (A :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ab :: ac :: bc :: nil) (A :: ac :: nil) 3 2 2 HACabacbcmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabacbcM3 : rk(A :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HACabacbceq : rk(A :: C :: ab :: ac :: bc :: nil) = 3) by (apply LACabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabacbcMtmp : rk(A :: C :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HACabacbceq HACabacbcM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: ac :: bc :: nil) (A :: C :: ab :: ac :: bc :: nil) 3 3 HACabacbcMtmp Hcomp Hincl);apply HT.
}

assert(HAabacbcM : rk(A :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabacbcm : rk(A :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAabacbceq HAabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans la couche 0 *)
Lemma LApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ab :: ac :: bc ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm2 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpabacbc requis par la preuve de (?)ApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpabacbcm2 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApCpabacbcm3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: nil) 4 1 2 HABApCpabacbcmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApCpabacbcM3 : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3).
{
	assert(HApCpabbceq : rk(Ap :: Cp :: ab :: bc :: nil) = 3) by (apply LApCpabbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpabbcMtmp : rk(Ap :: Cp :: ab :: bc :: nil) <= 3) by (solve_hyps_max HApCpabbceq HApCpabbcM3).
	assert(HApCpacbceq : rk(Ap :: Cp :: ac :: bc :: nil) = 3) by (apply LApCpacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpacbcMtmp : rk(Ap :: Cp :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpacbceq HApCpacbcM3).
	assert(HApCpbceq : rk(Ap :: Cp :: bc :: nil) = 3) by (apply LApCpbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpbcmtmp : rk(Ap :: Cp :: bc :: nil) >= 3) by (solve_hyps_min HApCpbceq HApCpbcm3).
	assert(Hincl : incl (Ap :: Cp :: bc :: nil) (list_inter (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ab :: bc :: Ap :: Cp :: ac :: bc :: nil) ((Ap :: Cp :: ab :: bc :: nil) ++ (Ap :: Cp :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ab :: bc :: nil) (Ap :: Cp :: ac :: bc :: nil) (Ap :: Cp :: bc :: nil) 3 3 3 HApCpabbcMtmp HApCpacbcMtmp HApCpbcmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApCpabacbcM : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpabacbcm : rk(Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HApCpabacbceq HApCpabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labacbc *)
(* dans constructLemma(), requis par LAApCpabacbc *)
(* dans la couche 0 *)
Lemma LABApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApCpabacbc requis par la preuve de (?)ABApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm2 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApCpabacbcm3 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApCpabacbcm4 : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HABApCpabacbcM : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApCpabacbcm : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpabacbc requis par la preuve de (?)AApCpabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpabacbcm2 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpabacbcm3 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: Cp :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApCpabacbcm4 : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApCpabacbceq : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LABApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpabacbcmtmp : rk(A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABApCpabacbceq HABApCpabacbcm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApCpabacbcmtmp;try rewrite HT2 in HABApCpabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: nil) 4 2 2 HABApCpabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HAApCpabacbcM : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpabacbcm : rk(A :: Ap :: Cp :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbc requis par la preuve de (?)ABCabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcm3 : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: nil) (A :: nil) 4 1 2 HOoABCApabacbcmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbc requis par la preuve de (?)ACabacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcm2 : rk(A :: C :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HABCApabacbceq HABCApabacbcm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcmtmp;try rewrite HT2 in HABCApabacbcmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: nil) (nil) 4 0 2 HABCApabacbcmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcm3 : rk(A :: C :: ab :: ac :: bc :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcmtmp : rk(A :: B :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HABCabacbceq HABCabacbcm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcmtmp;try rewrite HT2 in HABCabacbcmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abacbc requis par la preuve de (?)abacbc pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcm2 : rk(ab :: ac :: bc :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcmtmp : rk(A :: C :: ab :: ac :: bc :: nil) >= 3) by (solve_hyps_min HACabacbceq HACabacbcm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: nil) (A :: C :: ac :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcmtmp;try rewrite HT2 in HACabacbcmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: nil) (ac :: nil) 3 1 2 HACabacbcmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabacbcM2 : rk(ab :: ac :: bc :: nil) <= 2).
{
	assert(HAabacbceq : rk(A :: ab :: ac :: bc :: nil) = 3) by (apply LAabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabacbcMtmp : rk(A :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HAabacbceq HAabacbcM3).
	assert(HApCpabacbceq : rk(Ap :: Cp :: ab :: ac :: bc :: nil) = 3) by (apply LApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpabacbcMtmp : rk(Ap :: Cp :: ab :: ac :: bc :: nil) <= 3) by (solve_hyps_max HApCpabacbceq HApCpabacbcM3).
	assert(HAApCpabacbceq : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) = 4) by (apply LAApCpabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpabacbcmtmp : rk(A :: Ap :: Cp :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HAApCpabacbceq HAApCpabacbcm4).
	assert(Hincl : incl (ab :: ac :: bc :: nil) (list_inter (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ab :: ac :: bc :: nil) (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ac :: bc :: Ap :: Cp :: ab :: ac :: bc :: nil) ((A :: ab :: ac :: bc :: nil) ++ (Ap :: Cp :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpabacbcmtmp;try rewrite HT2 in HAApCpabacbcmtmp.
	assert(HT := rule_3 (A :: ab :: ac :: bc :: nil) (Ap :: Cp :: ab :: ac :: bc :: nil) (ab :: ac :: bc :: nil) 3 3 4 HAabacbcMtmp HApCpabacbcMtmp HAApCpabacbcmtmp Hincl);apply HT.
}


assert(HabacbcM : rk(ab :: ac :: bc ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habacbceq HabacbcM3).
assert(Habacbcm : rk(ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min Habacbceq Habacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbc *)
(* dans la couche 0 *)
Lemma LOoABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbc requis par la preuve de (?)OoABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbc : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbc requis par la preuve de (?)ABCApabacbc pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbceq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) = 4) by (apply LOoABCApabacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) >= 4) by (solve_hyps_min HOoABCApabacbceq HOoABCApabacbcm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcmtmp;try rewrite HT2 in HOoABCApabacbcmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabacbcM : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcm : rk(A :: B :: C :: Ap :: ab :: ac :: bc ::  nil) >= 1) by (solve_hyps_min HABCApabacbceq HABCApabacbcm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoD *)
(* dans la couche 0 *)
Lemma LOoD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)OoD pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm2 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm3 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDmtmp : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3) by (solve_hyps_min HOoABApDeq HOoABApDm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDmtmp;try rewrite HT2 in HOoABApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil) (A :: B :: nil) 3 2 3 HOoABApDmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour OoD requis par la preuve de (?)OoD pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 5*)
assert(HOoDm2 : rk(Oo :: D :: nil) >= 2).
{
	assert(HABDMtmp : rk(A :: B :: D :: nil) <= 3) by (solve_hyps_max HABDeq HABDM3).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 3 HOoABDmtmp HDmtmp HABDMtmp Hincl);apply HT.
}

assert(HOoDM : rk(Oo :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoDeq HOoDM2).
assert(HOoDm : rk(Oo :: D ::  nil) >= 1) by (solve_hyps_min HOoDeq HOoDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour AD requis par la preuve de (?)AD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : A :: Ap :: D ::  de rang :  3 et 3 	 AiB : A ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HADm2 : rk(A :: D :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (A :: Ap :: nil) (A :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: nil) (A :: Ap :: A :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: A :: D :: nil) ((A :: Ap :: nil) ++ (A :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDmtmp;try rewrite HT2 in HAApDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (A :: D :: nil) (A :: nil) 3 1 2 HAApDmtmp HAmtmp HAApMtmp Hincl); apply HT.
}

assert(HADM : rk(A :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HADeq HADM2).
assert(HADm : rk(A :: D ::  nil) >= 1) by (solve_hyps_min HADeq HADm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoAD *)
(* dans la couche 0 *)
Lemma LBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BD requis par la preuve de (?)BD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: Bp :: D ::  de rang :  3 et 3 	 AiB : B ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HBDm2 : rk(B :: D :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: Bp :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: D :: nil) (B :: Bp :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: B :: D :: nil) ((B :: Bp :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDmtmp;try rewrite HT2 in HBBpDmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (B :: D :: nil) (B :: nil) 3 1 2 HBBpDmtmp HBmtmp HBBpMtmp Hincl); apply HT.
}

assert(HBDM : rk(B :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBDeq HBDM2).
assert(HBDm : rk(B :: D ::  nil) >= 1) by (solve_hyps_min HBDeq HBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpD requis par la preuve de (?)OoAD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpD requis par la preuve de (?)OoABCBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDm4 : rk(Oo :: A :: B :: C :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAD requis par la preuve de (?)OoAD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoADm2 : rk(Oo :: A :: D :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpDmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCBpDeq HOoABCBpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: D :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDmtmp;try rewrite HT2 in HOoABCBpDmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: nil) (Oo :: nil) 4 1 3 HOoABCBpDmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: -4 -2 et 4*)
assert(HOoADm3 : rk(Oo :: A :: D :: nil) >= 3).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDMtmp : rk(B :: D :: nil) <= 2) by (solve_hyps_max HBDeq HBDM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: A :: D :: nil) (B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: A :: D :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: B :: D :: nil) ((Oo :: A :: D :: nil) ++ (B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_2 (Oo :: A :: D :: nil) (B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HBDMtmp Hincl);apply HT.
}

assert(HOoADM : rk(Oo :: A :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoADeq HOoADM3).
assert(HOoADm : rk(Oo :: A :: D ::  nil) >= 1) by (solve_hyps_min HOoADeq HOoADm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoBD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBD requis par la preuve de (?)OoBD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBDm2 : rk(Oo :: B :: D :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: D :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApDmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoBDm3 : rk(Oo :: B :: D :: nil) >= 3).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (A :: D :: Oo :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: B :: D :: nil) ((A :: D :: nil) ++ (Oo :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HADMtmp Hincl); apply HT.
}

assert(HOoBDM : rk(Oo :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBDeq HOoBDM3).
assert(HOoBDm : rk(Oo :: B :: D ::  nil) >= 1) by (solve_hyps_min HOoBDeq HOoBDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApD requis par la preuve de (?)ABD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApD requis par la preuve de (?)OoABApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm2 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDm3 : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABD requis par la preuve de (?)ABD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDm2 : rk(A :: B :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDmtmp : rk(Oo :: A :: B :: Ap :: D :: nil) >= 3) by (solve_hyps_min HOoABApDeq HOoABApDm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDmtmp;try rewrite HT2 in HOoABApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: nil) (A :: B :: nil) 3 2 3 HOoABApDmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HABDm3 : rk(A :: B :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: B :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: nil) (Oo :: D :: A :: B :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: B :: D :: nil) ((Oo :: D :: nil) ++ (A :: B :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDmtmp;try rewrite HT2 in HOoABDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: B :: D :: nil) (D :: nil) 4 1 2 HOoABDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HABDM : rk(A :: B :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABDeq HABDM3).
assert(HABDm : rk(A :: B :: D ::  nil) >= 1) by (solve_hyps_min HABDeq HABDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CD requis par la preuve de (?)CD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : C :: Cp :: D ::  de rang :  3 et 3 	 AiB : C ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 2 et 2 *)
assert(HCDm2 : rk(C :: D :: nil) >= 2).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HCCpDmtmp : rk(C :: Cp :: D :: nil) >= 3) by (solve_hyps_min HCCpDeq HCCpDm3).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (C :: Cp :: nil) (C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: D :: nil) (C :: Cp :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: C :: D :: nil) ((C :: Cp :: nil) ++ (C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCCpDmtmp;try rewrite HT2 in HCCpDmtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (C :: D :: nil) (C :: nil) 3 1 2 HCCpDmtmp HCmtmp HCCpMtmp Hincl); apply HT.
}

assert(HCDM : rk(C :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCDeq HCDM2).
assert(HCDm : rk(C :: D ::  nil) >= 1) by (solve_hyps_min HCDeq HCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCD requis par la preuve de (?)OoCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCDm2 : rk(Oo :: C :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApDmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HOoCDm3 : rk(Oo :: C :: D :: nil) >= 3).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (Oo :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (A :: D :: Oo :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: Oo :: C :: D :: nil) ((A :: D :: nil) ++ (Oo :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (Oo :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HADMtmp Hincl); apply HT.
}

assert(HOoCDM : rk(Oo :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCDeq HOoCDM3).
assert(HOoCDm : rk(Oo :: C :: D ::  nil) >= 1) by (solve_hyps_min HOoCDeq HOoCDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApD requis par la preuve de (?)ACD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDm2 : rk(A :: B :: C :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACD requis par la preuve de (?)ACD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACDm2 : rk(A :: C :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApDmtmp : rk(A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HABCApDeq HABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: D :: nil) (B :: Ap :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: D :: nil) ((B :: Ap :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDmtmp;try rewrite HT2 in HABCApDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: D :: nil) (nil) 4 0 2 HABCApDmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: D ::   de rang : 2 et 2 *)
assert(HACDm3 : rk(A :: C :: D :: nil) >= 3).
{
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDMtmp : rk(Oo :: D :: nil) <= 2) by (solve_hyps_max HOoDeq HOoDM2).
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: nil) (A :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: nil) (Oo :: D :: A :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: A :: C :: D :: nil) ((Oo :: D :: nil) ++ (A :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDmtmp;try rewrite HT2 in HOoACDmtmp.
	assert(HT := rule_4 (Oo :: D :: nil) (A :: C :: D :: nil) (D :: nil) 4 1 2 HOoACDmtmp HDmtmp HOoDMtmp Hincl); apply HT.
}

assert(HACDM : rk(A :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACDeq HACDM3).
assert(HACDm : rk(A :: C :: D ::  nil) >= 1) by (solve_hyps_min HACDeq HACDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApD requis par la preuve de (?)BCD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCD requis par la preuve de (?)BCD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCDm2 : rk(B :: C :: D :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: D :: nil) (nil) 4 0 2 HOoABCApDmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: -4 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: D ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : A :: D ::   de rang : 2 et 2 *)
assert(HBCDm3 : rk(B :: C :: D :: nil) >= 3).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADMtmp : rk(A :: D :: nil) <= 2) by (solve_hyps_max HADeq HADM2).
	assert(HABCDmtmp : rk(A :: B :: C :: D :: nil) >= 4) by (solve_hyps_min HABCDeq HABCDm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (A :: D :: nil) (B :: C :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: nil) (A :: D :: B :: C :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: B :: C :: D :: nil) ((A :: D :: nil) ++ (B :: C :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDmtmp;try rewrite HT2 in HABCDmtmp.
	assert(HT := rule_4 (A :: D :: nil) (B :: C :: D :: nil) (D :: nil) 4 1 2 HABCDmtmp HDmtmp HADMtmp Hincl); apply HT.
}

assert(HBCDM : rk(B :: C :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCDeq HBCDM3).
assert(HBCDm : rk(B :: C :: D ::  nil) >= 1) by (solve_hyps_min HBCDeq HBCDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApD *)
(* dans la couche 0 *)
Lemma LOoABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApD requis par la preuve de (?)OoABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDm4 : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDM : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDm : rk(Oo :: A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApDeq HOoABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApD requis par la preuve de (?)ABCApD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDm2 : rk(A :: B :: C :: Ap :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDm4 : rk(A :: B :: C :: Ap :: D :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDeq : rk(Oo :: A :: B :: C :: Ap :: D :: nil) = 4) by (apply LOoABCApD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: nil) >= 4) by (solve_hyps_min HOoABCApDeq HOoABCApDm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDmtmp;try rewrite HT2 in HOoABCApDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: D :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApDM : rk(A :: B :: C :: Ap :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDm : rk(A :: B :: C :: Ap :: D ::  nil) >= 1) by (solve_hyps_min HABCApDeq HABCApDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpD requis par la preuve de (?)BpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: Bp :: D ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HBpDm2 : rk(Bp :: D :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBBpDmtmp : rk(B :: Bp :: D :: nil) >= 3) by (solve_hyps_min HBBpDeq HBBpDm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: D :: nil) (B :: Bp :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bp :: D :: nil) ((B :: Bp :: nil) ++ (Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDmtmp;try rewrite HT2 in HBBpDmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (Bp :: D :: nil) (Bp :: nil) 3 1 2 HBBpDmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

assert(HBpDM : rk(Bp :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpDeq HBpDM2).
assert(HBpDm : rk(Bp :: D ::  nil) >= 1) by (solve_hyps_min HBpDeq HBpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpD *)
(* dans la couche 0 *)
Lemma LOoABBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpD requis par la preuve de (?)OoABApBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpD requis par la preuve de (?)OoABApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDm2 : rk(Oo :: A :: B :: Ap :: Bp :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDm3 : rk(Oo :: A :: B :: Ap :: Bp :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpD requis par la preuve de (?)OoABBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: D ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABBpDm2 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpDmtmp : rk(Oo :: A :: B :: Ap :: Bp :: D :: nil) >= 3) by (solve_hyps_min HOoABApBpDeq HOoABApBpDm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpDmtmp;try rewrite HT2 in HOoABApBpDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApBpDmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDm3 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDm4 : rk(Oo :: A :: B :: Bp :: D :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABBpDM : rk(Oo :: A :: B :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpDm : rk(Oo :: A :: B :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABBpDeq HOoABBpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpD *)
(* dans la couche 0 *)
Lemma LOoBBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpD requis par la preuve de (?)OoBBpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpD requis par la preuve de (?)OoBBpD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoBBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpD requis par la preuve de (?)OoBBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpDm2 : rk(Oo :: B :: Bp :: D :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDmtmp;try rewrite HT2 in HOoABCApBpDmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpDM3 : rk(Oo :: B :: Bp :: D :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: D :: nil) (Oo :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: D :: nil) ((Oo :: B :: Bp :: nil) ++ (D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (D :: nil) (nil) 2 1 0 HOoBBpMtmp HDMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpDm3 : rk(Oo :: B :: Bp :: D :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBBpDM : rk(Oo :: B :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpDm : rk(Oo :: B :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoBBpDeq HOoBBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABpD requis par la preuve de (?)ABpD pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABpD requis par la preuve de (?)ABpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDm2 : rk(A :: Bp :: D :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: D :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABpDm3 : rk(A :: Bp :: D :: nil) >= 3).
{
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoABBpDeq : rk(Oo :: A :: B :: Bp :: D :: nil) = 4) by (apply LOoABBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpDmtmp : rk(Oo :: A :: B :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABBpDeq HOoABBpDm4).
	assert(HBpDeq : rk(Bp :: D :: nil) = 2) by (apply LBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDmtmp : rk(Bp :: D :: nil) >= 2) by (solve_hyps_min HBpDeq HBpDm2).
	assert(Hincl : incl (Bp :: D :: nil) (list_inter (A :: Bp :: D :: nil) (Oo :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: nil) (A :: Bp :: D :: Oo :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: D :: Oo :: B :: Bp :: D :: nil) ((A :: Bp :: D :: nil) ++ (Oo :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDmtmp;try rewrite HT2 in HOoABBpDmtmp.
	assert(HT := rule_2 (A :: Bp :: D :: nil) (Oo :: B :: Bp :: D :: nil) (Bp :: D :: nil) 4 2 3 HOoABBpDmtmp HBpDmtmp HOoBBpDMtmp Hincl);apply HT.
}

assert(HABpDM : rk(A :: Bp :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABpDeq HABpDM3).
assert(HABpDm : rk(A :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HABpDeq HABpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCBpD *)
(* dans la couche 0 *)
Lemma LOoBCBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Bp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCBpD requis par la preuve de (?)OoBCBpD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoBCBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCBpD requis par la preuve de (?)OoBCBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCBpD requis par la preuve de (?)OoBCBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDm2 : rk(Oo :: B :: C :: Bp :: D :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) (A :: Ap :: Oo :: B :: C :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Bp :: D :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDmtmp;try rewrite HT2 in HOoABCApBpDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: nil) (nil) 4 0 2 HOoABCApBpDmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCBpDm3 : rk(Oo :: B :: C :: Bp :: D :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApBpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Bp :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDmtmp;try rewrite HT2 in HOoABCApBpDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Bp :: D :: nil) (Oo :: nil) 4 1 2 HOoABCApBpDmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HOoBCBpDM3 : rk(Oo :: B :: C :: Bp :: D :: nil) <= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBBpDeq : rk(Oo :: B :: Bp :: D :: nil) = 3) by (apply LOoBBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDMtmp : rk(Oo :: B :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBBpDeq HOoBBpDM3).
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hincl : incl (Oo :: B :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: B :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Bp :: D :: nil) (Oo :: B :: C :: D :: Oo :: B :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: B :: Bp :: D :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: B :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: D :: nil) (Oo :: B :: Bp :: D :: nil) (Oo :: B :: D :: nil) 3 3 3 HOoBCDMtmp HOoBBpDMtmp HOoBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBCBpDM : rk(Oo :: B :: C :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCBpDm : rk(Oo :: B :: C :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoBCBpDeq HOoBCBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpD requis par la preuve de (?)OoCBpD pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpabD requis par la preuve de (?)OoCBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabD requis par la preuve de (?)OoACApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabD requis par la preuve de (?)OoABCApBpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabD requis par la preuve de (?)OoACApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabD requis par la preuve de (?)OoACApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabD requis par la preuve de (?)OoACApBpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabD requis par la preuve de (?)OoBCApBpabD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDeq HOoBCApBpabDm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDmtmp;try rewrite HT2 in HOoBCApBpabDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoACApBpabDeq HOoACApBpabDm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDmtmp;try rewrite HT2 in HOoACApBpabDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpD requis par la preuve de (?)OoCBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoCBpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpD requis par la preuve de (?)OoCBpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpDm2 : rk(Oo :: C :: Bp :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDmtmp;try rewrite HT2 in HOoABCApBpDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : C :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCBpDm3 : rk(Oo :: C :: Bp :: D :: nil) >= 3).
{
	assert(HCApBpabeq : rk(C :: Ap :: Bp :: ab :: nil) = 3) by (apply LCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApBpabMtmp : rk(C :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HCApBpabeq HCApBpabM3).
	assert(HOoCApBpabDmtmp : rk(Oo :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoCApBpabDeq HOoCApBpabDm4).
	assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Bp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: ab :: D :: nil) (C :: Ap :: Bp :: ab :: Oo :: C :: Bp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: Oo :: C :: Bp :: D :: nil) ((C :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Bp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpabDmtmp;try rewrite HT2 in HOoCApBpabDmtmp.
	assert(HT := rule_4 (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Bp :: D :: nil) (C :: Bp :: nil) 4 2 3 HOoCApBpabDmtmp HCBpmtmp HCApBpabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCBpDM3 : rk(Oo :: C :: Bp :: D :: nil) <= 3).
{
	assert(HOoBCBpDeq : rk(Oo :: B :: C :: Bp :: D :: nil) = 3) by (apply LOoBCBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpDMtmp : rk(Oo :: B :: C :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoBCBpDeq HOoBCBpDM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Bp :: D :: nil) (Oo :: B :: C :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: C :: Bp :: D :: nil) (Oo :: B :: C :: Bp :: D :: nil) 3 3 HOoBCBpDMtmp Hcomp Hincl);apply HT.
}

assert(HOoCBpDM : rk(Oo :: C :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpDm : rk(Oo :: C :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoCBpDeq HOoCBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpD requis par la preuve de (?)OoABCBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDm4 : rk(Oo :: A :: B :: C :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDM : rk(Oo :: A :: B :: C :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDm : rk(Oo :: A :: B :: C :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCBpDeq HOoABCBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpD requis par la preuve de (?)OoABCApBpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDeq HOoABCApBpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: D ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpD requis par la preuve de (?)CpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : C :: Cp :: D ::  de rang :  3 et 3 	 AiB : Cp ::  de rang :  1 et 1 	 A : C :: Cp ::   de rang : 2 et 2 *)
assert(HCpDm2 : rk(Cp :: D :: nil) >= 2).
{
	assert(HCCpMtmp : rk(C :: Cp :: nil) <= 2) by (solve_hyps_max HCCpeq HCCpM2).
	assert(HCCpDmtmp : rk(C :: Cp :: D :: nil) >= 3) by (solve_hyps_min HCCpDeq HCCpDm3).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (C :: Cp :: nil) (Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Cp :: D :: nil) (C :: Cp :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Cp :: Cp :: D :: nil) ((C :: Cp :: nil) ++ (Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCCpDmtmp;try rewrite HT2 in HCCpDmtmp.
	assert(HT := rule_4 (C :: Cp :: nil) (Cp :: D :: nil) (Cp :: nil) 3 1 2 HCCpDmtmp HCpmtmp HCCpMtmp Hincl); apply HT.
}

assert(HCpDM : rk(Cp :: D ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpDeq HCpDM2).
assert(HCpDm : rk(Cp :: D ::  nil) >= 1) by (solve_hyps_min HCpDeq HCpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpD *)
(* dans la couche 0 *)
Lemma LOoACCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Cp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpD requis par la preuve de (?)OoACCpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpD requis par la preuve de (?)OoABCBpCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpD requis par la preuve de (?)OoACCpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpDm2 : rk(Oo :: A :: C :: Cp :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: D :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: D :: nil) (nil) 4 0 2 HOoABCApCpDmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpDm3 : rk(Oo :: A :: C :: Cp :: D :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpDmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCBpCpDeq HOoABCBpCpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: D :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpDmtmp;try rewrite HT2 in HOoABCBpCpDmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: D :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpDmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACCpDm4 : rk(Oo :: A :: C :: Cp :: D :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Cp :: D :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACCpDM : rk(Oo :: A :: C :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpDm : rk(Oo :: A :: C :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoACCpDeq HOoACCpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpD *)
(* dans la couche 0 *)
Lemma LOoCCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpD requis par la preuve de (?)OoCCpD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpD requis par la preuve de (?)OoCCpD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoCCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpD requis par la preuve de (?)OoCCpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpDm2 : rk(Oo :: C :: Cp :: D :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: D :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoCCpDM3 : rk(Oo :: C :: Cp :: D :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: D :: nil) ((Oo :: C :: Cp :: nil) ++ (D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (D :: nil) (nil) 2 1 0 HOoCCpMtmp HDMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCCpDm3 : rk(Oo :: C :: Cp :: D :: nil) >= 3).
{
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: D :: nil) (Oo :: C :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: C :: D :: nil) (Oo :: C :: Cp :: D :: nil) 3 3 HOoCDmtmp Hcomp Hincl);apply HT.
}

assert(HOoCCpDM : rk(Oo :: C :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpDm : rk(Oo :: C :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoCCpDeq HOoCCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpD requis par la preuve de (?)ACpD pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpD requis par la preuve de (?)ACpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDm2 : rk(A :: Cp :: D :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: D :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpDm3 : rk(A :: Cp :: D :: nil) >= 3).
{
	assert(HOoCCpDeq : rk(Oo :: C :: Cp :: D :: nil) = 3) by (apply LOoCCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDMtmp : rk(Oo :: C :: Cp :: D :: nil) <= 3) by (solve_hyps_max HOoCCpDeq HOoCCpDM3).
	assert(HOoACCpDeq : rk(Oo :: A :: C :: Cp :: D :: nil) = 4) by (apply LOoACCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACCpDmtmp : rk(Oo :: A :: C :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoACCpDeq HOoACCpDm4).
	assert(HCpDeq : rk(Cp :: D :: nil) = 2) by (apply LCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDmtmp : rk(Cp :: D :: nil) >= 2) by (solve_hyps_min HCpDeq HCpDm2).
	assert(Hincl : incl (Cp :: D :: nil) (list_inter (A :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: D :: nil) (A :: Cp :: D :: Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: D :: Oo :: C :: Cp :: D :: nil) ((A :: Cp :: D :: nil) ++ (Oo :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpDmtmp;try rewrite HT2 in HOoACCpDmtmp.
	assert(HT := rule_2 (A :: Cp :: D :: nil) (Oo :: C :: Cp :: D :: nil) (Cp :: D :: nil) 4 2 3 HOoACCpDmtmp HCpDmtmp HOoCCpDMtmp Hincl);apply HT.
}

assert(HACpDM : rk(A :: Cp :: D ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpDeq HACpDM3).
assert(HACpDm : rk(A :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HACpDeq HACpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpD *)
(* dans la couche 0 *)
Lemma LOoBCCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Cp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCCpD requis par la preuve de (?)OoBCCpD pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoBCCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCCpD requis par la preuve de (?)OoBCCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCCpD requis par la preuve de (?)OoBCCpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpDm2 : rk(Oo :: B :: C :: Cp :: D :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (A :: Ap :: Oo :: B :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Cp :: D :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil) (nil) 4 0 2 HOoABCApCpDmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCCpDm3 : rk(Oo :: B :: C :: Cp :: D :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Cp :: D :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Cp :: D :: nil) (Oo :: nil) 4 1 2 HOoABCApCpDmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HOoBCCpDM3 : rk(Oo :: B :: C :: Cp :: D :: nil) <= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoCCpDeq : rk(Oo :: C :: Cp :: D :: nil) = 3) by (apply LOoCCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpDMtmp : rk(Oo :: C :: Cp :: D :: nil) <= 3) by (solve_hyps_max HOoCCpDeq HOoCCpDM3).
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hincl : incl (Oo :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: C :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Cp :: D :: nil) (Oo :: B :: C :: D :: Oo :: C :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: C :: Cp :: D :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: C :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: D :: nil) (Oo :: C :: Cp :: D :: nil) (Oo :: C :: D :: nil) 3 3 3 HOoBCDMtmp HOoCCpDMtmp HOoCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBCCpDM : rk(Oo :: B :: C :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCCpDm : rk(Oo :: B :: C :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoBCCpDeq HOoBCCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: D ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpD requis par la preuve de (?)OoBCpD pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCpabD requis par la preuve de (?)OoBCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApCpabD requis par la preuve de (?)OoBCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabD requis par la preuve de (?)OoBApCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabD requis par la preuve de (?)OoABApCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabD requis par la preuve de (?)OoABApCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabD requis par la preuve de (?)OoABApCpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabD requis par la preuve de (?)OoBApCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabD requis par la preuve de (?)OoBApCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabD requis par la preuve de (?)OoBApCpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDm2 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDm3 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDm4 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABApCpabDeq HOoABApCpabDm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDmtmp;try rewrite HT2 in HOoABApCpabDmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabD requis par la preuve de (?)OoBCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabD requis par la preuve de (?)OoBCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabD requis par la preuve de (?)OoBCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabD requis par la preuve de (?)OoABCApCpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabD requis par la preuve de (?)OoBCpabD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDm2 : rk(Oo :: B :: Cp :: ab :: D :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDeq HOoABCApCpabDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDmtmp;try rewrite HT2 in HOoABCApCpabDmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDm3 : rk(Oo :: B :: Cp :: ab :: D :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: D ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDm4 : rk(Oo :: B :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoBApCpabDeq HOoBApCpabDm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: D :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDmtmp;try rewrite HT2 in HOoBApCpabDmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpD requis par la preuve de (?)OoBCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoBCpD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpD requis par la preuve de (?)OoBCpD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpDm2 : rk(Oo :: B :: Cp :: D :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: D :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDmtmp;try rewrite HT2 in HOoABCApCpDmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: Cp :: ab :: D ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoBCpDm3 : rk(Oo :: B :: Cp :: D :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoBCpabDmtmp : rk(Oo :: B :: Cp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoBCpabDeq HOoBCpabDm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: B :: Cp :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: ab :: D :: nil) (Cp :: ab :: Oo :: B :: Cp :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: B :: Cp :: D :: nil) ((Cp :: ab :: nil) ++ (Oo :: B :: Cp :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpabDmtmp;try rewrite HT2 in HOoBCpabDmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: B :: Cp :: D :: nil) (Cp :: nil) 4 1 2 HOoBCpabDmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpDM3 : rk(Oo :: B :: Cp :: D :: nil) <= 3).
{
	assert(HOoBCCpDeq : rk(Oo :: B :: C :: Cp :: D :: nil) = 3) by (apply LOoBCCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCCpDMtmp : rk(Oo :: B :: C :: Cp :: D :: nil) <= 3) by (solve_hyps_max HOoBCCpDeq HOoBCCpDM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Cp :: D :: nil) (Oo :: B :: C :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: Cp :: D :: nil) (Oo :: B :: C :: Cp :: D :: nil) 3 3 HOoBCCpDMtmp Hcomp Hincl);apply HT.
}

assert(HOoBCpDM : rk(Oo :: B :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpDm : rk(Oo :: B :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoBCpDeq HOoBCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpD requis par la preuve de (?)OoABCApCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpDM : rk(Oo :: A :: B :: C :: Ap :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDm : rk(Oo :: A :: B :: C :: Ap :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDeq HOoABCApCpDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpD requis par la preuve de (?)OoABCBpCpD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpDM : rk(Oo :: A :: B :: C :: Bp :: Cp :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpDm : rk(Oo :: A :: B :: C :: Bp :: Cp :: D ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpDeq HOoABCBpCpDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpabD *)
(* dans constructLemma(), requis par LOoACApBpabD *)
(* dans la couche 0 *)
Lemma LOoABCApBpabD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabD requis par la preuve de (?)OoABCApBpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabDM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpabD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ab :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabD requis par la preuve de (?)OoACApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabD requis par la preuve de (?)OoACApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabD requis par la preuve de (?)OoACApBpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) = 4) by (apply LOoABCApBpabD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) = 4) by (apply LOoABCApBpabD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpabDM : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpabDm : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D ::  nil) >= 1) by (solve_hyps_min HOoACApBpabDeq HOoACApBpabDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpabD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: ab :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabD requis par la preuve de (?)OoBCApBpabD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) = 4) by (apply LOoABCApBpabD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabD requis par la preuve de (?)OoCApBpabD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDeq HOoBCApBpabDm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDmtmp;try rewrite HT2 in HOoBCApBpabDmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) = 4) by (apply LOoABCApBpabD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDeq HOoABCApBpabDm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDmtmp;try rewrite HT2 in HOoABCApBpabDmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDeq : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) = 4) by (apply LOoACApBpabD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpabDmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoACApBpabDeq HOoACApBpabDm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDmtmp;try rewrite HT2 in HOoACApBpabDmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

assert(HOoCApBpabDM : rk(Oo :: C :: Ap :: Bp :: ab :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpabDm : rk(Oo :: C :: Ap :: Bp :: ab :: D ::  nil) >= 1) by (solve_hyps_min HOoCApBpabDeq HOoCApBpabDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpabD *)
(* dans constructLemma(), requis par LOoBApCpabD *)
(* dans la couche 0 *)
Lemma LOoABApCpabD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabD requis par la preuve de (?)OoABApCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabD requis par la preuve de (?)OoABApCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabD requis par la preuve de (?)OoABApCpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabDM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabDm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D ::  nil) >= 1) by (solve_hyps_min HOoABApCpabDeq HOoABApCpabDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApCpabD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Cp :: ab :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabD requis par la preuve de (?)OoBApCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabD requis par la preuve de (?)OoBApCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabD requis par la preuve de (?)OoBApCpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDm2 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDm3 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDm4 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) = 4) by (apply LOoABApCpabD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABApCpabDeq HOoABApCpabDm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDmtmp;try rewrite HT2 in HOoABApCpabDmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBApCpabDM : rk(Oo :: B :: Ap :: Cp :: ab :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpabDm : rk(Oo :: B :: Ap :: Cp :: ab :: D ::  nil) >= 1) by (solve_hyps_min HOoBApCpabDeq HOoBApCpabDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpabD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: ab :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabD requis par la preuve de (?)OoBCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabD requis par la preuve de (?)OoBCpabD pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabD requis par la preuve de (?)OoBCpabD pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabD requis par la preuve de (?)OoABCApCpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabD requis par la preuve de (?)OoBCpabD pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: D ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDm2 : rk(Oo :: B :: Cp :: ab :: D :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDeq HOoABCApCpabDm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDmtmp;try rewrite HT2 in HOoABCApCpabDmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDm3 : rk(Oo :: B :: Cp :: ab :: D :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: D ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDm4 : rk(Oo :: B :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDeq : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) = 4) by (apply LOoBApCpabD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApCpabDmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: D :: nil) >= 4) by (solve_hyps_min HOoBApCpabDeq HOoBApCpabDm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: D :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: D :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDmtmp;try rewrite HT2 in HOoBApCpabDmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

assert(HOoBCpabDM : rk(Oo :: B :: Cp :: ab :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpabDm : rk(Oo :: B :: Cp :: ab :: D ::  nil) >= 1) by (solve_hyps_min HOoBCpabDeq HOoBCpabDm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabD : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabD requis par la preuve de (?)OoABCApCpabD pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabDM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabDm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabDeq HOoABCApCpabDm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABDp *)
(* dans la couche 0 *)
Lemma LOoABDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABCCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDDpm4 : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDp requis par la preuve de (?)OoABApDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDp requis par la preuve de (?)OoABApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDDp requis par la preuve de (?)OoABDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABDDpm2 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDDpmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApDDpeq HOoABApDDpm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpmtmp;try rewrite HT2 in HOoABApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: Dp :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApDDpmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDDpm3 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDDpmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCCpDDpeq HOoABCCpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: Dp :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDDpmtmp;try rewrite HT2 in HOoABCCpDDpmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCCpDDpmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABDDpm4 : rk(Oo :: A :: B :: D :: Dp :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: Dp :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABDDpM : rk(Oo :: A :: B :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDDpm : rk(Oo :: A :: B :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABDDpeq HOoABDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDp requis par la preuve de (?)ABDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDp requis par la preuve de (?)ABDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoABApDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDp requis par la preuve de (?)OoABApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDpm2 : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDpm3 : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDp requis par la preuve de (?)ABDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Dp ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDpm2 : rk(A :: B :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDpmtmp : rk(Oo :: A :: B :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApDpeq HOoABApDpm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Dp :: nil) (Oo :: A :: B :: Ap :: A :: B :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDpmtmp;try rewrite HT2 in HOoABApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: Dp :: nil) (A :: B :: nil) 3 2 3 HOoABApDpmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HABDpm3 : rk(A :: B :: Dp :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoABDDpeq : rk(Oo :: A :: B :: D :: Dp :: nil) = 4) by (apply LOoABDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDDpmtmp : rk(Oo :: A :: B :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABDDpeq HOoABDDpm4).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (A :: B :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: Dp :: nil) (A :: B :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Dp :: Oo :: D :: Dp :: nil) ((A :: B :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDDpmtmp;try rewrite HT2 in HOoABDDpmtmp.
	assert(HT := rule_2 (A :: B :: Dp :: nil) (Oo :: D :: Dp :: nil) (Dp :: nil) 4 1 2 HOoABDDpmtmp HDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HABDpM : rk(A :: B :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABDpeq HABDpM3).
assert(HABDpm : rk(A :: B :: Dp ::  nil) >= 1) by (solve_hyps_min HABDpeq HABDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACDp *)
(* dans la couche 0 *)
Lemma LOoACDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoABCBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACDDp requis par la preuve de (?)OoACDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACDDpm2 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (B :: Ap :: Oo :: A :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApDDpmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACDDpm3 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpDDpmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCBpDDpeq HOoABCBpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDDpmtmp;try rewrite HT2 in HOoABCBpDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCBpDDpmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACDDpm4 : rk(Oo :: A :: C :: D :: Dp :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: Dp :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACDDpM : rk(Oo :: A :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDDpm : rk(Oo :: A :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACDDpeq HOoACDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDp requis par la preuve de (?)ACDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ACDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)ABCApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ABCApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDpm2 : rk(A :: B :: C :: Ap :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDpm4 : rk(A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDp requis par la preuve de (?)ACDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACDpm2 : rk(A :: C :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApDpmtmp : rk(A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HABCApDpeq HABCApDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Dp :: nil) (B :: Ap :: A :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Dp :: nil) ((B :: Ap :: nil) ++ (A :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDpmtmp;try rewrite HT2 in HABCApDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Dp :: nil) (nil) 4 0 2 HABCApDpmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HACDpm3 : rk(A :: C :: Dp :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoACDDpeq : rk(Oo :: A :: C :: D :: Dp :: nil) = 4) by (apply LOoACDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACDDpmtmp : rk(Oo :: A :: C :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACDDpeq HOoACDDpm4).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (A :: C :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: Dp :: nil) (A :: C :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Dp :: Oo :: D :: Dp :: nil) ((A :: C :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDDpmtmp;try rewrite HT2 in HOoACDDpmtmp.
	assert(HT := rule_2 (A :: C :: Dp :: nil) (Oo :: D :: Dp :: nil) (Dp :: nil) 4 1 2 HOoACDDpmtmp HDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HACDpM : rk(A :: C :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACDpeq HACDpM3).
assert(HACDpm : rk(A :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HACDpeq HACDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCDp *)
(* dans la couche 0 *)
Lemma LOoBCDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDDp requis par la preuve de (?)OoBCDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoBCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCDDp requis par la preuve de (?)OoBCDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDDp requis par la preuve de (?)OoBCDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDDpm2 : rk(Oo :: B :: C :: D :: Dp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: D :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApDDpmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDDpm3 : rk(Oo :: B :: C :: D :: Dp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApDDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et 4*)
assert(HOoBCDDpM3 : rk(Oo :: B :: C :: D :: Dp :: nil) <= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: Dp :: nil) (Oo :: B :: C :: D :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: D :: Dp :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: D :: nil) (Oo :: D :: Dp :: nil) (Oo :: D :: nil) 3 2 2 HOoBCDMtmp HOoDDpMtmp HOoDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBCDDpM : rk(Oo :: B :: C :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDDpm : rk(Oo :: B :: C :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCDDpeq HOoBCDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDp requis par la preuve de (?)OoBCDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoBCDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCDp requis par la preuve de (?)OoBCDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDp requis par la preuve de (?)OoBCDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDpm2 : rk(Oo :: B :: C :: Dp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil) (nil) 4 0 2 HOoABCApDpmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDpm3 : rk(Oo :: B :: C :: Dp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCDpM3 : rk(Oo :: B :: C :: Dp :: nil) <= 3).
{
	assert(HOoBCDDpeq : rk(Oo :: B :: C :: D :: Dp :: nil) = 3) by (apply LOoBCDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDDpMtmp : rk(Oo :: B :: C :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCDDpeq HOoBCDDpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: C :: Dp :: nil) (Oo :: B :: C :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: C :: Dp :: nil) (Oo :: B :: C :: D :: Dp :: nil) 3 3 HOoBCDDpMtmp Hcomp Hincl);apply HT.
}

assert(HOoBCDpM : rk(Oo :: B :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDpm : rk(Oo :: B :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCDpeq HOoBCDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDp requis par la preuve de (?)OoABCDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDpm4 : rk(Oo :: A :: B :: C :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDpM : rk(Oo :: A :: B :: C :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDpm : rk(Oo :: A :: B :: C :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCDpeq HOoABCDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApDp *)
(* dans la couche 0 *)
Lemma LOoABApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDDp requis par la preuve de (?)OoABApDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDDp requis par la preuve de (?)OoABApDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDDp requis par la preuve de (?)OoABApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpm2 : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpm3 : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDDpm4 : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Ap :: D :: Dp :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApDDpM : rk(Oo :: A :: B :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApDDpm : rk(Oo :: A :: B :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABApDDpeq HOoABApDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABApDp *)
(* dans la couche 0 *)
Lemma LOoAApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDDp requis par la preuve de (?)OoAApDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApDDp requis par la preuve de (?)OoAApDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDDp requis par la preuve de (?)OoAApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDDpm2 : rk(Oo :: A :: Ap :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoAApDDpM3 : rk(Oo :: A :: Ap :: D :: Dp :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (Oo :: D :: Dp :: nil) (Oo :: nil) 2 2 1 HOoAApMtmp HOoDDpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDDpm3 : rk(Oo :: A :: Ap :: D :: Dp :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: Dp :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApDDpM : rk(Oo :: A :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDDpm : rk(Oo :: A :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoAApDDpeq HOoAApDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApDp requis par la preuve de (?)ABApDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApDp requis par la preuve de (?)ABApDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApDp requis par la preuve de (?)ABApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApDpm2 : rk(A :: B :: Ap :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApDpm3 : rk(A :: B :: Ap :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HABApDpm4 : rk(A :: B :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoAApDDpeq : rk(Oo :: A :: Ap :: D :: Dp :: nil) = 3) by (apply LOoAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDDpMtmp : rk(Oo :: A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDDpeq HOoAApDDpM3).
	assert(HOoABApDDpeq : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) = 4) by (apply LOoABApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApDDpmtmp : rk(Oo :: A :: B :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABApDDpeq HOoABApDDpm4).
	assert(HAApDpmtmp : rk(A :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HAApDpeq HAApDpm3).
	assert(Hincl : incl (A :: Ap :: Dp :: nil) (list_inter (A :: B :: Ap :: Dp :: nil) (Oo :: A :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: Dp :: nil) (A :: B :: Ap :: Dp :: Oo :: A :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Dp :: Oo :: A :: Ap :: D :: Dp :: nil) ((A :: B :: Ap :: Dp :: nil) ++ (Oo :: A :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDDpmtmp;try rewrite HT2 in HOoABApDDpmtmp.
	assert(HT := rule_2 (A :: B :: Ap :: Dp :: nil) (Oo :: A :: Ap :: D :: Dp :: nil) (A :: Ap :: Dp :: nil) 4 3 3 HOoABApDDpmtmp HAApDpmtmp HOoAApDDpMtmp Hincl);apply HT.
}

assert(HABApDpM : rk(A :: B :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApDpm : rk(A :: B :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HABApDpeq HABApDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACApDp *)
(* dans la couche 0 *)
Lemma LOoACApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApDDp requis par la preuve de (?)OoACApDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoACApDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApDDp requis par la preuve de (?)OoACApDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApDDp requis par la preuve de (?)OoACApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpm2 : rk(Oo :: A :: C :: Ap :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApDDpm3 : rk(Oo :: A :: C :: Ap :: D :: Dp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpmtmp;try rewrite HT2 in HOoABCApDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApDDpm4 : rk(Oo :: A :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: Ap :: D :: Dp :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACApDDpM : rk(Oo :: A :: C :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApDDpm : rk(Oo :: A :: C :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACApDDpeq HOoACApDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApDp requis par la preuve de (?)ACApDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ACApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)ABCApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ABCApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDpm2 : rk(A :: B :: C :: Ap :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDpm4 : rk(A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApDp requis par la preuve de (?)ACApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApDp requis par la preuve de (?)ACApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApDpm2 : rk(A :: C :: Ap :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApDpm3 : rk(A :: C :: Ap :: Dp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApDpmtmp : rk(A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HABCApDpeq HABCApDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: Dp :: nil) (B :: Ap :: A :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: Dp :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApDpmtmp;try rewrite HT2 in HABCApDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: Dp :: nil) (Ap :: nil) 4 1 2 HABCApDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HACApDpm4 : rk(A :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoAApDDpeq : rk(Oo :: A :: Ap :: D :: Dp :: nil) = 3) by (apply LOoAApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDDpMtmp : rk(Oo :: A :: Ap :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoAApDDpeq HOoAApDDpM3).
	assert(HOoACApDDpeq : rk(Oo :: A :: C :: Ap :: D :: Dp :: nil) = 4) by (apply LOoACApDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApDDpmtmp : rk(Oo :: A :: C :: Ap :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACApDDpeq HOoACApDDpm4).
	assert(HAApDpmtmp : rk(A :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HAApDpeq HAApDpm3).
	assert(Hincl : incl (A :: Ap :: Dp :: nil) (list_inter (A :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: D :: Dp :: nil) (A :: C :: Ap :: Dp :: Oo :: A :: Ap :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Dp :: Oo :: A :: Ap :: D :: Dp :: nil) ((A :: C :: Ap :: Dp :: nil) ++ (Oo :: A :: Ap :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApDDpmtmp;try rewrite HT2 in HOoACApDDpmtmp.
	assert(HT := rule_2 (A :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: D :: Dp :: nil) (A :: Ap :: Dp :: nil) 4 3 3 HOoACApDDpmtmp HAApDpmtmp HOoAApDDpMtmp Hincl);apply HT.
}

assert(HACApDpM : rk(A :: C :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApDpm : rk(A :: C :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HACApDpeq HACApDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApDp *)
(* dans la couche 0 *)
Lemma LOoABCApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDp requis par la preuve de (?)OoABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDpM : rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpm : rk(Oo :: A :: B :: C :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ABCApDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApDp requis par la preuve de (?)ABCApDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApDpm2 : rk(A :: B :: C :: Ap :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApDpm4 : rk(A :: B :: C :: Ap :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDpeq : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) = 4) by (apply LOoABCApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApDpeq HOoABCApDpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpmtmp;try rewrite HT2 in HOoABCApDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: Dp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApDpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApDpM : rk(A :: B :: C :: Ap :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApDpm : rk(A :: B :: C :: Ap :: Dp ::  nil) >= 1) by (solve_hyps_min HABCApDpeq HABCApDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour BpDp requis par la preuve de (?)BpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -2 et -4*)
(* ensembles concernés AUB : B :: Bp :: Dp ::  de rang :  3 et 3 	 AiB : Bp ::  de rang :  1 et 1 	 A : B :: Bp ::   de rang : 2 et 2 *)
assert(HBpDpm2 : rk(Bp :: Dp :: nil) >= 2).
{
	assert(HBBpMtmp : rk(B :: Bp :: nil) <= 2) by (solve_hyps_max HBBpeq HBBpM2).
	assert(HBBpDpmtmp : rk(B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HBBpDpeq HBBpDpm3).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (B :: Bp :: nil) (Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Dp :: nil) (B :: Bp :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Bp :: Dp :: nil) ((B :: Bp :: nil) ++ (Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDpmtmp;try rewrite HT2 in HBBpDpmtmp.
	assert(HT := rule_4 (B :: Bp :: nil) (Bp :: Dp :: nil) (Bp :: nil) 3 1 2 HBBpDpmtmp HBpmtmp HBBpMtmp Hincl); apply HT.
}

assert(HBpDpM : rk(Bp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBpDpeq HBpDpM2).
assert(HBpDpm : rk(Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HBpDpeq HBpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCBpDp *)
(* dans la couche 0 *)
Lemma LOoCBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpDDp requis par la preuve de (?)OoCBpDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpabDDp requis par la preuve de (?)OoCBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabDDp requis par la preuve de (?)OoACApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDDp requis par la preuve de (?)OoABCApBpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDDp requis par la preuve de (?)OoACApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDDp requis par la preuve de (?)OoACApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDDp requis par la preuve de (?)OoACApBpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDDpm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDDpm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDDpm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDDpmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDDp requis par la preuve de (?)OoBCApBpabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDDpm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDDpm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDDpeq HOoBCApBpabDDpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDDpmtmp;try rewrite HT2 in HOoBCApBpabDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDDpmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDDpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACApBpabDDpeq HOoACApBpabDDpm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDDpmtmp;try rewrite HT2 in HOoACApBpabDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDDpmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpDDp requis par la preuve de (?)OoCBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoCBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpDDp requis par la preuve de (?)OoCBpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpDDpm2 : rk(Oo :: C :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpmtmp;try rewrite HT2 in HOoABCApBpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: D :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDDpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : C :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCBpDDpm3 : rk(Oo :: C :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HCApBpabeq : rk(C :: Ap :: Bp :: ab :: nil) = 3) by (apply LCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApBpabMtmp : rk(C :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HCApBpabeq HCApBpabM3).
	assert(HOoCApBpabDDpmtmp : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoCApBpabDDpeq HOoCApBpabDDpm4).
	assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (C :: Ap :: Bp :: ab :: Oo :: C :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: Oo :: C :: Bp :: D :: Dp :: nil) ((C :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpabDDpmtmp;try rewrite HT2 in HOoCApBpabDDpmtmp.
	assert(HT := rule_4 (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Bp :: D :: Dp :: nil) (C :: Bp :: nil) 4 2 3 HOoCApBpabDDpmtmp HCBpmtmp HCApBpabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HOoCBpDDpM3 : rk(Oo :: C :: Bp :: D :: Dp :: nil) <= 3).
{
	assert(HOoCBpDeq : rk(Oo :: C :: Bp :: D :: nil) = 3) by (apply LOoCBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpDMtmp : rk(Oo :: C :: Bp :: D :: nil) <= 3) by (solve_hyps_max HOoCBpDeq HOoCBpDM3).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: C :: Bp :: D :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Bp :: D :: Dp :: nil) (Oo :: C :: Bp :: D :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Bp :: D :: Oo :: D :: Dp :: nil) ((Oo :: C :: Bp :: D :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Bp :: D :: nil) (Oo :: D :: Dp :: nil) (Oo :: D :: nil) 3 2 2 HOoCBpDMtmp HOoDDpMtmp HOoDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoCBpDDpM : rk(Oo :: C :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpDDpm : rk(Oo :: C :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCBpDDpeq HOoCBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Bp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCBpDp requis par la preuve de (?)OoCBpDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpabDp requis par la preuve de (?)OoCBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabDp requis par la preuve de (?)OoACApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDp requis par la preuve de (?)OoABCApBpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDp requis par la preuve de (?)OoACApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDp requis par la preuve de (?)OoACApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDp requis par la preuve de (?)OoACApBpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDpm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDpm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDpm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDpmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDp requis par la preuve de (?)OoBCApBpabDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDpm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDpm2 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDpeq HOoBCApBpabDpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDpmtmp;try rewrite HT2 in HOoBCApBpabDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDpm3 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDpmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDpm4 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoACApBpabDpeq HOoACApBpabDpm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDpmtmp;try rewrite HT2 in HOoACApBpabDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDpmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCBpDp requis par la preuve de (?)OoCBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoCBpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCBpDp requis par la preuve de (?)OoCBpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCBpDpm2 : rk(Oo :: C :: Bp :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApBpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Bp :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDpmtmp;try rewrite HT2 in HOoABCApBpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Bp :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDpmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : C :: Bp ::  de rang :  2 et 2 	 A : C :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCBpDpm3 : rk(Oo :: C :: Bp :: Dp :: nil) >= 3).
{
	assert(HCApBpabeq : rk(C :: Ap :: Bp :: ab :: nil) = 3) by (apply LCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApBpabMtmp : rk(C :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HCApBpabeq HCApBpabM3).
	assert(HOoCApBpabDpmtmp : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoCApBpabDpeq HOoCApBpabDpm4).
	assert(HCBpeq : rk(C :: Bp :: nil) = 2) by (apply LCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCBpmtmp : rk(C :: Bp :: nil) >= 2) by (solve_hyps_min HCBpeq HCBpm2).
	assert(Hincl : incl (C :: Bp :: nil) (list_inter (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Bp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) (C :: Ap :: Bp :: ab :: Oo :: C :: Bp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: Oo :: C :: Bp :: Dp :: nil) ((C :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Bp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpabDpmtmp;try rewrite HT2 in HOoCApBpabDpmtmp.
	assert(HT := rule_4 (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Bp :: Dp :: nil) (C :: Bp :: nil) 4 2 3 HOoCApBpabDpmtmp HCBpmtmp HCApBpabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoCBpDpM3 : rk(Oo :: C :: Bp :: Dp :: nil) <= 3).
{
	assert(HOoCBpDDpeq : rk(Oo :: C :: Bp :: D :: Dp :: nil) = 3) by (apply LOoCBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpDDpMtmp : rk(Oo :: C :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoCBpDDpeq HOoCBpDDpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: C :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: C :: Bp :: Dp :: nil) (Oo :: C :: Bp :: D :: Dp :: nil) 3 3 HOoCBpDDpMtmp Hcomp Hincl);apply HT.
}

assert(HOoCBpDpM : rk(Oo :: C :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCBpDpm : rk(Oo :: C :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCBpDpeq HOoCBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDp requis par la preuve de (?)OoABCApBpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDpeq HOoABCApBpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour CpDp requis par la preuve de (?)CpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 2) *)
(* marque des antécédents AUB AiB A: -4 -1 et 4*)
(* ensembles concernés AUB : Ap :: Bp :: Cp :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Ap :: Bp ::   de rang : 2 et 2 *)
assert(HCpDpm2 : rk(Cp :: Dp :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpMtmp : rk(Ap :: Bp :: nil) <= 2) by (solve_hyps_max HApBpeq HApBpM2).
	assert(HApBpCpDpmtmp : rk(Ap :: Bp :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HApBpCpDpeq HApBpCpDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: nil) (Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) (Ap :: Bp :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: Cp :: Dp :: nil) ((Ap :: Bp :: nil) ++ (Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApBpCpDpmtmp;try rewrite HT2 in HApBpCpDpmtmp.
	assert(HT := rule_4 (Ap :: Bp :: nil) (Cp :: Dp :: nil) (nil) 4 0 2 HApBpCpDpmtmp Hmtmp HApBpMtmp Hincl); apply HT.
}

assert(HCpDpM : rk(Cp :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HCpDpeq HCpDpM2).
assert(HCpDpm : rk(Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HCpDpeq HCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpDp *)
(* dans constructLemma(), requis par LOoABCpDDp *)
(* dans constructLemma(), requis par LOoABCpabDDp *)
(* dans la couche 0 *)
Lemma LOoABApCpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDp requis par la preuve de (?)OoABApCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDp requis par la preuve de (?)OoABApCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDp requis par la preuve de (?)OoABApCpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDDpm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabDDpM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabDDpm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABApCpabDDpeq HOoABApCpabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Cp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpabDDp requis par la preuve de (?)OoABCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpabDDp requis par la preuve de (?)OoABCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDp requis par la preuve de (?)OoABCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDp requis par la preuve de (?)OoABApCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDp requis par la preuve de (?)OoABApCpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpabDDp requis par la preuve de (?)OoABCpabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABCpabDDpm2 : rk(Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpabDDpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApCpabDDpeq HOoABApCpabDDpm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpmtmp;try rewrite HT2 in HOoABApCpabDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApCpabDDpmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpabDDpm3 : rk(Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) 3 3 HABCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoABCpabDDpm4 : rk(Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoABApCpabDDpeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABApCpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDDpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpeq HOoABApCpabDDpm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpmtmp;try rewrite HT2 in HOoABApCpabDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoABApCpabDDpmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

assert(HOoABCpabDDpM : rk(Oo :: A :: B :: Cp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpabDDpm : rk(Oo :: A :: B :: Cp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCpabDDpeq HOoABCpabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABCpDDp requis par la preuve de (?)OoABCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABCpDDp requis par la preuve de (?)OoABCpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpDDp requis par la preuve de (?)OoABCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpDDp requis par la preuve de (?)OoABApCpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpDDp requis par la preuve de (?)OoABApCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpDDpm2 : rk(Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpDDpm3 : rk(Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCpDDp requis par la preuve de (?)OoABCpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: D :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABCpDDpm2 : rk(Oo :: A :: B :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApCpDDpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApCpDDpeq HOoABApCpDDpm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Cp :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpDDpmtmp;try rewrite HT2 in HOoABApCpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Cp :: D :: Dp :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApCpDDpmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABCpDDpm3 : rk(Oo :: A :: B :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Cp :: nil) (Oo :: A :: B :: Cp :: D :: Dp :: nil) 3 3 HABCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : A :: B :: Cp ::  de rang :  3 et 3 	 A : A :: B :: Cp :: ab ::   de rang : 3 et 3 *)
assert(HOoABCpDDpm4 : rk(Oo :: A :: B :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HABCpabeq : rk(A :: B :: Cp :: ab :: nil) = 3) by (apply LABCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpabMtmp : rk(A :: B :: Cp :: ab :: nil) <= 3) by (solve_hyps_max HABCpabeq HABCpabM3).
	assert(HOoABCpabDDpeq : rk(Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABCpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCpabDDpmtmp : rk(Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCpabDDpeq HOoABCpabDDpm4).
	assert(HABCpeq : rk(A :: B :: Cp :: nil) = 3) by (apply LABCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCpmtmp : rk(A :: B :: Cp :: nil) >= 3) by (solve_hyps_min HABCpeq HABCpm3).
	assert(Hincl : incl (A :: B :: Cp :: nil) (list_inter (A :: B :: Cp :: ab :: nil) (Oo :: A :: B :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: ab :: D :: Dp :: nil) (A :: B :: Cp :: ab :: Oo :: A :: B :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Cp :: ab :: Oo :: A :: B :: Cp :: D :: Dp :: nil) ((A :: B :: Cp :: ab :: nil) ++ (Oo :: A :: B :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpabDDpmtmp;try rewrite HT2 in HOoABCpabDDpmtmp.
	assert(HT := rule_4 (A :: B :: Cp :: ab :: nil) (Oo :: A :: B :: Cp :: D :: Dp :: nil) (A :: B :: Cp :: nil) 4 3 3 HOoABCpabDDpmtmp HABCpmtmp HABCpabMtmp Hincl); apply HT.
}

assert(HOoABCpDDpM : rk(Oo :: A :: B :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCpDDpm : rk(Oo :: A :: B :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCpDDpeq HOoABCpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACpDp *)
(* dans la couche 0 *)
Lemma LOoBCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpDDp requis par la preuve de (?)OoBCpDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCpabDDp requis par la preuve de (?)OoBCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabDDp requis par la preuve de (?)OoBApCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabDDp requis par la preuve de (?)OoBApCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabDDp requis par la preuve de (?)OoBApCpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpm2 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpm3 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDDpm4 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABApCpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDDpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpeq HOoABApCpabDDpm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpmtmp;try rewrite HT2 in HOoABApCpabDDpmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDDpmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDDp requis par la preuve de (?)OoABCApCpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpm2 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDDpeq HOoABCApCpabDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDDpmtmp;try rewrite HT2 in HOoABCApCpabDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDDpm3 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpm4 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDDpmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBApCpabDDpeq HOoBApCpabDDpm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDDpmtmp;try rewrite HT2 in HOoBApCpabDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDDpmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpDDp requis par la preuve de (?)OoBCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoBCpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoABCApCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpDDp requis par la preuve de (?)OoBCpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpDDpm2 : rk(Oo :: B :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDDpeq HOoABCApCpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: D :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDDpmtmp;try rewrite HT2 in HOoABCApCpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: D :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoBCpDDpm3 : rk(Oo :: B :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoBCpabDDpmtmp : rk(Oo :: B :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCpabDDpeq HOoBCpabDDpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: B :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: ab :: D :: Dp :: nil) (Cp :: ab :: Oo :: B :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: B :: Cp :: D :: Dp :: nil) ((Cp :: ab :: nil) ++ (Oo :: B :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpabDDpmtmp;try rewrite HT2 in HOoBCpabDDpmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: B :: Cp :: D :: Dp :: nil) (Cp :: nil) 4 1 2 HOoBCpabDDpmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HOoBCpDDpM3 : rk(Oo :: B :: Cp :: D :: Dp :: nil) <= 3).
{
	assert(HOoBCpDeq : rk(Oo :: B :: Cp :: D :: nil) = 3) by (apply LOoBCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCpDMtmp : rk(Oo :: B :: Cp :: D :: nil) <= 3) by (solve_hyps_max HOoBCpDeq HOoBCpDM3).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: B :: Cp :: D :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: D :: Dp :: nil) (Oo :: B :: Cp :: D :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Cp :: D :: Oo :: D :: Dp :: nil) ((Oo :: B :: Cp :: D :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Cp :: D :: nil) (Oo :: D :: Dp :: nil) (Oo :: D :: nil) 3 2 2 HOoBCpDMtmp HOoDDpMtmp HOoDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBCpDDpM : rk(Oo :: B :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpDDpm : rk(Oo :: B :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCpDDpeq HOoBCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACpDp requis par la preuve de (?)ACpDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACpDp requis par la preuve de (?)ACpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDpm2 : rk(A :: Cp :: Dp :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: Dp :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HACpDpm3 : rk(A :: Cp :: Dp :: nil) >= 3).
{
	assert(HOoBCpDDpeq : rk(Oo :: B :: Cp :: D :: Dp :: nil) = 3) by (apply LOoBCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCpDDpMtmp : rk(Oo :: B :: Cp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCpDDpeq HOoBCpDDpM3).
	assert(HOoABCpDDpeq : rk(Oo :: A :: B :: Cp :: D :: Dp :: nil) = 4) by (apply LOoABCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCpDDpmtmp : rk(Oo :: A :: B :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCpDDpeq HOoABCpDDpm4).
	assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hincl : incl (Cp :: Dp :: nil) (list_inter (A :: Cp :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: D :: Dp :: nil) (A :: Cp :: Dp :: Oo :: B :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: Dp :: Oo :: B :: Cp :: D :: Dp :: nil) ((A :: Cp :: Dp :: nil) ++ (Oo :: B :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpDDpmtmp;try rewrite HT2 in HOoABCpDDpmtmp.
	assert(HT := rule_2 (A :: Cp :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: nil) (Cp :: Dp :: nil) 4 2 3 HOoABCpDDpmtmp HCpDpmtmp HOoBCpDDpMtmp Hincl);apply HT.
}

assert(HACpDpM : rk(A :: Cp :: Dp ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACpDpeq HACpDpM3).
assert(HACpDpm : rk(A :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HACpDpeq HACpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpDp requis par la preuve de (?)OoBCpDp pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCpabDp requis par la preuve de (?)OoBCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabDp requis par la preuve de (?)OoBApCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDp requis par la preuve de (?)OoABApCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDp requis par la preuve de (?)OoABApCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDp requis par la preuve de (?)OoABApCpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDpm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDpm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDpm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabDp requis par la preuve de (?)OoBApCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabDp requis par la preuve de (?)OoBApCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabDp requis par la preuve de (?)OoBApCpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDpm2 : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDpm3 : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDpm4 : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABApCpabDpeq HOoABApCpabDpm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDpmtmp;try rewrite HT2 in HOoABApCpabDpmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDpmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDp requis par la preuve de (?)OoABCApCpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDpm2 : rk(Oo :: B :: Cp :: ab :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDpeq HOoABCApCpabDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDpmtmp;try rewrite HT2 in HOoABCApCpabDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDpm3 : rk(Oo :: B :: Cp :: ab :: Dp :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDpm4 : rk(Oo :: B :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDpmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoBApCpabDpeq HOoBApCpabDpm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: Dp :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDpmtmp;try rewrite HT2 in HOoBApCpabDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDpmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpDp requis par la preuve de (?)OoBCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoBCpDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoABCApCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpDp requis par la preuve de (?)OoBCpDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpDpm2 : rk(Oo :: B :: Cp :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpDpeq HOoABCApCpDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpDpmtmp;try rewrite HT2 in HOoABCApCpDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: Cp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoBCpDpm3 : rk(Oo :: B :: Cp :: Dp :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoBCpabDpmtmp : rk(Oo :: B :: Cp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCpabDpeq HOoBCpabDpm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: B :: Cp :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Cp :: ab :: Dp :: nil) (Cp :: ab :: Oo :: B :: Cp :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: B :: Cp :: Dp :: nil) ((Cp :: ab :: nil) ++ (Oo :: B :: Cp :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCpabDpmtmp;try rewrite HT2 in HOoBCpabDpmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: B :: Cp :: Dp :: nil) (Cp :: nil) 4 1 2 HOoBCpabDpmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpDpM3 : rk(Oo :: B :: Cp :: Dp :: nil) <= 3).
{
	assert(HOoBCpDDpeq : rk(Oo :: B :: Cp :: D :: Dp :: nil) = 3) by (apply LOoBCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCpDDpMtmp : rk(Oo :: B :: Cp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCpDDpeq HOoBCpDDpM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: Cp :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: Cp :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: nil) 3 3 HOoBCpDDpMtmp Hcomp Hincl);apply HT.
}

assert(HOoBCpDpM : rk(Oo :: B :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpDpm : rk(Oo :: B :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCpDpeq HOoBCpDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDp requis par la preuve de (?)OoABCApCpDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpDpM : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDpm : rk(Oo :: A :: B :: C :: Ap :: Cp :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDpeq HOoABCApCpDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LabDp *)
(* dans constructLemma(), requis par LOoabDDp *)
(* dans constructLemma(), requis par LOoBCabDDp *)
(* dans la couche 0 *)
Lemma LOoABCabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabDDp requis par la preuve de (?)OoABCabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabDDpm4 : rk(Oo :: A :: B :: C :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabDDpM : rk(Oo :: A :: B :: C :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabDDpm : rk(Oo :: A :: B :: C :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCabDDpeq HOoABCabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCabDDp requis par la preuve de (?)OoBCabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDDp requis par la preuve de (?)OoBCabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDDp requis par la preuve de (?)OoABCApabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDDpm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCabDDp requis par la preuve de (?)OoBCabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCabDDp requis par la preuve de (?)OoBCabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDDpm2 : rk(Oo :: B :: C :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApabDDpeq HOoABCApabDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: ab :: D :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDDpmtmp;try rewrite HT2 in HOoABCApabDDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApabDDpmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDDpm3 : rk(Oo :: B :: C :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApabDDpeq HOoABCApabDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDDpmtmp;try rewrite HT2 in HOoABCApabDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApabDDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBCabDDpm4 : rk(Oo :: B :: C :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCabDDpeq : rk(Oo :: A :: B :: C :: ab :: D :: Dp :: nil) = 4) by (apply LOoABCabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDDpmtmp : rk(Oo :: A :: B :: C :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCabDDpeq HOoABCabDDpm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: Dp :: nil) (A :: B :: ab :: Oo :: B :: C :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: C :: ab :: D :: Dp :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: C :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDDpmtmp;try rewrite HT2 in HOoABCabDDpmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: Dp :: nil) (B :: ab :: nil) 4 2 2 HOoABCabDDpmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBCabDDpM : rk(Oo :: B :: C :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCabDDpm : rk(Oo :: B :: C :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCabDDpeq HOoBCabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: ab :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoabDDp requis par la preuve de (?)OoabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoabDDp requis par la preuve de (?)OoabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoabDDp requis par la preuve de (?)OoabDDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoabDDpM3 : rk(Oo :: ab :: D :: Dp :: nil) <= 3).
{
	assert(HabMtmp : rk(ab :: nil) <= 1) by (solve_hyps_max Habeq HabM1).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ab :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: ab :: D :: Dp :: nil) (ab :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: Oo :: D :: Dp :: nil) ((ab :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HabMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoabDDpm2 : rk(Oo :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HOoabeq : rk(Oo :: ab :: nil) = 2) by (apply LOoab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoabmtmp : rk(Oo :: ab :: nil) >= 2) by (solve_hyps_min HOoabeq HOoabm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: ab :: nil) (Oo :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: ab :: nil) (Oo :: ab :: D :: Dp :: nil) 2 2 HOoabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HOoabDDpm3 : rk(Oo :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCabDDpeq : rk(Oo :: B :: C :: ab :: D :: Dp :: nil) = 4) by (apply LOoBCabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCabDDpmtmp : rk(Oo :: B :: C :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCabDDpeq HOoBCabDDpm4).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: ab :: D :: Dp :: nil) (Oo :: B :: C :: D :: Oo :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: ab :: D :: Dp :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCabDDpmtmp;try rewrite HT2 in HOoBCabDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Oo :: ab :: D :: Dp :: nil) (Oo :: D :: nil) 4 2 3 HOoBCabDDpmtmp HOoDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HOoabDDpM : rk(Oo :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoabDDpm : rk(Oo :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoabDDpeq HOoabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour abDp requis par la preuve de (?)abDp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HabDpm2 : rk(ab :: Dp :: nil) >= 2).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoabDDpeq : rk(Oo :: ab :: D :: Dp :: nil) = 3) by (apply LOoabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoabDDpmtmp : rk(Oo :: ab :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoabDDpeq HOoabDDpm3).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (ab :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: ab :: D :: Dp :: nil) (ab :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: Dp :: Oo :: D :: Dp :: nil) ((ab :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoabDDpmtmp;try rewrite HT2 in HOoabDDpmtmp.
	assert(HT := rule_2 (ab :: Dp :: nil) (Oo :: D :: Dp :: nil) (Dp :: nil) 3 1 2 HOoabDDpmtmp HDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HabDpM : rk(ab :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HabDpeq HabDpM2).
assert(HabDpm : rk(ab :: Dp ::  nil) >= 1) by (solve_hyps_min HabDpeq HabDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABabDp *)
(* dans la couche 0 *)
Lemma LOoABCabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabDp requis par la preuve de (?)OoABCabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabDpm4 : rk(Oo :: A :: B :: C :: ab :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabDpM : rk(Oo :: A :: B :: C :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabDpm : rk(Oo :: A :: B :: C :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCabDpeq HOoABCabDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDp requis par la preuve de (?)ABabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDp requis par la preuve de (?)ABabDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDp requis par la preuve de (?)ABabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDp requis par la preuve de (?)OoABApabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDp requis par la preuve de (?)OoABApabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDpm2 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDpm3 : rk(Oo :: A :: B :: Ap :: ab :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDp requis par la preuve de (?)ABabDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: Dp ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDpm2 : rk(A :: B :: ab :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDpmtmp : rk(Oo :: A :: B :: Ap :: ab :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApabDpeq HOoABApabDpm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: Dp :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDpmtmp;try rewrite HT2 in HOoABApabDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: Dp :: nil) (A :: B :: nil) 3 2 3 HOoABApabDpmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABabDpM3 : rk(A :: B :: ab :: Dp :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: Dp :: nil) (A :: B :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Dp :: nil) ((A :: B :: ab :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (Dp :: nil) (nil) 2 1 0 HABabMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: Dp ::  de rang :  4 et 4 	 AiB : A :: B :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HABabDpm3 : rk(A :: B :: ab :: Dp :: nil) >= 3).
{
	assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	assert(HOoABCabDpeq : rk(Oo :: A :: B :: C :: ab :: Dp :: nil) = 4) by (apply LOoABCabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDpmtmp : rk(Oo :: A :: B :: C :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCabDpeq HOoABCabDpm4).
	assert(HABDpeq : rk(A :: B :: Dp :: nil) = 3) by (apply LABDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDpmtmp : rk(A :: B :: Dp :: nil) >= 3) by (solve_hyps_min HABDpeq HABDpm3).
	assert(Hincl : incl (A :: B :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (A :: B :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: A :: B :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: A :: B :: ab :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (A :: B :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDpmtmp;try rewrite HT2 in HOoABCabDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (A :: B :: ab :: Dp :: nil) (A :: B :: Dp :: nil) 4 3 4 HOoABCabDpmtmp HABDpmtmp HOoABCDpMtmp Hincl); apply HT.
}

assert(HABabDpM : rk(A :: B :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDpm : rk(A :: B :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HABabDpeq HABabDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpabDp *)
(* dans constructLemma(), requis par LOoACApBpabDp *)
(* dans la couche 0 *)
Lemma LOoABCApBpabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDp requis par la preuve de (?)OoABCApBpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDp requis par la preuve de (?)OoACApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDp requis par la preuve de (?)OoACApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDp requis par la preuve de (?)OoACApBpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDpm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDpm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) = 4) by (apply LOoABCApBpabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDpm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) = 4) by (apply LOoABCApBpabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDpmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpabDpM : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpabDpm : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACApBpabDpeq HOoACApBpabDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDp requis par la preuve de (?)OoBCApBpabDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDpm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) = 4) by (apply LOoABCApBpabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDp requis par la preuve de (?)OoCApBpabDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDpm2 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDpeq HOoBCApBpabDpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDpmtmp;try rewrite HT2 in HOoBCApBpabDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDpm3 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) = 4) by (apply LOoABCApBpabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpeq HOoABCApBpabDpm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpmtmp;try rewrite HT2 in HOoABCApBpabDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDpmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDpm4 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDpeq : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) = 4) by (apply LOoACApBpabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpabDpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoACApBpabDpeq HOoACApBpabDpm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDpmtmp;try rewrite HT2 in HOoACApBpabDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDpmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

assert(HOoCApBpabDpM : rk(Oo :: C :: Ap :: Bp :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpabDpm : rk(Oo :: C :: Ap :: Bp :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCApBpabDpeq HOoCApBpabDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpabDp *)
(* dans constructLemma(), requis par LOoBApCpabDp *)
(* dans la couche 0 *)
Lemma LOoABApCpabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDp requis par la preuve de (?)OoABApCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDp requis par la preuve de (?)OoABApCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDp requis par la preuve de (?)OoABApCpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDpm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDpm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDpm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabDpM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabDpm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABApCpabDpeq HOoABApCpabDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApCpabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Cp :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabDp requis par la preuve de (?)OoBApCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabDp requis par la preuve de (?)OoBApCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabDp requis par la preuve de (?)OoBApCpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDpm2 : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDpm3 : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDpm4 : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDpeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) = 4) by (apply LOoABApCpabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABApCpabDpeq HOoABApCpabDpm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: Dp :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDpmtmp;try rewrite HT2 in HOoABApCpabDpmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDpmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBApCpabDpM : rk(Oo :: B :: Ap :: Cp :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpabDpm : rk(Oo :: B :: Ap :: Cp :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBApCpabDpeq HOoBApCpabDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDp requis par la preuve de (?)OoABCApCpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabDp requis par la preuve de (?)OoBCpabDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDpm2 : rk(Oo :: B :: Cp :: ab :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDpeq HOoABCApCpabDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDpmtmp;try rewrite HT2 in HOoABCApCpabDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDpm3 : rk(Oo :: B :: Cp :: ab :: Dp :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDpm4 : rk(Oo :: B :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDpeq : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) = 4) by (apply LOoBApCpabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApCpabDpmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) >= 4) by (solve_hyps_min HOoBApCpabDpeq HOoBApCpabDpm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: Dp :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: Dp :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDpmtmp;try rewrite HT2 in HOoBApCpabDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: Dp :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDpmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

assert(HOoBCpabDpM : rk(Oo :: B :: Cp :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpabDpm : rk(Oo :: B :: Cp :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCpabDpeq HOoBCpabDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDp requis par la preuve de (?)OoABCApCpabDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabDpM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabDpm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabDpeq HOoABCApCpabDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LacDp *)
(* dans constructLemma(), requis par LOoacDDp *)
(* dans constructLemma(), requis par LOoBCacDDp *)
(* dans la couche 0 *)
Lemma LOoABCacDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ac :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCacDDp requis par la preuve de (?)OoABCacDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCacDDpm4 : rk(Oo :: A :: B :: C :: ac :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCacDDpM : rk(Oo :: A :: B :: C :: ac :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCacDDpm : rk(Oo :: A :: B :: C :: ac :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCacDDpeq HOoABCacDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCacDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: ac :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCacDDp requis par la preuve de (?)OoBCacDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDDp requis par la preuve de (?)OoBCacDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDp requis par la preuve de (?)OoABCApacDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCacDDp requis par la preuve de (?)OoBCacDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCacDDp requis par la preuve de (?)OoBCacDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCacDDpm2 : rk(Oo :: B :: C :: ac :: D :: Dp :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApacDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpeq HOoABCApacDDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: ac :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: ac :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: ac :: D :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: ac :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpmtmp;try rewrite HT2 in HOoABCApacDDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: ac :: D :: Dp :: nil) (nil) 4 0 2 HOoABCApacDDpmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCacDDpm3 : rk(Oo :: B :: C :: ac :: D :: Dp :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApacDDpeq HOoABCApacDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ac :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: ac :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: ac :: D :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: ac :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDDpmtmp;try rewrite HT2 in HOoABCApacDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ac :: D :: Dp :: nil) (Oo :: nil) 4 1 2 HOoABCApacDDpmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ac :: D :: Dp ::  de rang :  4 et 4 	 AiB : C :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoBCacDDpm4 : rk(Oo :: B :: C :: ac :: D :: Dp :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoABCacDDpeq : rk(Oo :: A :: B :: C :: ac :: D :: Dp :: nil) = 4) by (apply LOoABCacDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCacDDpmtmp : rk(Oo :: A :: B :: C :: ac :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCacDDpeq HOoABCacDDpm4).
	assert(HCaceq : rk(C :: ac :: nil) = 2) by (apply LCac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCacmtmp : rk(C :: ac :: nil) >= 2) by (solve_hyps_min HCaceq HCacm2).
	assert(Hincl : incl (C :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: B :: C :: ac :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: D :: Dp :: nil) (A :: C :: ac :: Oo :: B :: C :: ac :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: B :: C :: ac :: D :: Dp :: nil) ((A :: C :: ac :: nil) ++ (Oo :: B :: C :: ac :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacDDpmtmp;try rewrite HT2 in HOoABCacDDpmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: B :: C :: ac :: D :: Dp :: nil) (C :: ac :: nil) 4 2 2 HOoABCacDDpmtmp HCacmtmp HACacMtmp Hincl); apply HT.
}

assert(HOoBCacDDpM : rk(Oo :: B :: C :: ac :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCacDDpm : rk(Oo :: B :: C :: ac :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCacDDpeq HOoBCacDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoacDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: ac :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoacDDp requis par la preuve de (?)OoacDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoacDDp requis par la preuve de (?)OoacDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoacDDp requis par la preuve de (?)OoacDDp pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoacDDpM3 : rk(Oo :: ac :: D :: Dp :: nil) <= 3).
{
	assert(HacMtmp : rk(ac :: nil) <= 1) by (solve_hyps_max Haceq HacM1).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ac :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: ac :: D :: Dp :: nil) (ac :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: Oo :: D :: Dp :: nil) ((ac :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ac :: nil) (Oo :: D :: Dp :: nil) (nil) 1 2 0 HacMtmp HOoDDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoacDDpm2 : rk(Oo :: ac :: D :: Dp :: nil) >= 2).
{
	assert(HOoaceq : rk(Oo :: ac :: nil) = 2) by (apply LOoac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoacmtmp : rk(Oo :: ac :: nil) >= 2) by (solve_hyps_min HOoaceq HOoacm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Oo :: ac :: nil) (Oo :: ac :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: ac :: nil) (Oo :: ac :: D :: Dp :: nil) 2 2 HOoacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: ac :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HOoacDDpm3 : rk(Oo :: ac :: D :: Dp :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCacDDpeq : rk(Oo :: B :: C :: ac :: D :: Dp :: nil) = 4) by (apply LOoBCacDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCacDDpmtmp : rk(Oo :: B :: C :: ac :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBCacDDpeq HOoBCacDDpm4).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: ac :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: ac :: D :: Dp :: nil) (Oo :: B :: C :: D :: Oo :: ac :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: ac :: D :: Dp :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: ac :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCacDDpmtmp;try rewrite HT2 in HOoBCacDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Oo :: ac :: D :: Dp :: nil) (Oo :: D :: nil) 4 2 3 HOoBCacDDpmtmp HOoDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HOoacDDpM : rk(Oo :: ac :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoacDDpm : rk(Oo :: ac :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoacDDpeq HOoacDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LacDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: Dp ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour acDp requis par la preuve de (?)acDp pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HacDpm2 : rk(ac :: Dp :: nil) >= 2).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoacDDpeq : rk(Oo :: ac :: D :: Dp :: nil) = 3) by (apply LOoacDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoacDDpmtmp : rk(Oo :: ac :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoacDDpeq HOoacDDpm3).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (ac :: Dp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: ac :: D :: Dp :: nil) (ac :: Dp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: Dp :: Oo :: D :: Dp :: nil) ((ac :: Dp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoacDDpmtmp;try rewrite HT2 in HOoacDDpmtmp.
	assert(HT := rule_2 (ac :: Dp :: nil) (Oo :: D :: Dp :: nil) (Dp :: nil) 3 1 2 HOoacDDpmtmp HDpmtmp HOoDDpMtmp Hincl);apply HT.
}

assert(HacDpM : rk(ac :: Dp ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HacDpeq HacDpM2).
assert(HacDpm : rk(ac :: Dp ::  nil) >= 1) by (solve_hyps_min HacDpeq HacDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACacDp *)
(* dans la couche 0 *)
Lemma LOoABCacDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ac :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCacDp requis par la preuve de (?)OoABCacDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCacDpm4 : rk(Oo :: A :: B :: C :: ac :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCacDpM : rk(Oo :: A :: B :: C :: ac :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCacDpm : rk(Oo :: A :: B :: C :: ac :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCacDpeq HOoABCacDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDp requis par la preuve de (?)ACacDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDp requis par la preuve de (?)ACacDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDp requis par la preuve de (?)ACacDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDp requis par la preuve de (?)ABCApacDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDp requis par la preuve de (?)OoABCApacDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDp requis par la preuve de (?)ABCApacDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDp requis par la preuve de (?)ABCApacDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApacDpeq HOoABCApacDpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpmtmp;try rewrite HT2 in HOoABCApacDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDp requis par la preuve de (?)ACacDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDpm2 : rk(A :: C :: ac :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: nil) >= 4) by (solve_hyps_min HABCApacDpeq HABCApacDpm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: nil) (B :: Ap :: A :: C :: ac :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: Dp :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpmtmp;try rewrite HT2 in HABCApacDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: Dp :: nil) (nil) 4 0 2 HABCApacDpmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HACacDpM3 : rk(A :: C :: ac :: Dp :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HDpMtmp : rk(Dp :: nil) <= 1) by (solve_hyps_max HDpeq HDpM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: Dp :: nil) (A :: C :: ac :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Dp :: nil) ((A :: C :: ac :: nil) ++ (Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (Dp :: nil) (nil) 2 1 0 HACacMtmp HDpMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ac :: Dp ::  de rang :  4 et 4 	 AiB : A :: C :: Dp ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: Dp ::   de rang : 4 et 4 *)
assert(HACacDpm3 : rk(A :: C :: ac :: Dp :: nil) >= 3).
{
	assert(HOoABCDpeq : rk(Oo :: A :: B :: C :: Dp :: nil) = 4) by (apply LOoABCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDpMtmp : rk(Oo :: A :: B :: C :: Dp :: nil) <= 4) by (solve_hyps_max HOoABCDpeq HOoABCDpM4).
	assert(HOoABCacDpeq : rk(Oo :: A :: B :: C :: ac :: Dp :: nil) = 4) by (apply LOoABCacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCacDpmtmp : rk(Oo :: A :: B :: C :: ac :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCacDpeq HOoABCacDpm4).
	assert(HACDpeq : rk(A :: C :: Dp :: nil) = 3) by (apply LACDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDpmtmp : rk(A :: C :: Dp :: nil) >= 3) by (solve_hyps_min HACDpeq HACDpm3).
	assert(Hincl : incl (A :: C :: Dp :: nil) (list_inter (Oo :: A :: B :: C :: Dp :: nil) (A :: C :: ac :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: Dp :: nil) (Oo :: A :: B :: C :: Dp :: A :: C :: ac :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: Dp :: A :: C :: ac :: Dp :: nil) ((Oo :: A :: B :: C :: Dp :: nil) ++ (A :: C :: ac :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacDpmtmp;try rewrite HT2 in HOoABCacDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: Dp :: nil) (A :: C :: ac :: Dp :: nil) (A :: C :: Dp :: nil) 4 3 4 HOoABCacDpmtmp HACDpmtmp HOoABCDpMtmp Hincl); apply HT.
}

assert(HACacDpM : rk(A :: C :: ac :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDpm : rk(A :: C :: ac :: Dp ::  nil) >= 1) by (solve_hyps_min HACacDpeq HACacDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDp *)
(* dans la couche 0 *)
Lemma LOoABCApacDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDp requis par la preuve de (?)OoABCApacDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpeq HOoABCApacDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDp requis par la preuve de (?)ABCApacDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDp requis par la preuve de (?)ABCApacDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpeq : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) = 4) by (apply LOoABCApacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDpmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApacDpeq HOoABCApacDpm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpmtmp;try rewrite HT2 in HOoABCApacDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDpM : rk(A :: B :: C :: Ap :: ac :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDpm : rk(A :: B :: C :: Ap :: ac :: Dp ::  nil) >= 1) by (solve_hyps_min HABCApacDpeq HABCApacDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDp requis par la preuve de (?)OoABCApDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpeq HOoABCApDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpDDp *)
(* dans la couche 0 *)
Lemma LOoABBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpDDp requis par la preuve de (?)OoABApBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpDDp requis par la preuve de (?)OoABApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDDpm2 : rk(Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpDDpm3 : rk(Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpDDp requis par la preuve de (?)OoABBpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: D :: Dp ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABBpDDpm2 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpDDpmtmp : rk(Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoABApBpDDpeq HOoABApBpDDpm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: D :: Dp :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: D :: Dp :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpDDpmtmp;try rewrite HT2 in HOoABApBpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApBpDDpmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDDpm3 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpDDpm4 : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: Bp :: D :: Dp :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABBpDDpM : rk(Oo :: A :: B :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpDDpm : rk(Oo :: A :: B :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABBpDDpeq HOoABBpDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABpDDp *)
(* dans la couche 0 *)
Lemma LOoBBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: D :: Dp ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpDDp requis par la preuve de (?)OoBBpDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpDDpm2 : rk(Oo :: B :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: D :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpDDpmtmp;try rewrite HT2 in HOoABCApBpDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: D :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApBpDDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoBBpDDpM3 : rk(Oo :: B :: Bp :: D :: Dp :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: Oo :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: D :: Dp :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (Oo :: D :: Dp :: nil) (Oo :: nil) 2 2 1 HOoBBpMtmp HOoDDpMtmp HOomtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBBpDDpm3 : rk(Oo :: B :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: Bp :: D :: Dp :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

assert(HOoBBpDDpM : rk(Oo :: B :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpDDpm : rk(Oo :: B :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBBpDDpeq HOoBBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABpDDp requis par la preuve de (?)ABpDDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABpDDp requis par la preuve de (?)ABpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABpDDp requis par la preuve de (?)ABpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDDpm2 : rk(A :: Bp :: D :: Dp :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (A :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (A :: Bp :: D :: Dp :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABpDDpm3 : rk(A :: Bp :: D :: Dp :: nil) >= 3).
{
	assert(HABpDeq : rk(A :: Bp :: D :: nil) = 3) by (apply LABpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpDmtmp : rk(A :: Bp :: D :: nil) >= 3) by (solve_hyps_min HABpDeq HABpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: D :: nil) (A :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: D :: nil) (A :: Bp :: D :: Dp :: nil) 3 3 HABpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HABpDDpm4 : rk(A :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoBBpDDpeq : rk(Oo :: B :: Bp :: D :: Dp :: nil) = 3) by (apply LOoBBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpDDpMtmp : rk(Oo :: B :: Bp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoBBpDDpeq HOoBBpDDpM3).
	assert(HOoABBpDDpeq : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) = 4) by (apply LOoABBpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpDDpmtmp : rk(Oo :: A :: B :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABBpDDpeq HOoABBpDDpm4).
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (list_inter (A :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: D :: Dp :: nil) (A :: Bp :: D :: Dp :: Oo :: B :: Bp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Bp :: D :: Dp :: Oo :: B :: Bp :: D :: Dp :: nil) ((A :: Bp :: D :: Dp :: nil) ++ (Oo :: B :: Bp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpDDpmtmp;try rewrite HT2 in HOoABBpDDpmtmp.
	assert(HT := rule_2 (A :: Bp :: D :: Dp :: nil) (Oo :: B :: Bp :: D :: Dp :: nil) (Bp :: D :: Dp :: nil) 4 3 3 HOoABBpDDpmtmp HBpDDpmtmp HOoBBpDDpMtmp Hincl);apply HT.
}

assert(HABpDDpM : rk(A :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABpDDpm : rk(A :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HABpDDpeq HABpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDp requis par la preuve de (?)OoABCBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDDpM : rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDDpm : rk(Oo :: A :: B :: C :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCBpDDpeq HOoABCBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpDDp requis par la preuve de (?)OoABCApBpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpDDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpDDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpDDpeq HOoABCApBpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpDDp requis par la preuve de (?)ACpDDp pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpDDp requis par la preuve de (?)ACpDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpDDp requis par la preuve de (?)ACpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpm2 : rk(A :: Cp :: D :: Dp :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: D :: Dp :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpm3 : rk(A :: Cp :: D :: Dp :: nil) >= 3).
{
	assert(HACpDeq : rk(A :: Cp :: D :: nil) = 3) by (apply LACpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDmtmp : rk(A :: Cp :: D :: nil) >= 3) by (solve_hyps_min HACpDeq HACpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: nil) 3 3 HACpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -4 et 4*)
assert(HACpDDpm4 : rk(A :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoBCpDDpeq : rk(Oo :: B :: Cp :: D :: Dp :: nil) = 3) by (apply LOoBCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCpDDpMtmp : rk(Oo :: B :: Cp :: D :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCpDDpeq HOoBCpDDpM3).
	assert(HOoABCpDDpeq : rk(Oo :: A :: B :: Cp :: D :: Dp :: nil) = 4) by (apply LOoABCpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCpDDpmtmp : rk(Oo :: A :: B :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCpDDpeq HOoABCpDDpm4).
	assert(HCpDDpmtmp : rk(Cp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HCpDDpeq HCpDDpm3).
	assert(Hincl : incl (Cp :: D :: Dp :: nil) (list_inter (A :: Cp :: D :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Cp :: D :: Dp :: nil) (A :: Cp :: D :: Dp :: Oo :: B :: Cp :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Cp :: D :: Dp :: Oo :: B :: Cp :: D :: Dp :: nil) ((A :: Cp :: D :: Dp :: nil) ++ (Oo :: B :: Cp :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCpDDpmtmp;try rewrite HT2 in HOoABCpDDpmtmp.
	assert(HT := rule_2 (A :: Cp :: D :: Dp :: nil) (Oo :: B :: Cp :: D :: Dp :: nil) (Cp :: D :: Dp :: nil) 4 3 3 HOoABCpDDpmtmp HCpDDpmtmp HOoBCpDDpMtmp Hincl);apply HT.
}

assert(HACpDDpM : rk(A :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpDDpm : rk(A :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HACpDDpeq HACpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDDp requis par la preuve de (?)OoABCCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDDpm4 : rk(Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpDDpM : rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDDpm : rk(Oo :: A :: B :: C :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCCpDDpeq HOoABCCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpDDp requis par la preuve de (?)OoABCApCpDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpDDpM : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpDDpm : rk(Oo :: A :: B :: C :: Ap :: Cp :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpDDpeq HOoABCApCpDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDDp requis par la preuve de (?)OoABCApabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDDpm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabDDpM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDDpm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApabDDpeq HOoABCApabDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpabDDp *)
(* dans constructLemma(), requis par LOoACApBpabDDp *)
(* dans la couche 0 *)
Lemma LOoABCApBpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDDp requis par la preuve de (?)OoABCApBpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabDDpM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDDpm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDDp requis par la preuve de (?)OoACApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDDp requis par la preuve de (?)OoACApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDDp requis par la preuve de (?)OoACApBpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDDpm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDDpm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABCApBpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDDpm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABCApBpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDDpmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpabDDpM : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpabDDpm : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoACApBpabDDpeq HOoACApBpabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDDp requis par la preuve de (?)OoBCApBpabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDDpm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABCApBpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDDp requis par la preuve de (?)OoCApBpabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDDpm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDDpmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDDpeq HOoBCApBpabDDpm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDDpmtmp;try rewrite HT2 in HOoBCApBpabDDpmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDDpmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABCApBpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpeq HOoABCApBpabDDpm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpmtmp;try rewrite HT2 in HOoABCApBpabDDpmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDDpmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDDpeq : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) = 4) by (apply LOoACApBpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpabDDpmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoACApBpabDDpeq HOoACApBpabDDpm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDDpmtmp;try rewrite HT2 in HOoACApBpabDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDDpmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

assert(HOoCApBpabDDpM : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpabDDpm : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoCApBpabDDpeq HOoCApBpabDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCpabDDp *)
(* dans la couche 0 *)
Lemma LOoBApCpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpabDDp requis par la preuve de (?)OoBApCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpabDDp requis par la preuve de (?)OoBApCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpabDDp requis par la preuve de (?)OoBApCpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpm2 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpabDDpm3 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBApCpabDDpm4 : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) = 4) by (apply LOoABApCpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDDpmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpeq HOoABApCpabDDpm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpmtmp;try rewrite HT2 in HOoABApCpabDDpmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (B :: ab :: nil) 4 2 2 HOoABApCpabDDpmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBApCpabDDpM : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpabDDpm : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBApCpabDDpeq HOoBApCpabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Cp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDDp requis par la preuve de (?)OoABCApCpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCpabDDp requis par la preuve de (?)OoBCpabDDp pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpm2 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApCpabDDpmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoABCApCpabDDpeq HOoABCApCpabDDpm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Cp :: ab :: D :: Dp :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpabDDpmtmp;try rewrite HT2 in HOoABCApCpabDDpmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil) (Oo :: nil) 4 1 3 HOoABCApCpabDDpmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBCpabDDpm3 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: nil) >= 3).
{
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil) 3 3 HOoBabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ab :: D :: Dp ::  de rang :  4 et 4 	 AiB : Oo :: B :: ab ::  de rang :  3 et 3 	 A : Oo :: B :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoBCpabDDpm4 : rk(Oo :: B :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoBApabeq : rk(Oo :: B :: Ap :: ab :: nil) = 3) by (apply LOoBApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApabMtmp : rk(Oo :: B :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoBApabeq HOoBApabM3).
	assert(HOoBApCpabDDpeq : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) = 4) by (apply LOoBApCpabDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApCpabDDpmtmp : rk(Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4) by (solve_hyps_min HOoBApCpabDDpeq HOoBApCpabDDpm4).
	assert(HOoBabeq : rk(Oo :: B :: ab :: nil) = 3) by (apply LOoBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBabmtmp : rk(Oo :: B :: ab :: nil) >= 3) by (solve_hyps_min HOoBabeq HOoBabm3).
	assert(Hincl : incl (Oo :: B :: ab :: nil) (list_inter (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ab :: D :: Dp :: nil) (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Ap :: ab :: Oo :: B :: Cp :: ab :: D :: Dp :: nil) ((Oo :: B :: Ap :: ab :: nil) ++ (Oo :: B :: Cp :: ab :: D :: Dp :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpabDDpmtmp;try rewrite HT2 in HOoBApCpabDDpmtmp.
	assert(HT := rule_4 (Oo :: B :: Ap :: ab :: nil) (Oo :: B :: Cp :: ab :: D :: Dp :: nil) (Oo :: B :: ab :: nil) 4 3 3 HOoBApCpabDDpmtmp HOoBabmtmp HOoBApabMtmp Hincl); apply HT.
}

assert(HOoBCpabDDpM : rk(Oo :: B :: Cp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCpabDDpm : rk(Oo :: B :: Cp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoBCpabDDpeq HOoBCpabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpabDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpabDDp requis par la preuve de (?)OoABCApCpabDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpabDDpm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpabDDpM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpabDDpm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ab :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApCpabDDpeq HOoABCApCpabDDpm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApacDDp : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDDp requis par la preuve de (?)OoABCApacDDp pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDDpm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: Dp :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDDpM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDDpm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: Dp ::  nil) >= 1) by (solve_hyps_min HOoABCApacDDpeq HOoABCApacDDpm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoad *)
(* dans la couche 0 *)
Lemma LOoADad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoABCBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoADad requis par la preuve de (?)OoADad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADad requis par la preuve de (?)OoADad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoADadM3 : rk(Oo :: A :: D :: ad :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: D :: ad :: nil) ((Oo :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HOoMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoADadm2 : rk(Oo :: A :: D :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpDadmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpDadeq HOoABCBpDadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: D :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDadmtmp;try rewrite HT2 in HOoABCBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpDadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADadm3 : rk(Oo :: A :: D :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoADadM : rk(Oo :: A :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADadm : rk(Oo :: A :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoADadeq HOoADadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Ooad requis par la preuve de (?)Ooad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoadm2 : rk(Oo :: ad :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoADadeq : rk(Oo :: A :: D :: ad :: nil) = 3) by (apply LOoADad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADadmtmp : rk(Oo :: A :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoADadeq HOoADadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: ad :: nil) (Oo :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: ad :: A :: D :: ad :: nil) ((Oo :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoADadmtmp;try rewrite HT2 in HOoADadmtmp.
	assert(HT := rule_2 (Oo :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HOoADadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoadM : rk(Oo :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HOoadeq HOoadM2).
assert(HOoadm : rk(Oo :: ad ::  nil) >= 1) by (solve_hyps_min HOoadeq HOoadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAad *)
(* dans la couche 0 *)
Lemma LAApDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDpad requis par la preuve de (?)AApDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApDpadM3 : rk(A :: Ap :: Dp :: ad :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Dp :: ad :: nil) ((A :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HAMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpadm2 : rk(A :: Ap :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDpadm3 : rk(A :: Ap :: Dp :: ad :: nil) >= 3).
{
	assert(HAApDpmtmp : rk(A :: Ap :: Dp :: nil) >= 3) by (solve_hyps_min HAApDpeq HAApDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Dp :: nil) (A :: Ap :: Dp :: ad :: nil) 3 3 HAApDpmtmp Hcomp Hincl);apply HT.
}

assert(HAApDpadM : rk(A :: Ap :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDpadm : rk(A :: Ap :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HAApDpadeq HAApDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Aad requis par la preuve de (?)Aad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HAadm2 : rk(A :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HAApDpadeq : rk(A :: Ap :: Dp :: ad :: nil) = 3) by (apply LAApDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDpadmtmp : rk(A :: Ap :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HAApDpadeq HAApDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (A :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Dp :: ad :: nil) (A :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ad :: Ap :: Dp :: ad :: nil) ((A :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDpadmtmp;try rewrite HT2 in HAApDpadmtmp.
	assert(HT := rule_2 (A :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HAApDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HAadM : rk(A :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HAadeq HAadM2).
assert(HAadm : rk(A :: ad ::  nil) >= 1) by (solve_hyps_min HAadeq HAadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBad *)
(* dans la couche 0 *)
Lemma LOoABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDad requis par la preuve de (?)OoABApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDad requis par la preuve de (?)OoABApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadm2 : rk(Oo :: A :: B :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadm3 : rk(Oo :: A :: B :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDad requis par la preuve de (?)OoABDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: ad ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABDadm2 : rk(Oo :: A :: B :: D :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDadmtmp : rk(Oo :: A :: B :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HOoABApDadeq HOoABApDadm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDadmtmp;try rewrite HT2 in HOoABApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: ad :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApDadmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDadm3 : rk(Oo :: A :: B :: D :: ad :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDadmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDadmtmp;try rewrite HT2 in HOoABCCpDadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpDadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABDadm4 : rk(Oo :: A :: B :: D :: ad :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABDadM : rk(Oo :: A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDadm : rk(Oo :: A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABDadeq HOoABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoBad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBad requis par la preuve de (?)OoBad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBadm2 : rk(Oo :: B :: ad :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: ad :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApadmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoBadm3 : rk(Oo :: B :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: ad :: A :: D :: ad :: nil) ((Oo :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: B :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoABDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoBadM : rk(Oo :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBadeq HOoBadM3).
assert(HOoBadm : rk(Oo :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoBadeq HOoBadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABad *)
(* dans la couche 0 *)
Lemma LABDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDad requis par la preuve de (?)ABDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDad requis par la preuve de (?)ABDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDadM3 : rk(A :: B :: D :: ad :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (B :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: A :: D :: ad :: nil) ((B :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HBMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadm2 : rk(A :: B :: D :: ad :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: ad :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadm3 : rk(A :: B :: D :: ad :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: ad :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABDadM : rk(A :: B :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDadm : rk(A :: B :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABDadeq HABDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApad requis par la preuve de (?)ABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm2 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm3 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABad requis par la preuve de (?)ABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABadm2 : rk(A :: B :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadmtmp : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoABApadeq HOoABApadm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadmtmp;try rewrite HT2 in HOoABApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: nil) (A :: B :: nil) 3 2 3 HOoABApadmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABadm3 : rk(A :: B :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABDadeq : rk(A :: B :: D :: ad :: nil) = 3) by (apply LABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDadmtmp : rk(A :: B :: D :: ad :: nil) >= 3) by (solve_hyps_min HABDadeq HABDadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: nil) (A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ad :: A :: D :: ad :: nil) ((A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDadmtmp;try rewrite HT2 in HABDadmtmp.
	assert(HT := rule_2 (A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HABadM : rk(A :: B :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HABadeq HABadM3).
assert(HABadm : rk(A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HABadeq HABadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApad requis par la preuve de (?)OoABApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm2 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadm3 : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABad requis par la preuve de (?)OoABad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABadm2 : rk(Oo :: A :: B :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadmtmp : rk(Oo :: A :: B :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HOoABApadeq HOoABApadm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadmtmp;try rewrite HT2 in HOoABApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ad :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApadmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABadm3 : rk(Oo :: A :: B :: ad :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoABadm4 : rk(Oo :: A :: B :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoABDadeq : rk(Oo :: A :: B :: D :: ad :: nil) = 4) by (apply LOoABDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDadmtmp : rk(Oo :: A :: B :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABDadeq HOoABDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: nil) (Oo :: A :: B :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ad :: A :: D :: ad :: nil) ((Oo :: A :: B :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadmtmp;try rewrite HT2 in HOoABDadmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HOoABDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoABadM : rk(Oo :: A :: B :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABadm : rk(Oo :: A :: B :: ad ::  nil) >= 1) by (solve_hyps_min HOoABadeq HOoABadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCad *)
(* dans la couche 0 *)
Lemma LOoACDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACDad requis par la preuve de (?)OoACDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoABCBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACDad requis par la preuve de (?)OoACDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACDadm2 : rk(Oo :: A :: C :: D :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (B :: Ap :: Oo :: A :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: D :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: D :: ad :: nil) (nil) 4 0 2 HOoABCApDadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACDadm3 : rk(Oo :: A :: C :: D :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpDadmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpDadeq HOoABCBpDadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: D :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDadmtmp;try rewrite HT2 in HOoABCBpDadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: D :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCBpDadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACDadm4 : rk(Oo :: A :: C :: D :: ad :: nil) >= 4).
{
	assert(HOoACDmtmp : rk(Oo :: A :: C :: D :: nil) >= 4) by (solve_hyps_min HOoACDeq HOoACDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: C :: D :: nil) (Oo :: A :: C :: D :: ad :: nil) 4 4 HOoACDmtmp Hcomp Hincl);apply HT.
}

assert(HOoACDadM : rk(Oo :: A :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACDadm : rk(Oo :: A :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoACDadeq HOoACDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCad requis par la preuve de (?)OoCad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoCad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCad requis par la preuve de (?)OoCad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCadm2 : rk(Oo :: C :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApadmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HOoCadm3 : rk(Oo :: C :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoACDadeq : rk(Oo :: A :: C :: D :: ad :: nil) = 4) by (apply LOoACDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACDadmtmp : rk(Oo :: A :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoACDadeq HOoACDadm4).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Oo :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: ad :: nil) (Oo :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: ad :: A :: D :: ad :: nil) ((Oo :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDadmtmp;try rewrite HT2 in HOoACDadmtmp.
	assert(HT := rule_2 (Oo :: C :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 4 1 2 HOoACDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoCadM : rk(Oo :: C :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCadeq HOoCadM3).
assert(HOoCadm : rk(Oo :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoCadeq HOoCadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACad *)
(* dans la couche 0 *)
Lemma LACDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDad requis par la preuve de (?)ACDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDad requis par la preuve de (?)ACDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDad requis par la preuve de (?)ACDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDadM3 : rk(A :: C :: D :: ad :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: ad :: nil) (C :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: A :: D :: ad :: nil) ((C :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HCMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDadm2 : rk(A :: C :: D :: ad :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: D :: ad :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDadm3 : rk(A :: C :: D :: ad :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: D :: ad :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACDadM : rk(A :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACDadm : rk(A :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HACDadeq HACDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACad requis par la preuve de (?)ACad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApad requis par la preuve de (?)ACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApadm2 : rk(A :: B :: C :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApadm4 : rk(A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACad requis par la preuve de (?)ACad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACadm2 : rk(A :: C :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApadmtmp : rk(A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HABCApadeq HABCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ad :: nil) (B :: Ap :: A :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ad :: nil) ((B :: Ap :: nil) ++ (A :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApadmtmp;try rewrite HT2 in HABCApadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ad :: nil) (nil) 4 0 2 HABCApadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HACadm3 : rk(A :: C :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACDadeq : rk(A :: C :: D :: ad :: nil) = 3) by (apply LACDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDadmtmp : rk(A :: C :: D :: ad :: nil) >= 3) by (solve_hyps_min HACDadeq HACDadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: ad :: nil) (A :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ad :: A :: D :: ad :: nil) ((A :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDadmtmp;try rewrite HT2 in HACDadmtmp.
	assert(HT := rule_2 (A :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HACDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HACadM : rk(A :: C :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HACadeq HACadM3).
assert(HACadm : rk(A :: C :: ad ::  nil) >= 1) by (solve_hyps_min HACadeq HACadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACad requis par la preuve de (?)OoACad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoABCBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpadm4 : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACad requis par la preuve de (?)OoACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoACad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACad requis par la preuve de (?)OoACad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACadm2 : rk(Oo :: A :: C :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (B :: Ap :: Oo :: A :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: ad :: nil) (nil) 4 0 2 HOoABCApadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACadm3 : rk(Oo :: A :: C :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCBpadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HOoACadm4 : rk(Oo :: A :: C :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HOoACDadeq : rk(Oo :: A :: C :: D :: ad :: nil) = 4) by (apply LOoACDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACDadmtmp : rk(Oo :: A :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoACDadeq HOoACDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: D :: ad :: nil) (Oo :: A :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: ad :: A :: D :: ad :: nil) ((Oo :: A :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACDadmtmp;try rewrite HT2 in HOoACDadmtmp.
	assert(HT := rule_2 (Oo :: A :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HOoACDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HOoACadM : rk(Oo :: A :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACadm : rk(Oo :: A :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoACadeq HOoACadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCad *)
(* dans constructLemma(), requis par LABCDad *)
(* dans la couche 0 *)
Lemma LOoABCDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCDad requis par la preuve de (?)OoABCDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCDadm4 : rk(Oo :: A :: B :: C :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCDadM : rk(Oo :: A :: B :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCDadm : rk(Oo :: A :: B :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCDadeq HOoABCDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCDad requis par la preuve de (?)ABCDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)ABCDad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCDad requis par la preuve de (?)ABCDad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCDadm3 : rk(A :: B :: C :: D :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDadmtmp;try rewrite HT2 in HOoABCApDadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: D :: ad :: nil) (A :: nil) 4 1 2 HOoABCApDadmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: D :: ad ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCDadm4 : rk(A :: B :: C :: D :: ad :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCDadeq : rk(Oo :: A :: B :: C :: D :: ad :: nil) = 4) by (apply LOoABCDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCDadmtmp : rk(Oo :: A :: B :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoABCDadeq HOoABCDadm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: D :: ad :: nil) (Oo :: B :: C :: D :: A :: B :: C :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: D :: ad :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCDadmtmp;try rewrite HT2 in HOoABCDadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: D :: ad :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCDadmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HABCDadM : rk(A :: B :: C :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCDadm : rk(A :: B :: C :: D :: ad ::  nil) >= 1) by (solve_hyps_min HABCDadeq HABCDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCad requis par la preuve de (?)ABCad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApad requis par la preuve de (?)ABCad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCad requis par la preuve de (?)ABCad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCadm3 : rk(A :: B :: C :: ad :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ad :: nil) (A :: nil) 4 1 2 HOoABCApadmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HABCadm4 : rk(A :: B :: C :: ad :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HABCDadeq : rk(A :: B :: C :: D :: ad :: nil) = 4) by (apply LABCDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCDadmtmp : rk(A :: B :: C :: D :: ad :: nil) >= 4) by (solve_hyps_min HABCDadeq HABCDadm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: B :: C :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: D :: ad :: nil) (A :: B :: C :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: C :: ad :: A :: D :: ad :: nil) ((A :: B :: C :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCDadmtmp;try rewrite HT2 in HABCDadmtmp.
	assert(HT := rule_2 (A :: B :: C :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 4 2 2 HABCDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HABCadM : rk(A :: B :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCadm : rk(A :: B :: C :: ad ::  nil) >= 1) by (solve_hyps_min HABCadeq HABCadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCad requis par la preuve de (?)OoABCad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCadm4 : rk(Oo :: A :: B :: C :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCadM : rk(Oo :: A :: B :: C :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCadm : rk(Oo :: A :: B :: C :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCadeq HOoABCadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApad *)
(* dans la couche 0 *)
Lemma LAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApDad requis par la preuve de (?)AApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApDad requis par la preuve de (?)AApDad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HAApDadM3 : rk(A :: Ap :: D :: ad :: nil) <= 3).
{
	assert(HApMtmp : rk(Ap :: nil) <= 1) by (solve_hyps_max HApeq HApM1).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: A :: D :: ad :: nil) ((Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: nil) (A :: D :: ad :: nil) (nil) 1 2 0 HApMtmp HADadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDadm2 : rk(A :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApDadm3 : rk(A :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HAApDmtmp : rk(A :: Ap :: D :: nil) >= 3) by (solve_hyps_min HAApDeq HAApDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: D :: nil) (A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: D :: nil) (A :: Ap :: D :: ad :: nil) 3 3 HAApDmtmp Hcomp Hincl);apply HT.
}

assert(HAApDadM : rk(A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApDadm : rk(A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HAApDadeq HAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Apad requis par la preuve de (?)Apad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HApadm2 : rk(Ap :: ad :: nil) >= 2).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAApDadeq : rk(A :: Ap :: D :: ad :: nil) = 3) by (apply LAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDadmtmp : rk(A :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HAApDadeq HAApDadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (Ap :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (Ap :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ad :: A :: D :: ad :: nil) ((Ap :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDadmtmp;try rewrite HT2 in HAApDadmtmp.
	assert(HT := rule_2 (Ap :: ad :: nil) (A :: D :: ad :: nil) (ad :: nil) 3 1 2 HAApDadmtmp Hadmtmp HADadMtmp Hincl);apply HT.
}

assert(HApadM : rk(Ap :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HApadeq HApadM2).
assert(HApadm : rk(Ap :: ad ::  nil) >= 1) by (solve_hyps_min HApadeq HApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour AApad requis par la preuve de (?)AApad pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour AApad requis par la preuve de (?)AApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApadm2 : rk(A :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HAApadm3 : rk(A :: Ap :: ad :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAApDadeq : rk(A :: Ap :: D :: ad :: nil) = 3) by (apply LAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApDadmtmp : rk(A :: Ap :: D :: ad :: nil) >= 3) by (solve_hyps_min HAApDadeq HAApDadm3).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: Ap :: ad :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: D :: ad :: nil) (A :: Ap :: ad :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: ad :: A :: D :: ad :: nil) ((A :: Ap :: ad :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApDadmtmp;try rewrite HT2 in HAApDadmtmp.
	assert(HT := rule_2 (A :: Ap :: ad :: nil) (A :: D :: ad :: nil) (A :: ad :: nil) 3 2 2 HAApDadmtmp HAadmtmp HADadMtmp Hincl);apply HT.
}

assert(HAApadM : rk(A :: Ap :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAApadeq HAApadM3).
assert(HAApadm : rk(A :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HAApadeq HAApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApad *)
(* dans la couche 0 *)
Lemma LOoABCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApad requis par la preuve de (?)OoABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApadm4 : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApadM : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApadm : rk(Oo :: A :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApadeq HOoABCApadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApad requis par la preuve de (?)ABCApad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApadm2 : rk(A :: B :: C :: Ap :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApadm4 : rk(A :: B :: C :: Ap :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApadeq : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) = 4) by (apply LOoABCApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApadmtmp : rk(Oo :: A :: B :: C :: Ap :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApadeq HOoABCApadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApadmtmp;try rewrite HT2 in HOoABCApadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApadM : rk(A :: B :: C :: Ap :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApadm : rk(A :: B :: C :: Ap :: ad ::  nil) >= 1) by (solve_hyps_min HABCApadeq HABCApadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpad *)
(* dans la couche 0 *)
Lemma LOoABpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacDDpad requis par la preuve de (?)OoABCApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacDDpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacDDpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacDDpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacDDpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacDDpadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacDDpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacDDpadeq HOoACApBpacDDpadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacDDpadmtmp;try rewrite HT2 in HOoACApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacDDpadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm2 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm3 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacDDpadm4 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacDDpadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacDDpadeq HOoAApBpacDDpadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacDDpadmtmp;try rewrite HT2 in HOoAApBpacDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacDDpadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpDDpad requis par la preuve de (?)OoABpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpDDpadm2 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: ac ::   de rang : 2 et 2 *)
assert(HOoABpDDpadm3 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBpaceq : rk(Bp :: ac :: nil) = 2) by (apply LBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpacMtmp : rk(Bp :: ac :: nil) <= 2) by (solve_hyps_max HBpaceq HBpacM2).
	assert(HOoABpacDDpadmtmp : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpacDDpadeq HOoABpacDDpadm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: ac :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) (Bp :: ac :: Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: ac :: Oo :: A :: Bp :: D :: Dp :: ad :: nil) ((Bp :: ac :: nil) ++ (Oo :: A :: Bp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpacDDpadmtmp;try rewrite HT2 in HOoABpacDDpadmtmp.
	assert(HT := rule_4 (Bp :: ac :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Bp :: nil) 4 1 2 HOoABpacDDpadmtmp HBpmtmp HBpacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpDDpadm4 : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABpDDpeq : rk(A :: Bp :: D :: Dp :: nil) = 4) by (apply LABpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpDDpmtmp : rk(A :: Bp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HABpDDpeq HABpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: D :: Dp :: nil) (Oo :: A :: Bp :: D :: Dp :: ad :: nil) 4 4 HABpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABpDDpadM : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpDDpadm : rk(Oo :: A :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBpad *)
(* dans la couche 0 *)
Lemma LOoADDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoADDpad requis par la preuve de (?)OoADDpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoADDpad requis par la preuve de (?)OoADDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpDDpad requis par la preuve de (?)OoADDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDpad requis par la preuve de (?)OoABCBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoADDpad requis par la preuve de (?)OoADDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoADDpadm2 : rk(Oo :: A :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpDDpadeq HOoABCBpDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpDDpadmtmp;try rewrite HT2 in HOoABCBpDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoADDpadm3 : rk(Oo :: A :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: D :: Dp :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoADDpadM3 : rk(Oo :: A :: D :: Dp :: ad :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: D :: Dp :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: A :: D :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (A :: D :: ad :: nil) (D :: nil) 2 2 1 HOoDDpMtmp HADadMtmp HDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoADDpadM : rk(Oo :: A :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoADDpadm : rk(Oo :: A :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoADDpadeq HOoADDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpad requis par la preuve de (?)OoABCApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoBpad requis par la preuve de (?)OoBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoBpadm2 : rk(Oo :: Bp :: ad :: nil) >= 2).
{
	assert(HOoACApCpeq : rk(Oo :: A :: C :: Ap :: Cp :: nil) = 3) by (apply LOoACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApCpMtmp : rk(Oo :: A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HOoACApCpeq HOoACApCpM3).
	assert(HOoACApBpCpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpCpadeq HOoACApBpCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (Oo :: A :: C :: Ap :: Cp :: Oo :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Cp :: Oo :: Bp :: ad :: nil) ((Oo :: A :: C :: Ap :: Cp :: nil) ++ (Oo :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpadmtmp;try rewrite HT2 in HOoACApBpCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: Cp :: nil) (Oo :: Bp :: ad :: nil) (Oo :: nil) 4 1 3 HOoACApBpCpadmtmp HOomtmp HOoACApCpMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoBpadm3 : rk(Oo :: Bp :: ad :: nil) >= 3).
{
	assert(HOoADDpadeq : rk(Oo :: A :: D :: Dp :: ad :: nil) = 3) by (apply LOoADDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADDpadMtmp : rk(Oo :: A :: D :: Dp :: ad :: nil) <= 3) by (solve_hyps_max HOoADDpadeq HOoADDpadM3).
	assert(HOoABpDDpadeq : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpDDpadmtmp : rk(Oo :: A :: Bp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpDDpadeq HOoABpDDpadm4).
	assert(HOoadeq : rk(Oo :: ad :: nil) = 2) by (apply LOoad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoadmtmp : rk(Oo :: ad :: nil) >= 2) by (solve_hyps_min HOoadeq HOoadm2).
	assert(Hincl : incl (Oo :: ad :: nil) (list_inter (Oo :: Bp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: D :: Dp :: ad :: nil) (Oo :: Bp :: ad :: Oo :: A :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Bp :: ad :: Oo :: A :: D :: Dp :: ad :: nil) ((Oo :: Bp :: ad :: nil) ++ (Oo :: A :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpDDpadmtmp;try rewrite HT2 in HOoABpDDpadmtmp.
	assert(HT := rule_2 (Oo :: Bp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: ad :: nil) 4 2 3 HOoABpDDpadmtmp HOoadmtmp HOoADDpadMtmp Hincl);apply HT.
}

assert(HOoBpadM : rk(Oo :: Bp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoBpadeq HOoBpadM3).
assert(HOoBpadm : rk(Oo :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBpadeq HOoBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans constructLemma(), requis par LOoABBpad *)
(* dans la couche 0 *)
Lemma LOoABCBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpad requis par la preuve de (?)OoABCBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpadm4 : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpadM : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpadm : rk(Oo :: A :: B :: C :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApBpad requis par la preuve de (?)OoABApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApBpad requis par la preuve de (?)OoABApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpadm2 : rk(Oo :: A :: B :: Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApBpadm3 : rk(Oo :: A :: B :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Bp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABBpad requis par la preuve de (?)OoABBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Bp :: ad ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABBpadm2 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApBpadmtmp : rk(Oo :: A :: B :: Ap :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoABApBpadeq HOoABApBpadm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Bp :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApBpadmtmp;try rewrite HT2 in HOoABApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApBpadmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABBpadm3 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HABBpmtmp : rk(A :: B :: Bp :: nil) >= 3) by (solve_hyps_min HABBpeq HABBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Bp :: nil) (Oo :: A :: B :: Bp :: ad :: nil) 3 3 HABBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: B :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoABBpadm4 : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOoABadeq : rk(Oo :: A :: B :: ad :: nil) = 4) by (apply LOoABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABadmtmp : rk(Oo :: A :: B :: ad :: nil) >= 4) by (solve_hyps_min HOoABadeq HOoABadm4).
	assert(Hincl : incl (Oo :: A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: B :: ad :: nil) 4 4 4 HOoABCBpadmtmp HOoABadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoABBpadM : rk(Oo :: A :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABBpadm : rk(Oo :: A :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABBpadeq HOoABBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpad *)
(* dans la couche 0 *)
Lemma LOoBBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBBpad requis par la preuve de (?)OoBBpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBBpadm2 : rk(Oo :: B :: Bp :: ad :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApBpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpadmtmp;try rewrite HT2 in HOoABCApBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApBpadmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoBBpadM3 : rk(Oo :: B :: Bp :: ad :: nil) <= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: B :: Bp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: Bp :: nil) (ad :: nil) (nil) 2 1 0 HOoBBpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoBBpadm3 : rk(Oo :: B :: Bp :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCBpadeq : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) = 4) by (apply LOoABCBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCBpadmtmp : rk(Oo :: A :: B :: C :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpadeq HOoABCBpadm4).
	assert(HOoBadeq : rk(Oo :: B :: ad :: nil) = 3) by (apply LOoBad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBadmtmp : rk(Oo :: B :: ad :: nil) >= 3) by (solve_hyps_min HOoBadeq HOoBadm3).
	assert(Hincl : incl (Oo :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpadmtmp;try rewrite HT2 in HOoABCBpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: B :: ad :: nil) 4 3 4 HOoABCBpadmtmp HOoBadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoBBpadM : rk(Oo :: B :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBBpadm : rk(Oo :: B :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBBpadeq HOoBBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoABpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacad requis par la preuve de (?)OoABCApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacadeq HOoACApBpacadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacadmtmp;try rewrite HT2 in HOoACApBpacadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm2 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm3 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacadm4 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacadeq HOoAApBpacadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacadmtmp;try rewrite HT2 in HOoAApBpacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpad requis par la preuve de (?)OoABpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpadm2 : rk(Oo :: A :: Bp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Bp ::  de rang :  1 et 1 	 A : Bp :: ac ::   de rang : 2 et 2 *)
assert(HOoABpadm3 : rk(Oo :: A :: Bp :: ad :: nil) >= 3).
{
	assert(HBpaceq : rk(Bp :: ac :: nil) = 2) by (apply LBpac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpacMtmp : rk(Bp :: ac :: nil) <= 2) by (solve_hyps_max HBpaceq HBpacM2).
	assert(HOoABpacadmtmp : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABpacadeq HOoABpacadm4).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Bp :: ac :: nil) (Oo :: A :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Bp :: ac :: ad :: nil) (Bp :: ac :: Oo :: A :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Bp :: ac :: Oo :: A :: Bp :: ad :: nil) ((Bp :: ac :: nil) ++ (Oo :: A :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABpacadmtmp;try rewrite HT2 in HOoABpacadmtmp.
	assert(HT := rule_4 (Bp :: ac :: nil) (Oo :: A :: Bp :: ad :: nil) (Bp :: nil) 4 1 2 HOoABpacadmtmp HBpmtmp HBpacMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoABpadm4 : rk(Oo :: A :: Bp :: ad :: nil) >= 4).
{
	assert(HOoBBpadeq : rk(Oo :: B :: Bp :: ad :: nil) = 3) by (apply LOoBBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBBpadMtmp : rk(Oo :: B :: Bp :: ad :: nil) <= 3) by (solve_hyps_max HOoBBpadeq HOoBBpadM3).
	assert(HOoABBpadeq : rk(Oo :: A :: B :: Bp :: ad :: nil) = 4) by (apply LOoABBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABBpadmtmp : rk(Oo :: A :: B :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABBpadeq HOoABBpadm4).
	assert(HOoBpadeq : rk(Oo :: Bp :: ad :: nil) = 3) by (apply LOoBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBpadmtmp : rk(Oo :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HOoBpadeq HOoBpadm3).
	assert(Hincl : incl (Oo :: Bp :: ad :: nil) (list_inter (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Bp :: ad :: nil) (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Bp :: ad :: Oo :: B :: Bp :: ad :: nil) ((Oo :: A :: Bp :: ad :: nil) ++ (Oo :: B :: Bp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABBpadmtmp;try rewrite HT2 in HOoABBpadmtmp.
	assert(HT := rule_2 (Oo :: A :: Bp :: ad :: nil) (Oo :: B :: Bp :: ad :: nil) (Oo :: Bp :: ad :: nil) 4 3 3 HOoABBpadmtmp HOoBpadmtmp HOoBBpadMtmp Hincl);apply HT.
}

assert(HOoABpadM : rk(Oo :: A :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpadm : rk(Oo :: A :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpadeq HOoABpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpad *)
(* dans la couche 0 *)
Lemma LOoAApBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpDad requis par la preuve de (?)OoAApBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpDadm2 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpDadm3 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpDadm4 : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: D :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpDadM : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpDadm : rk(Oo :: A :: Ap :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApBpad *)
(* dans la couche 0 *)
Lemma LOoAApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: D :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApDad requis par la preuve de (?)OoAApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApDadm2 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoAApDadM3 : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: D :: ad :: nil) (Oo :: A :: Ap :: A :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: D :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: A :: Ap :: nil) (A :: D :: ad :: nil) (A :: nil) 2 2 1 HOoAApMtmp HADadMtmp HAmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApDadm3 : rk(Oo :: A :: Ap :: D :: ad :: nil) >= 3).
{
	assert(HOoADeq : rk(Oo :: A :: D :: nil) = 3) by (apply LOoAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADmtmp : rk(Oo :: A :: D :: nil) >= 3) by (solve_hyps_min HOoADeq HOoADm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: D :: nil) (Oo :: A :: Ap :: D :: ad :: nil) 3 3 HOoADmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApDadM : rk(Oo :: A :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApDadm : rk(Oo :: A :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApDadeq HOoAApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpad requis par la preuve de (?)ApBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApBpad requis par la preuve de (?)ApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpadm2 : rk(Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: ad :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApBpadm3 : rk(Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDadMtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3) by (solve_hyps_max HOoAApDadeq HOoAApDadM3).
	assert(HOoAApBpDadeq : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoAApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpDadmtmp : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm4).
	assert(HApadeq : rk(Ap :: ad :: nil) = 2) by (apply LApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApadmtmp : rk(Ap :: ad :: nil) >= 2) by (solve_hyps_min HApadeq HApadm2).
	assert(Hincl : incl (Ap :: ad :: nil) (list_inter (Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: D :: ad :: nil) (Ap :: Bp :: ad :: Oo :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ad :: Oo :: A :: Ap :: D :: ad :: nil) ((Ap :: Bp :: ad :: nil) ++ (Oo :: A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpDadmtmp;try rewrite HT2 in HOoAApBpDadmtmp.
	assert(HT := rule_2 (Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil) (Ap :: ad :: nil) 4 2 3 HOoAApBpDadmtmp HApadmtmp HOoAApDadMtmp Hincl);apply HT.
}

assert(HApBpadM : rk(Ap :: Bp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApBpadeq HApBpadM3).
assert(HApBpadm : rk(Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HApBpadeq HApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpad requis par la preuve de (?)AApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpadm2 : rk(A :: Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpadm3 : rk(A :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApBpadm4 : rk(A :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDadMtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3) by (solve_hyps_max HOoAApDadeq HOoAApDadM3).
	assert(HOoAApBpDadeq : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) = 4) by (apply LOoAApBpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpDadmtmp : rk(Oo :: A :: Ap :: Bp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpDadeq HOoAApBpDadm4).
	assert(HAApadeq : rk(A :: Ap :: ad :: nil) = 3) by (apply LAApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApadmtmp : rk(A :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HAApadeq HAApadm3).
	assert(Hincl : incl (A :: Ap :: ad :: nil) (list_inter (A :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: D :: ad :: nil) (A :: Ap :: Bp :: ad :: Oo :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Bp :: ad :: Oo :: A :: Ap :: D :: ad :: nil) ((A :: Ap :: Bp :: ad :: nil) ++ (Oo :: A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpDadmtmp;try rewrite HT2 in HOoAApBpDadmtmp.
	assert(HT := rule_2 (A :: Ap :: Bp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil) (A :: Ap :: ad :: nil) 4 3 3 HOoAApBpDadmtmp HAApadmtmp HOoAApDadMtmp Hincl);apply HT.
}

assert(HAApBpadM : rk(A :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpadm : rk(A :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpadeq HAApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpad requis par la preuve de (?)OoAApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpadm2 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpadm3 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpadm4 : rk(Oo :: A :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpadM : rk(Oo :: A :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpadm : rk(Oo :: A :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpadeq HOoAApBpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApBpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpad requis par la preuve de (?)OoABCApBpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpadeq HOoABCApBpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCpad *)
(* dans la couche 0 *)
Lemma LOoACpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDDpadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabDDpadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpadeq HOoABApCpabDDpadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpadmtmp;try rewrite HT2 in HOoABApCpabDDpadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabDDpadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoABCBpCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm2 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabDDpadeq HOoABCBpCpabDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabDDpadmtmp;try rewrite HT2 in HOoABCBpCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabDDpadm3 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm4 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabDDpadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabDDpadeq HOoAApCpabDDpadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabDDpadmtmp;try rewrite HT2 in HOoAApCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabDDpadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpDDpad requis par la preuve de (?)OoABCBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpDDpad requis par la preuve de (?)OoACpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpDDpadm2 : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpDDpadeq HOoABCBpCpDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpDDpadmtmp;try rewrite HT2 in HOoABCBpCpDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoACpDDpadm3 : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoACpabDDpadmtmp : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpabDDpadeq HOoACpabDDpadm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Cp :: ab :: Oo :: A :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: A :: Cp :: D :: Dp :: ad :: nil) ((Cp :: ab :: nil) ++ (Oo :: A :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpabDDpadmtmp;try rewrite HT2 in HOoACpabDDpadmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil) (Cp :: nil) 4 1 2 HOoACpabDDpadmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpDDpadm4 : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACpDDpeq : rk(A :: Cp :: D :: Dp :: nil) = 4) by (apply LACpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpmtmp : rk(A :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HACpDDpeq HACpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: Dp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: Dp :: nil) (Oo :: A :: Cp :: D :: Dp :: ad :: nil) 4 4 HACpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HOoACpDDpadM : rk(Oo :: A :: Cp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpDDpadm : rk(Oo :: A :: Cp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpDDpadeq HOoACpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Cp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCpad requis par la preuve de (?)OoCpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabadmtmp;try rewrite HT2 in HOoABApCpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoCpad requis par la preuve de (?)OoCpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoCpadm2 : rk(Oo :: Cp :: ad :: nil) >= 2).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: Cp :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabadmtmp;try rewrite HT2 in HOoAApCpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: Cp :: ad :: nil) (Oo :: nil) 4 1 3 HOoAApCpabadmtmp HOomtmp HOoAApabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoCpadm3 : rk(Oo :: Cp :: ad :: nil) >= 3).
{
	assert(HOoADDpadeq : rk(Oo :: A :: D :: Dp :: ad :: nil) = 3) by (apply LOoADDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoADDpadMtmp : rk(Oo :: A :: D :: Dp :: ad :: nil) <= 3) by (solve_hyps_max HOoADDpadeq HOoADDpadM3).
	assert(HOoACpDDpadeq : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) = 4) by (apply LOoACpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACpDDpadmtmp : rk(Oo :: A :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpDDpadeq HOoACpDDpadm4).
	assert(HOoadeq : rk(Oo :: ad :: nil) = 2) by (apply LOoad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoadmtmp : rk(Oo :: ad :: nil) >= 2) by (solve_hyps_min HOoadeq HOoadm2).
	assert(Hincl : incl (Oo :: ad :: nil) (list_inter (Oo :: Cp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: D :: Dp :: ad :: nil) (Oo :: Cp :: ad :: Oo :: A :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: Cp :: ad :: Oo :: A :: D :: Dp :: ad :: nil) ((Oo :: Cp :: ad :: nil) ++ (Oo :: A :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpDDpadmtmp;try rewrite HT2 in HOoACpDDpadmtmp.
	assert(HT := rule_2 (Oo :: Cp :: ad :: nil) (Oo :: A :: D :: Dp :: ad :: nil) (Oo :: ad :: nil) 4 2 3 HOoACpDDpadmtmp HOoadmtmp HOoADDpadMtmp Hincl);apply HT.
}

assert(HOoCpadM : rk(Oo :: Cp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HOoCpadeq HOoCpadM3).
assert(HOoCpadm : rk(Oo :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoCpadeq HOoCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpad *)
(* dans constructLemma(), requis par LOoACCpad *)
(* dans la couche 0 *)
Lemma LOoABCCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpad requis par la preuve de (?)OoABCCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpadm4 : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpadM : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpadm : rk(Oo :: A :: B :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoABCBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoABCApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACCpad requis par la preuve de (?)OoACCpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACCpadm2 : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApCpadeq HOoABCApCpadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Cp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpadmtmp;try rewrite HT2 in HOoABCApCpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Cp :: ad :: nil) (nil) 4 0 2 HOoABCApCpadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: Bp ::   de rang : 2 et 2 *)
assert(HOoACCpadm3 : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 3).
{
	assert(HOoBBpMtmp : rk(Oo :: B :: Bp :: nil) <= 2) by (solve_hyps_max HOoBBpeq HOoBBpM2).
	assert(HOoABCBpCpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpadeq HOoABCBpCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Bp :: Oo :: A :: C :: Cp :: ad :: nil) ((Oo :: B :: Bp :: nil) ++ (Oo :: A :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpadmtmp;try rewrite HT2 in HOoABCBpCpadmtmp.
	assert(HT := rule_4 (Oo :: B :: Bp :: nil) (Oo :: A :: C :: Cp :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCBpCpadmtmp HOomtmp HOoBBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: C :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoACCpadm4 : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCCpadeq : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) = 4) by (apply LOoABCCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	assert(HOoACadeq : rk(Oo :: A :: C :: ad :: nil) = 4) by (apply LOoACad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACadmtmp : rk(Oo :: A :: C :: ad :: nil) >= 4) by (solve_hyps_min HOoACadeq HOoACadm4).
	assert(Hincl : incl (Oo :: A :: C :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: A :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: A :: C :: Cp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: A :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: A :: C :: Cp :: ad :: nil) (Oo :: A :: C :: ad :: nil) 4 4 4 HOoABCCpadmtmp HOoACadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoACCpadM : rk(Oo :: A :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACCpadm : rk(Oo :: A :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACCpadeq HOoACCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpad *)
(* dans la couche 0 *)
Lemma LOoCCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Cp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoCCpad requis par la preuve de (?)OoCCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCCpad requis par la preuve de (?)OoCCpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoCCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoABCApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCCpad requis par la preuve de (?)OoCCpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoCCpadm2 : rk(Oo :: C :: Cp :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABCApCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApCpadeq HOoABCApCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: C :: Cp :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApCpadmtmp;try rewrite HT2 in HOoABCApCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: C :: Cp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCApCpadmtmp HOomtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HOoCCpadM3 : rk(Oo :: C :: Cp :: ad :: nil) <= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: C :: Cp :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Cp :: ad :: nil) (Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: C :: Cp :: nil) (ad :: nil) (nil) 2 1 0 HOoCCpMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: C :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HOoCCpadm3 : rk(Oo :: C :: Cp :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCCpadeq : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) = 4) by (apply LOoABCCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCCpadmtmp : rk(Oo :: A :: B :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpadeq HOoABCCpadm4).
	assert(HOoCadeq : rk(Oo :: C :: ad :: nil) = 3) by (apply LOoCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCadmtmp : rk(Oo :: C :: ad :: nil) >= 3) by (solve_hyps_min HOoCadeq HOoCadm3).
	assert(Hincl : incl (Oo :: C :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (Oo :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ad :: nil) (Oo :: A :: B :: C :: ad :: Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: Oo :: C :: Cp :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (Oo :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpadmtmp;try rewrite HT2 in HOoABCCpadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (Oo :: C :: Cp :: ad :: nil) (Oo :: C :: ad :: nil) 4 3 4 HOoABCCpadmtmp HOoCadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HOoCCpadM : rk(Oo :: C :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCCpadm : rk(Oo :: C :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoCCpadeq HOoCCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpad requis par la preuve de (?)OoACpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabadmtmp;try rewrite HT2 in HOoABApCpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoABCBpCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabadm2 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabadeq HOoABCBpCpabadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabadmtmp;try rewrite HT2 in HOoABCBpCpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabadm3 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabadm4 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabadmtmp;try rewrite HT2 in HOoAApCpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoABCBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpad requis par la preuve de (?)OoACpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpadm2 : rk(Oo :: A :: Cp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpadeq HOoABCBpCpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpadmtmp;try rewrite HT2 in HOoABCBpCpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Cp ::  de rang :  1 et 1 	 A : Cp :: ab ::   de rang : 2 et 2 *)
assert(HOoACpadm3 : rk(Oo :: A :: Cp :: ad :: nil) >= 3).
{
	assert(HCpabeq : rk(Cp :: ab :: nil) = 2) by (apply LCpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpabMtmp : rk(Cp :: ab :: nil) <= 2) by (solve_hyps_max HCpabeq HCpabM2).
	assert(HOoACpabadmtmp : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoACpabadeq HOoACpabadm4).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Cp :: ab :: nil) (Oo :: A :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Cp :: ab :: ad :: nil) (Cp :: ab :: Oo :: A :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: ab :: Oo :: A :: Cp :: ad :: nil) ((Cp :: ab :: nil) ++ (Oo :: A :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACpabadmtmp;try rewrite HT2 in HOoACpabadmtmp.
	assert(HT := rule_4 (Cp :: ab :: nil) (Oo :: A :: Cp :: ad :: nil) (Cp :: nil) 4 1 2 HOoACpabadmtmp HCpmtmp HCpabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HOoACpadm4 : rk(Oo :: A :: Cp :: ad :: nil) >= 4).
{
	assert(HOoCCpadeq : rk(Oo :: C :: Cp :: ad :: nil) = 3) by (apply LOoCCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCCpadMtmp : rk(Oo :: C :: Cp :: ad :: nil) <= 3) by (solve_hyps_max HOoCCpadeq HOoCCpadM3).
	assert(HOoACCpadeq : rk(Oo :: A :: C :: Cp :: ad :: nil) = 4) by (apply LOoACCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACCpadmtmp : rk(Oo :: A :: C :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACCpadeq HOoACCpadm4).
	assert(HOoCpadeq : rk(Oo :: Cp :: ad :: nil) = 3) by (apply LOoCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCpadmtmp : rk(Oo :: Cp :: ad :: nil) >= 3) by (solve_hyps_min HOoCpadeq HOoCpadm3).
	assert(Hincl : incl (Oo :: Cp :: ad :: nil) (list_inter (Oo :: A :: Cp :: ad :: nil) (Oo :: C :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Cp :: ad :: nil) (Oo :: A :: Cp :: ad :: Oo :: C :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Cp :: ad :: Oo :: C :: Cp :: ad :: nil) ((Oo :: A :: Cp :: ad :: nil) ++ (Oo :: C :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACCpadmtmp;try rewrite HT2 in HOoACCpadmtmp.
	assert(HT := rule_2 (Oo :: A :: Cp :: ad :: nil) (Oo :: C :: Cp :: ad :: nil) (Oo :: Cp :: ad :: nil) 4 3 3 HOoACCpadmtmp HOoCpadmtmp HOoCCpadMtmp Hincl);apply HT.
}

assert(HOoACpadM : rk(Oo :: A :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpadm : rk(Oo :: A :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpadeq HOoACpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApCpad *)
(* dans la couche 0 *)
Lemma LOoAApCpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpDad requis par la preuve de (?)OoAApCpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpDad requis par la preuve de (?)OoAApCpDad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpDad requis par la preuve de (?)OoAApCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpDadm2 : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpDadm3 : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpDadm4 : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoACpadeq : rk(Oo :: A :: Cp :: ad :: nil) = 4) by (apply LOoACpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACpadmtmp : rk(Oo :: A :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpadeq HOoACpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: D :: ad :: nil) 4 4 HOoACpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApCpDadM : rk(Oo :: A :: Ap :: Cp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpDadm : rk(Oo :: A :: Ap :: Cp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpDadeq HOoAApCpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpad requis par la preuve de (?)ApCpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApCpad requis par la preuve de (?)ApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpadm2 : rk(Ap :: Cp :: ad :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ad :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HApCpadm3 : rk(Ap :: Cp :: ad :: nil) >= 3).
{
	assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDadMtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3) by (solve_hyps_max HOoAApDadeq HOoAApDadM3).
	assert(HOoAApCpDadeq : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) = 4) by (apply LOoAApCpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpDadmtmp : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpDadeq HOoAApCpDadm4).
	assert(HApadeq : rk(Ap :: ad :: nil) = 2) by (apply LApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApadmtmp : rk(Ap :: ad :: nil) >= 2) by (solve_hyps_min HApadeq HApadm2).
	assert(Hincl : incl (Ap :: ad :: nil) (list_inter (Ap :: Cp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: D :: ad :: nil) (Ap :: Cp :: ad :: Oo :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ad :: Oo :: A :: Ap :: D :: ad :: nil) ((Ap :: Cp :: ad :: nil) ++ (Oo :: A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpDadmtmp;try rewrite HT2 in HOoAApCpDadmtmp.
	assert(HT := rule_2 (Ap :: Cp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil) (Ap :: ad :: nil) 4 2 3 HOoAApCpDadmtmp HApadmtmp HOoAApDadMtmp Hincl);apply HT.
}

assert(HApCpadM : rk(Ap :: Cp :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApCpadeq HApCpadM3).
assert(HApCpadm : rk(Ap :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HApCpadeq HApCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpad requis par la preuve de (?)AApCpad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpad requis par la preuve de (?)AApCpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpad requis par la preuve de (?)AApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpadm2 : rk(A :: Ap :: Cp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpadm3 : rk(A :: Ap :: Cp :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAApCpadm4 : rk(A :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoAApDadeq : rk(Oo :: A :: Ap :: D :: ad :: nil) = 3) by (apply LOoAApDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApDadMtmp : rk(Oo :: A :: Ap :: D :: ad :: nil) <= 3) by (solve_hyps_max HOoAApDadeq HOoAApDadM3).
	assert(HOoAApCpDadeq : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) = 4) by (apply LOoAApCpDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpDadmtmp : rk(Oo :: A :: Ap :: Cp :: D :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpDadeq HOoAApCpDadm4).
	assert(HAApadeq : rk(A :: Ap :: ad :: nil) = 3) by (apply LAApad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApadmtmp : rk(A :: Ap :: ad :: nil) >= 3) by (solve_hyps_min HAApadeq HAApadm3).
	assert(Hincl : incl (A :: Ap :: ad :: nil) (list_inter (A :: Ap :: Cp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: D :: ad :: nil) (A :: Ap :: Cp :: ad :: Oo :: A :: Ap :: D :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Cp :: ad :: Oo :: A :: Ap :: D :: ad :: nil) ((A :: Ap :: Cp :: ad :: nil) ++ (Oo :: A :: Ap :: D :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpDadmtmp;try rewrite HT2 in HOoAApCpDadmtmp.
	assert(HT := rule_2 (A :: Ap :: Cp :: ad :: nil) (Oo :: A :: Ap :: D :: ad :: nil) (A :: Ap :: ad :: nil) 4 3 3 HOoAApCpDadmtmp HAApadmtmp HOoAApDadMtmp Hincl);apply HT.
}

assert(HAApCpadM : rk(A :: Ap :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpadm : rk(A :: Ap :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HAApCpadeq HAApCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpad requis par la preuve de (?)OoAApCpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpad requis par la preuve de (?)OoAApCpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpad requis par la preuve de (?)OoAApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpadm2 : rk(Oo :: A :: Ap :: Cp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpadm3 : rk(Oo :: A :: Ap :: Cp :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpadm4 : rk(Oo :: A :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoACpadeq : rk(Oo :: A :: Cp :: ad :: nil) = 4) by (apply LOoACpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACpadmtmp : rk(Oo :: A :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpadeq HOoACpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: ad :: nil) 4 4 HOoACpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApCpadM : rk(Oo :: A :: Ap :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpadm : rk(Oo :: A :: Ap :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpadeq HOoAApCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApCpad requis par la preuve de (?)OoABCApCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApCpadM : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApCpadm : rk(Oo :: A :: B :: C :: Ap :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApCpadeq HOoABCApCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpad requis par la preuve de (?)OoABCBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpadeq HOoABCBpCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACApBpCpad *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpad requis par la preuve de (?)OoABCApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpad requis par la preuve de (?)OoACApBpCpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) = 4) by (apply LOoABCApBpCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) = 4) by (apply LOoABCApBpCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpadeq HOoABCApBpCpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpadmtmp;try rewrite HT2 in HOoABCApBpCpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpadM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpadm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpadeq HOoACApBpCpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labad *)
(* dans constructLemma(), requis par LApabDpad *)
(* dans la couche 0 *)
Lemma LABApabDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpad requis par la preuve de (?)ABApabDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpad requis par la preuve de (?)ABApabDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpad requis par la preuve de (?)ABApabDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadm2 : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabDpadm4 : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) >= 4).
{
	assert(HABApDpeq : rk(A :: B :: Ap :: Dp :: nil) = 4) by (apply LABApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApDpmtmp : rk(A :: B :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HABApDpeq HABApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil) 4 4 HABApDpmtmp Hcomp Hincl);apply HT.
}

assert(HABApabDpadM : rk(A :: B :: Ap :: ab :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabDpadm : rk(A :: B :: Ap :: ab :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HABApabDpadeq HABApabDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApabDpad requis par la preuve de (?)ApabDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpad requis par la preuve de (?)ApabDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpad requis par la preuve de (?)ABApabDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpad requis par la preuve de (?)ABApabDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadm2 : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApabDpad requis par la preuve de (?)ApabDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpad requis par la preuve de (?)ApabDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HApabDpadM3 : rk(Ap :: ab :: Dp :: ad :: nil) <= 3).
{
	assert(HabMtmp : rk(ab :: nil) <= 1) by (solve_hyps_max Habeq HabM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ab :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: Dp :: ad :: nil) (ab :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: Ap :: Dp :: ad :: nil) ((ab :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HabMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpadm2 : rk(Ap :: ab :: Dp :: ad :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpadmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HABApabDpadeq HABApabDpadm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: ad :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadmtmp;try rewrite HT2 in HABApabDpadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: nil) (ab :: nil) 3 1 2 HABApabDpadmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad ::  de rang :  4 et 4 	 AiB : ab :: Dp ::  de rang :  2 et 2 	 A : A :: B :: ab :: Dp ::   de rang : 3 et 3 *)
assert(HApabDpadm3 : rk(Ap :: ab :: Dp :: ad :: nil) >= 3).
{
	assert(HABabDpeq : rk(A :: B :: ab :: Dp :: nil) = 3) by (apply LABabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDpMtmp : rk(A :: B :: ab :: Dp :: nil) <= 3) by (solve_hyps_max HABabDpeq HABabDpM3).
	assert(HABApabDpadeq : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) = 4) by (apply LABApabDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApabDpadmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HABApabDpadeq HABApabDpadm4).
	assert(HabDpeq : rk(ab :: Dp :: nil) = 2) by (apply LabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabDpmtmp : rk(ab :: Dp :: nil) >= 2) by (solve_hyps_min HabDpeq HabDpm2).
	assert(Hincl : incl (ab :: Dp :: nil) (list_inter (A :: B :: ab :: Dp :: nil) (Ap :: ab :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: nil) (A :: B :: ab :: Dp :: Ap :: ab :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Dp :: Ap :: ab :: Dp :: ad :: nil) ((A :: B :: ab :: Dp :: nil) ++ (Ap :: ab :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadmtmp;try rewrite HT2 in HABApabDpadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: Dp :: nil) (Ap :: ab :: Dp :: ad :: nil) (ab :: Dp :: nil) 4 2 3 HABApabDpadmtmp HabDpmtmp HABabDpMtmp Hincl); apply HT.
}

assert(HApabDpadM : rk(Ap :: ab :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpadm : rk(Ap :: ab :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HApabDpadeq HApabDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour abad requis par la preuve de (?)abad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(Habadm2 : rk(ab :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HApabDpadeq : rk(Ap :: ab :: Dp :: ad :: nil) = 3) by (apply LApabDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDpadmtmp : rk(Ap :: ab :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HApabDpadeq HApabDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (ab :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: Dp :: ad :: nil) (ab :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: Ap :: Dp :: ad :: nil) ((ab :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApabDpadmtmp;try rewrite HT2 in HApabDpadmtmp.
	assert(HT := rule_2 (ab :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HApabDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HabadM : rk(ab :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max Habadeq HabadM2).
assert(Habadm : rk(ab :: ad ::  nil) >= 1) by (solve_hyps_min Habadeq Habadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabad *)
(* dans constructLemma(), requis par LAApBpabad *)
(* dans la couche 0 *)
Lemma LOoAApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpabad requis par la preuve de (?)OoAApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpabadm2 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpabadm3 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApBpabadm4 : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABpadeq : rk(Oo :: A :: Bp :: ad :: nil) = 4) by (apply LOoABpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABpadmtmp : rk(Oo :: A :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HOoABpadeq HOoABpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Bp :: ad :: nil) (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) 4 4 HOoABpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApBpabadM : rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpabadm : rk(Oo :: A :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpabadeq HOoAApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Bp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApBpabad requis par la preuve de (?)AApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpabadm2 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApBpabadm3 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: Bp :: ad ::   de rang : 4 et 4 *)
assert(HAApBpabadm4 : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 4).
{
	assert(HOoAApBpadeq : rk(Oo :: A :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpadMtmp : rk(Oo :: A :: Ap :: Bp :: ad :: nil) <= 4) by (solve_hyps_max HOoAApBpadeq HOoAApBpadM4).
	assert(HOoAApBpabadeq : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoAApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabadmtmp : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpabadeq HOoAApBpabadm4).
	assert(HAApBpadeq : rk(A :: Ap :: Bp :: ad :: nil) = 4) by (apply LAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpadmtmp : rk(A :: Ap :: Bp :: ad :: nil) >= 4) by (solve_hyps_min HAApBpadeq HAApBpadm4).
	assert(Hincl : incl (A :: Ap :: Bp :: ad :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: A :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ad :: A :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: Bp :: ad :: nil) ++ (A :: Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpabadmtmp;try rewrite HT2 in HOoAApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ad :: nil) (A :: Ap :: Bp :: ab :: ad :: nil) (A :: Ap :: Bp :: ad :: nil) 4 4 4 HOoAApBpabadmtmp HAApBpadmtmp HOoAApBpadMtmp Hincl); apply HT.
}

assert(HAApBpabadM : rk(A :: Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApBpabadm : rk(A :: Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HAApBpabadeq HAApBpabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabad *)
(* dans la couche 0 *)
Lemma LApBpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpabad requis par la preuve de (?)ApBpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpabadm2 : rk(Ap :: Bp :: ab :: ad :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: ab :: ad :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApBpabadM3 : rk(Ap :: Bp :: ab :: ad :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Bp :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: ad :: nil) ((Ap :: Bp :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (ad :: nil) (nil) 2 1 0 HApBpabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Ap :: Bp :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ad ::   de rang : 4 et 4 *)
assert(HApBpabadm3 : rk(Ap :: Bp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAApBpadeq : rk(Oo :: A :: Ap :: Bp :: ad :: nil) = 4) by (apply LOoAApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpadMtmp : rk(Oo :: A :: Ap :: Bp :: ad :: nil) <= 4) by (solve_hyps_max HOoAApBpadeq HOoAApBpadM4).
	assert(HOoAApBpabadeq : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LOoAApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabadmtmp : rk(Oo :: A :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpabadeq HOoAApBpabadm4).
	assert(HApBpadeq : rk(Ap :: Bp :: ad :: nil) = 3) by (apply LApBpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpadmtmp : rk(Ap :: Bp :: ad :: nil) >= 3) by (solve_hyps_min HApBpadeq HApBpadm3).
	assert(Hincl : incl (Ap :: Bp :: ad :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ab :: ad :: nil) (Oo :: A :: Ap :: Bp :: ad :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ad :: Ap :: Bp :: ab :: ad :: nil) ((Oo :: A :: Ap :: Bp :: ad :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpabadmtmp;try rewrite HT2 in HOoAApBpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil) (Ap :: Bp :: ad :: nil) 4 3 4 HOoAApBpabadmtmp HApBpadmtmp HOoAApBpadMtmp Hincl); apply HT.
}

assert(HApBpabadM : rk(Ap :: Bp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpabadm : rk(Ap :: Bp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HApBpabadeq HApBpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Aabad requis par la preuve de (?)Aabad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabad requis par la preuve de (?)Aabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabad requis par la preuve de (?)OoABApabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabad requis par la preuve de (?)OoABApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadm2 : rk(A :: B :: ab :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApabadeq HOoABApabadm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadmtmp;try rewrite HT2 in HOoABApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: nil) (A :: B :: nil) 3 2 3 HOoABApabadmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABabadM3 : rk(A :: B :: ab :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (ad :: nil) (nil) 2 1 0 HABabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Aabad requis par la preuve de (?)Aabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ad ::  de rang :  2 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabadm2 : rk(A :: ab :: ad :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabadmtmp : rk(A :: B :: ab :: ad :: nil) >= 2) by (solve_hyps_min HABabadeq HABabadm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: A :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadmtmp;try rewrite HT2 in HABabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ad :: nil) (A :: ab :: nil) 2 2 2 HABabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAabadm3 : rk(A :: ab :: ad :: nil) >= 3).
{
	assert(HApBpabadeq : rk(Ap :: Bp :: ab :: ad :: nil) = 3) by (apply LApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpabadMtmp : rk(Ap :: Bp :: ab :: ad :: nil) <= 3) by (solve_hyps_max HApBpabadeq HApBpabadM3).
	assert(HAApBpabadeq : rk(A :: Ap :: Bp :: ab :: ad :: nil) = 4) by (apply LAApBpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApBpabadmtmp : rk(A :: Ap :: Bp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HAApBpabadeq HAApBpabadm4).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (A :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Bp :: ab :: ad :: nil) (A :: ab :: ad :: Ap :: Bp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ad :: Ap :: Bp :: ab :: ad :: nil) ((A :: ab :: ad :: nil) ++ (Ap :: Bp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApBpabadmtmp;try rewrite HT2 in HAApBpabadmtmp.
	assert(HT := rule_2 (A :: ab :: ad :: nil) (Ap :: Bp :: ab :: ad :: nil) (ab :: ad :: nil) 4 2 3 HAApBpabadmtmp Habadmtmp HApBpabadMtmp Hincl);apply HT.
}

assert(HAabadM : rk(A :: ab :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAabadeq HAabadM3).
assert(HAabadm : rk(A :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HAabadeq HAabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABabad *)
(* dans la couche 0 *)
Lemma LOoABCabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabad requis par la preuve de (?)OoABCabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabadm4 : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabadM : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabadm : rk(Oo :: A :: B :: C :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCabadeq HOoABCabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabad requis par la preuve de (?)OoABApabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabad requis par la preuve de (?)OoABApabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabad requis par la preuve de (?)ABabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadm2 : rk(A :: B :: ab :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: nil) >= 3) by (solve_hyps_min HOoABApabadeq HOoABApabadm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadmtmp;try rewrite HT2 in HOoABApabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: nil) (A :: B :: nil) 3 2 3 HOoABApabadmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HABabadM3 : rk(A :: B :: ab :: ad :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: B :: ab :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: nil) (A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (ad :: nil) (nil) 2 1 0 HABabMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: B :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HABabadm3 : rk(A :: B :: ab :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCabadeq : rk(Oo :: A :: B :: C :: ab :: ad :: nil) = 4) by (apply LOoABCabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabadmtmp : rk(Oo :: A :: B :: C :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCabadeq HOoABCabadm4).
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hincl : incl (A :: B :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: ad :: nil) (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: B :: ab :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: B :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabadmtmp;try rewrite HT2 in HOoABCabadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: B :: ab :: ad :: nil) (A :: B :: ad :: nil) 4 3 4 HOoABCabadmtmp HABadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HABabadM : rk(A :: B :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabadm : rk(A :: B :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HABabadeq HABabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpabad *)
(* dans constructLemma(), requis par LOoAApCpabad *)
(* dans la couche 0 *)
Lemma LOoABApCpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabad requis par la preuve de (?)OoABApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabadM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabadm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabad requis par la preuve de (?)OoAApCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabadeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) = 4) by (apply LOoABApCpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabadeq HOoABApCpabadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabadmtmp;try rewrite HT2 in HOoABApCpabadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoAApCpabadM : rk(Oo :: A :: Ap :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpabadm : rk(Oo :: A :: Ap :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoABCBpCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabad requis par la preuve de (?)OoACpabad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabadm2 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabadeq HOoABCBpCpabadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabadmtmp;try rewrite HT2 in HOoABCBpCpabadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabadm3 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabadm4 : rk(Oo :: A :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabadeq : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) = 4) by (apply LOoAApCpabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpabadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabadeq HOoAApCpabadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabadmtmp;try rewrite HT2 in HOoAApCpabadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

assert(HOoACpabadM : rk(Oo :: A :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpabadm : rk(Oo :: A :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpabadeq HOoACpabadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpabad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabad requis par la preuve de (?)OoABCBpCpabad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpabadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpabadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpabadeq HOoABCBpCpabadm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacad *)
(* dans constructLemma(), requis par LApacDpad *)
(* dans la couche 0 *)
Lemma LACApacDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpad requis par la preuve de (?)ACApacDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ACApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpad requis par la preuve de (?)OoABCApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadeq HOoABCApacDpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadmtmp;try rewrite HT2 in HOoABCApacDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpad requis par la preuve de (?)ACApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpad requis par la preuve de (?)ACApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpadm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpadm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpadmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HABCApacDpadeq HABCApacDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpadmtmp;try rewrite HT2 in HABCApacDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HABCApacDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpadm4 : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4).
{
	assert(HACApDpeq : rk(A :: C :: Ap :: Dp :: nil) = 4) by (apply LACApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApDpmtmp : rk(A :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HACApDpeq HACApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil) 4 4 HACApDpmtmp Hcomp Hincl);apply HT.
}

assert(HACApacDpadM : rk(A :: C :: Ap :: ac :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacDpadm : rk(A :: C :: Ap :: ac :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HACApacDpadeq HACApacDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApacDpad requis par la preuve de (?)ApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpad requis par la preuve de (?)ApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ACApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpad requis par la preuve de (?)OoABCApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadeq HOoABCApacDpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadmtmp;try rewrite HT2 in HOoABCApacDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpad requis par la preuve de (?)ACApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpad requis par la preuve de (?)ACApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpadm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpadm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpadmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HABCApacDpadeq HABCApacDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpadmtmp;try rewrite HT2 in HABCApacDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HABCApacDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApacDpad requis par la preuve de (?)ApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpad requis par la preuve de (?)ApacDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HApacDpadM3 : rk(Ap :: ac :: Dp :: ad :: nil) <= 3).
{
	assert(HacMtmp : rk(ac :: nil) <= 1) by (solve_hyps_max Haceq HacM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ac :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: Dp :: ad :: nil) (ac :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: Ap :: Dp :: ad :: nil) ((ac :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ac :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HacMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpadm2 : rk(Ap :: ac :: Dp :: ad :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpadmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HACApacDpadeq HACApacDpadm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: ad :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadmtmp;try rewrite HT2 in HACApacDpadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: nil) (ac :: nil) 3 1 2 HACApacDpadmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad ::  de rang :  4 et 4 	 AiB : ac :: Dp ::  de rang :  2 et 2 	 A : A :: C :: ac :: Dp ::   de rang : 3 et 3 *)
assert(HApacDpadm3 : rk(Ap :: ac :: Dp :: ad :: nil) >= 3).
{
	assert(HACacDpeq : rk(A :: C :: ac :: Dp :: nil) = 3) by (apply LACacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDpMtmp : rk(A :: C :: ac :: Dp :: nil) <= 3) by (solve_hyps_max HACacDpeq HACacDpM3).
	assert(HACApacDpadeq : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) = 4) by (apply LACApacDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApacDpadmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HACApacDpadeq HACApacDpadm4).
	assert(HacDpeq : rk(ac :: Dp :: nil) = 2) by (apply LacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HacDpmtmp : rk(ac :: Dp :: nil) >= 2) by (solve_hyps_min HacDpeq HacDpm2).
	assert(Hincl : incl (ac :: Dp :: nil) (list_inter (A :: C :: ac :: Dp :: nil) (Ap :: ac :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: nil) (A :: C :: ac :: Dp :: Ap :: ac :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Dp :: Ap :: ac :: Dp :: ad :: nil) ((A :: C :: ac :: Dp :: nil) ++ (Ap :: ac :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadmtmp;try rewrite HT2 in HACApacDpadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: Dp :: nil) (Ap :: ac :: Dp :: ad :: nil) (ac :: Dp :: nil) 4 2 3 HACApacDpadmtmp HacDpmtmp HACacDpMtmp Hincl); apply HT.
}

assert(HApacDpadM : rk(Ap :: ac :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpadm : rk(Ap :: ac :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HApacDpadeq HApacDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour acad requis par la preuve de (?)acad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(Hacadm2 : rk(ac :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HApacDpadeq : rk(Ap :: ac :: Dp :: ad :: nil) = 3) by (apply LApacDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDpadmtmp : rk(Ap :: ac :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HApacDpadeq HApacDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (ac :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: Dp :: ad :: nil) (ac :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ac :: ad :: Ap :: Dp :: ad :: nil) ((ac :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApacDpadmtmp;try rewrite HT2 in HApacDpadmtmp.
	assert(HT := rule_2 (ac :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HApacDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HacadM : rk(ac :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max Hacadeq HacadM2).
assert(Hacadm : rk(ac :: ad ::  nil) >= 1) by (solve_hyps_min Hacadeq Hacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAacad *)
(* dans constructLemma(), requis par LAApCpacad *)
(* dans la couche 0 *)
Lemma LOoAApCpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpacad requis par la preuve de (?)OoAApCpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpacad requis par la preuve de (?)OoAApCpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpacad requis par la preuve de (?)OoAApCpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpacadm2 : rk(Oo :: A :: Ap :: Cp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpacadm3 : rk(Oo :: A :: Ap :: Cp :: ac :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ac :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoAApCpacadm4 : rk(Oo :: A :: Ap :: Cp :: ac :: ad :: nil) >= 4).
{
	assert(HOoACpadeq : rk(Oo :: A :: Cp :: ad :: nil) = 4) by (apply LOoACpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACpadmtmp : rk(Oo :: A :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HOoACpadeq HOoACpadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: Cp :: ad :: nil) (Oo :: A :: Ap :: Cp :: ac :: ad :: nil) 4 4 HOoACpadmtmp Hcomp Hincl);apply HT.
}

assert(HOoAApCpacadM : rk(Oo :: A :: Ap :: Cp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpacadm : rk(Oo :: A :: Ap :: Cp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpacadeq HOoAApCpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApCpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: Cp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApCpacad requis par la preuve de (?)AApCpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApCpacad requis par la preuve de (?)AApCpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApCpacad requis par la preuve de (?)AApCpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpacadm2 : rk(A :: Ap :: Cp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: Cp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApCpacadm3 : rk(A :: Ap :: Cp :: ac :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (A :: Ap :: Cp :: ac :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Cp :: ad ::  de rang :  4 et 4 	 A : Oo :: A :: Ap :: Cp :: ad ::   de rang : 4 et 4 *)
assert(HAApCpacadm4 : rk(A :: Ap :: Cp :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApCpadeq : rk(Oo :: A :: Ap :: Cp :: ad :: nil) = 4) by (apply LOoAApCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpadMtmp : rk(Oo :: A :: Ap :: Cp :: ad :: nil) <= 4) by (solve_hyps_max HOoAApCpadeq HOoAApCpadM4).
	assert(HOoAApCpacadeq : rk(Oo :: A :: Ap :: Cp :: ac :: ad :: nil) = 4) by (apply LOoAApCpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpacadmtmp : rk(Oo :: A :: Ap :: Cp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpacadeq HOoAApCpacadm4).
	assert(HAApCpadeq : rk(A :: Ap :: Cp :: ad :: nil) = 4) by (apply LAApCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpadmtmp : rk(A :: Ap :: Cp :: ad :: nil) >= 4) by (solve_hyps_min HAApCpadeq HAApCpadm4).
	assert(Hincl : incl (A :: Ap :: Cp :: ad :: nil) (list_inter (Oo :: A :: Ap :: Cp :: ad :: nil) (A :: Ap :: Cp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ac :: ad :: nil) (Oo :: A :: Ap :: Cp :: ad :: A :: Ap :: Cp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Cp :: ad :: A :: Ap :: Cp :: ac :: ad :: nil) ((Oo :: A :: Ap :: Cp :: ad :: nil) ++ (A :: Ap :: Cp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpacadmtmp;try rewrite HT2 in HOoAApCpacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Cp :: ad :: nil) (A :: Ap :: Cp :: ac :: ad :: nil) (A :: Ap :: Cp :: ad :: nil) 4 4 4 HOoAApCpacadmtmp HAApCpadmtmp HOoAApCpadMtmp Hincl); apply HT.
}

assert(HAApCpacadM : rk(A :: Ap :: Cp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApCpacadm : rk(A :: Ap :: Cp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HAApCpacadeq HAApCpacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAacad *)
(* dans la couche 0 *)
Lemma LApCpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacad requis par la preuve de (?)ApCpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacad requis par la preuve de (?)ApCpacad pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacad requis par la preuve de (?)ApCpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpacadm2 : rk(Ap :: Cp :: ac :: ad :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ac :: ad :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApCpacadM3 : rk(Ap :: Cp :: ac :: ad :: nil) <= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Cp :: ac :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: ad :: nil) (Ap :: Cp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: ad :: nil) ((Ap :: Cp :: ac :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (ad :: nil) (nil) 2 1 0 HApCpacMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Ap :: Cp :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Cp :: ad ::   de rang : 4 et 4 *)
assert(HApCpacadm3 : rk(Ap :: Cp :: ac :: ad :: nil) >= 3).
{
	assert(HOoAApCpadeq : rk(Oo :: A :: Ap :: Cp :: ad :: nil) = 4) by (apply LOoAApCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpadMtmp : rk(Oo :: A :: Ap :: Cp :: ad :: nil) <= 4) by (solve_hyps_max HOoAApCpadeq HOoAApCpadM4).
	assert(HOoAApCpacadeq : rk(Oo :: A :: Ap :: Cp :: ac :: ad :: nil) = 4) by (apply LOoAApCpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpacadmtmp : rk(Oo :: A :: Ap :: Cp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpacadeq HOoAApCpacadm4).
	assert(HApCpadeq : rk(Ap :: Cp :: ad :: nil) = 3) by (apply LApCpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpadmtmp : rk(Ap :: Cp :: ad :: nil) >= 3) by (solve_hyps_min HApCpadeq HApCpadm3).
	assert(Hincl : incl (Ap :: Cp :: ad :: nil) (list_inter (Oo :: A :: Ap :: Cp :: ad :: nil) (Ap :: Cp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ac :: ad :: nil) (Oo :: A :: Ap :: Cp :: ad :: Ap :: Cp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Cp :: ad :: Ap :: Cp :: ac :: ad :: nil) ((Oo :: A :: Ap :: Cp :: ad :: nil) ++ (Ap :: Cp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpacadmtmp;try rewrite HT2 in HOoAApCpacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Cp :: ad :: nil) (Ap :: Cp :: ac :: ad :: nil) (Ap :: Cp :: ad :: nil) 4 3 4 HOoAApCpacadmtmp HApCpadmtmp HOoAApCpadMtmp Hincl); apply HT.
}

assert(HApCpacadM : rk(Ap :: Cp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacadm : rk(Ap :: Cp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HApCpacadeq HApCpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Aacad requis par la preuve de (?)Aacad pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacad requis par la preuve de (?)Aacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)ABCApacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)OoABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ABCApacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacadm2 : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacadm4 : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadmtmp;try rewrite HT2 in HOoABCApacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacadm2 : rk(A :: C :: ac :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacadmtmp : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 4) by (solve_hyps_min HABCApacadeq HABCApacadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: ad :: nil) (B :: Ap :: A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: ad :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacadmtmp;try rewrite HT2 in HABCApacadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: ad :: nil) (nil) 4 0 2 HABCApacadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HACacadM3 : rk(A :: C :: ac :: ad :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: ad :: nil) (A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (ad :: nil) (nil) 2 1 0 HACacMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Aacad requis par la preuve de (?)Aacad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: ad ::  de rang :  2 et 3 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacadm2 : rk(A :: ac :: ad :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacadmtmp : rk(A :: C :: ac :: ad :: nil) >= 2) by (solve_hyps_min HACacadeq HACacadm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: ad :: nil) (A :: C :: ac :: A :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacadmtmp;try rewrite HT2 in HACacadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: ad :: nil) (A :: ac :: nil) 2 2 2 HACacadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HAacadm3 : rk(A :: ac :: ad :: nil) >= 3).
{
	assert(HApCpacadeq : rk(Ap :: Cp :: ac :: ad :: nil) = 3) by (apply LApCpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpacadMtmp : rk(Ap :: Cp :: ac :: ad :: nil) <= 3) by (solve_hyps_max HApCpacadeq HApCpacadM3).
	assert(HAApCpacadeq : rk(A :: Ap :: Cp :: ac :: ad :: nil) = 4) by (apply LAApCpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApCpacadmtmp : rk(A :: Ap :: Cp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HAApCpacadeq HAApCpacadm4).
	assert(Hacadeq : rk(ac :: ad :: nil) = 2) by (apply Lacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Hacadmtmp : rk(ac :: ad :: nil) >= 2) by (solve_hyps_min Hacadeq Hacadm2).
	assert(Hincl : incl (ac :: ad :: nil) (list_inter (A :: ac :: ad :: nil) (Ap :: Cp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: Cp :: ac :: ad :: nil) (A :: ac :: ad :: Ap :: Cp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: ad :: Ap :: Cp :: ac :: ad :: nil) ((A :: ac :: ad :: nil) ++ (Ap :: Cp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApCpacadmtmp;try rewrite HT2 in HAApCpacadmtmp.
	assert(HT := rule_2 (A :: ac :: ad :: nil) (Ap :: Cp :: ac :: ad :: nil) (ac :: ad :: nil) 4 2 3 HAApCpacadmtmp Hacadmtmp HApCpacadMtmp Hincl);apply HT.
}

assert(HAacadM : rk(A :: ac :: ad ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAacadeq HAacadM3).
assert(HAacadm : rk(A :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HAacadeq HAacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABacad requis par la preuve de (?)OoABacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpacad requis par la preuve de (?)OoABacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpacad requis par la preuve de (?)OoABCCpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacadm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABacad requis par la preuve de (?)OoABacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacad requis par la preuve de (?)OoABacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacad requis par la preuve de (?)OoABApacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacad requis par la preuve de (?)OoABApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacadm2 : rk(Oo :: A :: B :: Ap :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacadm3 : rk(Oo :: A :: B :: Ap :: ac :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABacad requis par la preuve de (?)OoABacad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: ad ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABacadm2 : rk(Oo :: A :: B :: ac :: ad :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacadmtmp : rk(Oo :: A :: B :: Ap :: ac :: ad :: nil) >= 3) by (solve_hyps_min HOoABApacadeq HOoABApacadm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: ad :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: ad :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacadmtmp;try rewrite HT2 in HOoABApacadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: ad :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApacadmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABacadm3 : rk(Oo :: A :: B :: ac :: ad :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpacadmtmp : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCCpacadeq HOoABCCpacadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ac :: ad :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ac :: ad :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpacadmtmp;try rewrite HT2 in HOoABCCpacadmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: ad :: nil) (Oo :: nil) 4 1 2 HOoABCCpacadmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABacadm4 : rk(Oo :: A :: B :: ac :: ad :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ac :: ad :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

assert(HOoABacadM : rk(Oo :: A :: B :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABacadm : rk(Oo :: A :: B :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABacadeq HOoABacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACacad *)
(* dans la couche 0 *)
Lemma LOoABCacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCacad requis par la preuve de (?)OoABCacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCacadm4 : rk(Oo :: A :: B :: C :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCacadM : rk(Oo :: A :: B :: C :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCacadm : rk(Oo :: A :: B :: C :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCacadeq HOoABCacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)ABCApacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)OoABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ABCApacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacadm2 : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacadm4 : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadmtmp;try rewrite HT2 in HOoABCApacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacad requis par la preuve de (?)ACacad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: ad ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacadm2 : rk(A :: C :: ac :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacadmtmp : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 4) by (solve_hyps_min HABCApacadeq HABCApacadm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: ad :: nil) (B :: Ap :: A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: ad :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacadmtmp;try rewrite HT2 in HABCApacadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: ad :: nil) (nil) 4 0 2 HABCApacadmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HACacadM3 : rk(A :: C :: ac :: ad :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HadMtmp : rk(ad :: nil) <= 1) by (solve_hyps_max Hadeq HadM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: C :: ac :: nil) (ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: ad :: nil) (A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (ad :: nil) (nil) 2 1 0 HACacMtmp HadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: C :: ad ::  de rang :  3 et 3 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HACacadm3 : rk(A :: C :: ac :: ad :: nil) >= 3).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCacadeq : rk(Oo :: A :: B :: C :: ac :: ad :: nil) = 4) by (apply LOoABCacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCacadmtmp : rk(Oo :: A :: B :: C :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCacadeq HOoABCacadm4).
	assert(HACadeq : rk(A :: C :: ad :: nil) = 3) by (apply LACad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACadmtmp : rk(A :: C :: ad :: nil) >= 3) by (solve_hyps_min HACadeq HACadm3).
	assert(Hincl : incl (A :: C :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: C :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ac :: ad :: nil) (Oo :: A :: B :: C :: ad :: A :: C :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: C :: ac :: ad :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: C :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCacadmtmp;try rewrite HT2 in HOoABCacadmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: C :: ac :: ad :: nil) (A :: C :: ad :: nil) 4 3 4 HOoABCacadmtmp HACadmtmp HOoABCadMtmp Hincl); apply HT.
}

assert(HACacadM : rk(A :: C :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacadm : rk(A :: C :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HACacadeq HACacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacad *)
(* dans la couche 0 *)
Lemma LOoABCApacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacad requis par la preuve de (?)OoABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacadM : rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacadm : rk(Oo :: A :: B :: C :: Ap :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ABCApacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacad requis par la preuve de (?)ABCApacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacadm2 : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacadm4 : rk(A :: B :: C :: Ap :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacadeq : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) = 4) by (apply LOoABCApacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacadeq HOoABCApacadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadmtmp;try rewrite HT2 in HOoABCApacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacadM : rk(A :: B :: C :: Ap :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacadm : rk(A :: B :: C :: Ap :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HABCApacadeq HABCApacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpacad *)
(* dans constructLemma(), requis par LOoAApBpacad *)
(* dans constructLemma(), requis par LOoACApBpacad *)
(* dans la couche 0 *)
Lemma LOoABCApBpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacad requis par la preuve de (?)OoABCApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpacadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpacadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacad requis par la preuve de (?)OoACApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoABCApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoABCApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacadeq HOoABCApBpacadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacadmtmp;try rewrite HT2 in HOoABCApBpacadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpacadM : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpacadm : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoACApBpacadeq HOoACApBpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacad requis par la preuve de (?)OoAApBpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacadeq : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoACApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpacadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacadeq HOoACApBpacadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacadmtmp;try rewrite HT2 in HOoACApBpacadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

assert(HOoAApBpacadM : rk(Oo :: A :: Ap :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpacadm : rk(Oo :: A :: Ap :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpacadeq HOoAApBpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacad requis par la preuve de (?)OoABpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm2 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacadm3 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacadm4 : rk(Oo :: A :: Bp :: ac :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacadeq : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) = 4) by (apply LOoAApBpacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpacadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacadeq HOoAApBpacadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacadmtmp;try rewrite HT2 in HOoAApBpacadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

assert(HOoABpacadM : rk(Oo :: A :: Bp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpacadm : rk(Oo :: A :: Bp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpacadeq HOoABpacadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpacad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ac :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpacad requis par la preuve de (?)OoABCCpacad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacadm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpacadM : rk(Oo :: A :: B :: C :: Cp :: ac :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpacadm : rk(Oo :: A :: B :: C :: Cp :: ac :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpacadeq HOoABCCpacadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDad *)
(* dans constructLemma(), requis par LApDDpad *)
(* dans la couche 0 *)
Lemma LOoApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: Ap :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDDpad requis par la preuve de (?)OoABCApbcDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDDpadm3 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadeq HOoABCApbcDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadmtmp;try rewrite HT2 in HOoABCApbcDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDDpadm4 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadeq HOoABCApbcDDpadm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadmtmp;try rewrite HT2 in HOoABCApbcDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDDpadmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpad requis par la preuve de (?)OoABCApDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpadm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadeq HOoABCApDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadmtmp;try rewrite HT2 in HOoABCApDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDDpadm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDDpadmtmp : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApbcDDpadeq HOoBCApbcDDpadm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDDpadmtmp;try rewrite HT2 in HOoBCApbcDDpadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDDpadmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpCpDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpCpDDpad requis par la preuve de (?)OoACApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpDDpad requis par la preuve de (?)OoABCApBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpDDpad requis par la preuve de (?)OoACApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpDDpad requis par la preuve de (?)OoACApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpDDpad requis par la preuve de (?)OoACApBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpDDpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpDDpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpDDpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpDDpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpDDpad requis par la preuve de (?)OoBCApBpCpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpDDpadm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpDDpadm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpDDpadmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpDDpadeq HOoBCApBpCpDDpadm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpDDpadmtmp;try rewrite HT2 in HOoBCApBpCpDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpDDpadm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpDDpadmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpDDpadm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpDDpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpCpDDpadeq HOoACApBpCpDDpadm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpDDpadmtmp;try rewrite HT2 in HOoACApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpDDpadmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoApDDpad requis par la preuve de (?)OoApDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Bp :: Cp ::   de rang : 3 et 3 *)
assert(HOoApDDpadm2 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoCBpCpeq : rk(Oo :: C :: Bp :: Cp :: nil) = 3) by (apply LOoCBpCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpCpMtmp : rk(Oo :: C :: Bp :: Cp :: nil) <= 3) by (solve_hyps_max HOoCBpCpeq HOoCBpCpM3).
	assert(HOoCApBpCpDDpadmtmp : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoCApBpCpDDpadeq HOoCApBpCpDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Bp :: Cp :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Oo :: C :: Bp :: Cp :: Oo :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Bp :: Cp :: Oo :: Ap :: D :: Dp :: ad :: nil) ((Oo :: C :: Bp :: Cp :: nil) ++ (Oo :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpCpDDpadmtmp;try rewrite HT2 in HOoCApBpCpDDpadmtmp.
	assert(HT := rule_4 (Oo :: C :: Bp :: Cp :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoCApBpCpDDpadmtmp HOomtmp HOoCBpCpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HOoApDDpadm3 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpadmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApDDpadeq HOoBCApDDpadm4).
	assert(HOoDeq : rk(Oo :: D :: nil) = 2) by (apply LOoD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoDmtmp : rk(Oo :: D :: nil) >= 2) by (solve_hyps_min HOoDeq HOoDm2).
	assert(Hincl : incl (Oo :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (Oo :: B :: C :: D :: Oo :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: Ap :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpadmtmp;try rewrite HT2 in HOoBCApDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: D :: nil) 4 2 3 HOoBCApDDpadmtmp HOoDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HOoApDDpadM3 : rk(Oo :: Ap :: D :: Dp :: ad :: nil) <= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: Dp :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: D :: Dp :: nil) (Ap :: Dp :: ad :: nil) (Dp :: nil) 2 2 1 HOoDDpMtmp HApDpadMtmp HDpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoApDDpadM : rk(Oo :: Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoApDDpadm : rk(Oo :: Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoApDDpadeq HOoApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: D :: Dp :: ad ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)ApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDDpad requis par la preuve de (?)OoABCApbcDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDDpadm3 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadeq HOoABCApbcDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadmtmp;try rewrite HT2 in HOoABCApbcDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDDpadm4 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadeq HOoABCApbcDDpadm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadmtmp;try rewrite HT2 in HOoABCApbcDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDDpadmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpad requis par la preuve de (?)OoABCApDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpadm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadeq HOoABCApDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadmtmp;try rewrite HT2 in HOoABCApDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDDpadm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDDpadmtmp : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApbcDDpadeq HOoBCApbcDDpadm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDDpadmtmp;try rewrite HT2 in HOoBCApbcDDpadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDDpadmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDDpad requis par la preuve de (?)ApDDpad pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HApDDpadM3 : rk(Ap :: D :: Dp :: ad :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Ap :: Dp :: ad :: nil) ((D :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Ap :: Dp :: ad :: nil) (nil) 1 2 0 HDMtmp HApDpadMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : D ::  de rang :  1 et 1 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HApDDpadm2 : rk(Ap :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpadmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApDDpadeq HOoBCApDDpadm4).
	assert(HDmtmp : rk(D :: nil) >= 1) by (solve_hyps_min HDeq HDm1).
	assert(Hincl : incl (D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (Oo :: B :: C :: D :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Ap :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: D :: nil) ++ (Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpadmtmp;try rewrite HT2 in HOoBCApDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Ap :: D :: Dp :: ad :: nil) (D :: nil) 4 1 3 HOoBCApDDpadmtmp HDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: Ap :: D :: Dp :: ad ::  de rang :  3 et 3 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HApDDpadm3 : rk(Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoApDDpadeq : rk(Oo :: Ap :: D :: Dp :: ad :: nil) = 3) by (apply LOoApDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApDDpadmtmp : rk(Oo :: Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoApDDpadeq HOoApDDpadm3).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: Ap :: D :: Dp :: ad :: nil) (Oo :: D :: Dp :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: Ap :: D :: Dp :: ad :: nil) ((Oo :: D :: Dp :: nil) ++ (Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoApDDpadmtmp;try rewrite HT2 in HOoApDDpadmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (Ap :: D :: Dp :: ad :: nil) (D :: Dp :: nil) 3 2 2 HOoApDDpadmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HApDDpadM : rk(Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDDpadm : rk(Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HApDDpadeq HApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: ad ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dad requis par la preuve de (?)Dad pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDadm2 : rk(D :: ad :: nil) >= 2).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HApDDpadeq : rk(Ap :: D :: Dp :: ad :: nil) = 3) by (apply LApDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDDpadmtmp : rk(Ap :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HApDDpadeq HApDDpadm3).
	assert(Hadmtmp : rk(ad :: nil) >= 1) by (solve_hyps_min Hadeq Hadm1).
	assert(Hincl : incl (ad :: nil) (list_inter (D :: ad :: nil) (Ap :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: D :: Dp :: ad :: nil) (D :: ad :: Ap :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: ad :: Ap :: Dp :: ad :: nil) ((D :: ad :: nil) ++ (Ap :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HApDDpadmtmp;try rewrite HT2 in HApDDpadmtmp.
	assert(HT := rule_2 (D :: ad :: nil) (Ap :: Dp :: ad :: nil) (ad :: nil) 3 1 2 HApDDpadmtmp Hadmtmp HApDpadMtmp Hincl);apply HT.
}

assert(HDadM : rk(D :: ad ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDadeq HDadM2).
assert(HDadm : rk(D :: ad ::  nil) >= 1) by (solve_hyps_min HDadeq HDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDad requis par la preuve de (?)OoABCApDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDadM : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDadm : rk(Oo :: A :: B :: C :: Ap :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApDadeq HOoABCApDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDad requis par la preuve de (?)OoABCBpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDadM : rk(Oo :: A :: B :: C :: Bp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDadm : rk(Oo :: A :: B :: C :: Bp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpDadeq HOoABCBpDadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDad requis par la preuve de (?)OoABCCpDad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpDadM : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDadm : rk(Oo :: A :: B :: C :: Cp :: D :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCCpDadeq HOoABCCpDadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDpad *)
(* dans la couche 0 *)
Lemma LOoABCApacDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpad requis par la preuve de (?)OoABCApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpadM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpadm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpadeq HOoABCApacDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpad requis par la preuve de (?)ABCApacDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadeq : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) = 4) by (apply LOoABCApacDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadeq HOoABCApacDpadm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadmtmp;try rewrite HT2 in HOoABCApacDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDpadM : rk(A :: B :: C :: Ap :: ac :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDpadm : rk(A :: B :: C :: Ap :: ac :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HABCApacDpadeq HABCApacDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApDDpad *)
(* dans constructLemma(), requis par LOoBCApbcDDpad *)
(* dans la couche 0 *)
Lemma LOoABCApbcDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDDpad requis par la preuve de (?)OoABCApbcDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDDpadM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDDpadm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDDpadeq HOoABCApbcDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDDpad requis par la preuve de (?)OoBCApbcDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDDpadm3 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDDpadeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApbcDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadeq HOoABCApbcDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadmtmp;try rewrite HT2 in HOoABCApbcDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDDpadm4 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDDpadeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApbcDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadeq HOoABCApbcDDpadm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadmtmp;try rewrite HT2 in HOoABCApbcDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDDpadmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDDpadM : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDDpadm : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDDpadeq HOoBCApbcDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpad requis par la preuve de (?)OoABCApDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpad requis par la preuve de (?)OoBCApDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpadm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadeq HOoABCApDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadmtmp;try rewrite HT2 in HOoABCApDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDDpadm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDDpadeq : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) = 4) by (apply LOoBCApbcDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDDpadmtmp : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoBCApbcDDpadeq HOoBCApbcDDpadm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDDpadmtmp;try rewrite HT2 in HOoBCApbcDDpadmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDDpadmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDDpadM : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDDpadm : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoBCApDDpadeq HOoBCApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpad requis par la preuve de (?)OoABCApDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpadM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpadm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpadeq HOoABCApDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpDDpad requis par la preuve de (?)OoABCBpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpDDpadM : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpDDpadm : rk(Oo :: A :: B :: C :: Bp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpDDpadeq HOoABCBpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpDDpad requis par la preuve de (?)OoABCBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpDDpadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpDDpadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpDDpadeq HOoABCBpCpDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpCpDDpad *)
(* dans constructLemma(), requis par LOoACApBpCpDDpad *)
(* dans la couche 0 *)
Lemma LOoABCApBpCpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpCpDDpad requis par la preuve de (?)OoABCApBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpCpDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpCpDDpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpCpDDpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpCpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpCpDDpad requis par la preuve de (?)OoACApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpCpDDpad requis par la preuve de (?)OoACApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpCpDDpad requis par la preuve de (?)OoACApBpCpDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpCpDDpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpCpDDpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpCpDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpCpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpCpDDpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpCpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpCpDDpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpCpDDpadM : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpCpDDpadm : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACApBpCpDDpadeq HOoACApBpCpDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpCpDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpCpDDpad requis par la preuve de (?)OoBCApBpCpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpCpDDpadm3 : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpCpDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpCpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpCpDDpadmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpCpDDpad requis par la preuve de (?)OoCApBpCpDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpCpDDpadm2 : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpCpDDpadmtmp : rk(Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3) by (solve_hyps_min HOoBCApBpCpDDpadeq HOoBCApBpCpDDpadm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpCpDDpadmtmp;try rewrite HT2 in HOoBCApBpCpDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: nil) 3 1 2 HOoBCApBpCpDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpDDpadm3 : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpCpDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpCpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpCpDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpCpDDpadeq HOoABCApBpCpDDpadm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpCpDDpadmtmp;try rewrite HT2 in HOoABCApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpCpDDpadmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : C :: Ap :: Cp ::  de rang :  3 et 3 	 A : A :: C :: Ap :: Cp ::   de rang : 3 et 3 *)
assert(HOoCApBpCpDDpadm4 : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACApCpeq : rk(A :: C :: Ap :: Cp :: nil) = 3) by (apply LACApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApCpMtmp : rk(A :: C :: Ap :: Cp :: nil) <= 3) by (solve_hyps_max HACApCpeq HACApCpM3).
	assert(HOoACApBpCpDDpadeq : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) = 4) by (apply LOoACApBpCpDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpCpDDpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpCpDDpadeq HOoACApBpCpDDpadm4).
	assert(HCApCpmtmp : rk(C :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HCApCpeq HCApCpm3).
	assert(Hincl : incl (C :: Ap :: Cp :: nil) (list_inter (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: Ap :: Cp :: Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) ((A :: C :: Ap :: Cp :: nil) ++ (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpCpDDpadmtmp;try rewrite HT2 in HOoACApBpCpDDpadmtmp.
	assert(HT := rule_4 (A :: C :: Ap :: Cp :: nil) (Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad :: nil) (C :: Ap :: Cp :: nil) 4 3 3 HOoACApBpCpDDpadmtmp HCApCpmtmp HACApCpMtmp Hincl); apply HT.
}

assert(HOoCApBpCpDDpadM : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpCpDDpadm : rk(Oo :: C :: Ap :: Bp :: Cp :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoCApBpCpDDpadeq HOoCApBpCpDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoACpabDDpad *)
(* dans constructLemma(), requis par LOoAApCpabDDpad *)
(* dans la couche 0 *)
Lemma LOoABApCpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpabDDpad requis par la preuve de (?)OoABApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm2 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpabDDpadm3 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpabDDpadm4 : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpabDDpadM : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpabDDpadm : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABApCpabDDpadeq HOoABApCpabDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApCpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApCpabDDpad requis par la preuve de (?)OoAApCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm2 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApCpabDDpadm3 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApCpmtmp : rk(A :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HAApCpeq HAApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Cp :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HAApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoAApCpabDDpadm4 : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABApCpabDDpadeq : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) = 4) by (apply LOoABApCpabDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpabDDpadmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABApCpabDDpadeq HOoABApCpabDDpadm4).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) ((A :: B :: ab :: nil) ++ (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpabDDpadmtmp;try rewrite HT2 in HOoABApCpabDDpadmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (A :: ab :: nil) 4 2 2 HOoABApCpabDDpadmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoAApCpabDDpadM : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApCpabDDpadm : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApCpabDDpadeq HOoAApCpabDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoABCBpCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACpabDDpad requis par la preuve de (?)OoACpabDDpad pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Bp ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm2 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HOoBCBpeq : rk(Oo :: B :: C :: Bp :: nil) = 3) by (apply LOoBCBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCBpMtmp : rk(Oo :: B :: C :: Bp :: nil) <= 3) by (solve_hyps_max HOoBCBpeq HOoBCBpM3).
	assert(HOoABCBpCpabDDpadmtmp : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCBpCpabDDpadeq HOoABCBpCpabDDpadm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Bp :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: B :: C :: Bp :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCBpCpabDDpadmtmp;try rewrite HT2 in HOoABCBpCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Bp :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: nil) 4 1 3 HOoABCBpCpabDDpadmtmp HOomtmp HOoBCBpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoACpabDDpadm3 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) 3 3 HOoAabmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ab ::   de rang : 3 et 3 *)
assert(HOoACpabDDpadm4 : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApabeq : rk(Oo :: A :: Ap :: ab :: nil) = 3) by (apply LOoAApab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApabMtmp : rk(Oo :: A :: Ap :: ab :: nil) <= 3) by (solve_hyps_max HOoAApabeq HOoAApabM3).
	assert(HOoAApCpabDDpadeq : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) = 4) by (apply LOoAApCpabDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApCpabDDpadmtmp : rk(Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApCpabDDpadeq HOoAApCpabDDpadm4).
	assert(HOoAabeq : rk(Oo :: A :: ab :: nil) = 3) by (apply LOoAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAabmtmp : rk(Oo :: A :: ab :: nil) >= 3) by (solve_hyps_min HOoAabeq HOoAabm3).
	assert(Hincl : incl (Oo :: A :: ab :: nil) (list_inter (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ab :: Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ab :: nil) ++ (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApCpabDDpadmtmp;try rewrite HT2 in HOoAApCpabDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ab :: nil) (Oo :: A :: Cp :: ab :: D :: Dp :: ad :: nil) (Oo :: A :: ab :: nil) 4 3 3 HOoAApCpabDDpadmtmp HOoAabmtmp HOoAApabMtmp Hincl); apply HT.
}

assert(HOoACpabDDpadM : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACpabDDpadm : rk(Oo :: A :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACpabDDpadeq HOoACpabDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCBpCpabDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCBpCpabDDpad requis par la preuve de (?)OoABCBpCpabDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCBpCpabDDpadm4 : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCBpCpabDDpadM : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCBpCpabDDpadm : rk(Oo :: A :: B :: C :: Bp :: Cp :: ab :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCBpCpabDDpadeq HOoABCBpCpabDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoABpacDDpad *)
(* dans constructLemma(), requis par LOoAApBpacDDpad *)
(* dans constructLemma(), requis par LOoACApBpacDDpad *)
(* dans la couche 0 *)
Lemma LOoABCApBpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpacDDpad requis par la preuve de (?)OoABCApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpacDDpadm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpacDDpadM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpacDDpadm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpacDDpad requis par la preuve de (?)OoACApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpacDDpadm2 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpacDDpadm3 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpacDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Ap :: nil) 4 1 2 HOoABCApBpacDDpadmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpacDDpadm4 : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpacDDpadeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoABCApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpacDDpadmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoABCApBpacDDpadeq HOoABCApBpacDDpadm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpacDDpadmtmp;try rewrite HT2 in HOoABCApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpacDDpadmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpacDDpadM : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpacDDpadm : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoACApBpacDDpadeq HOoACApBpacDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoAApBpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoAApBpacDDpad requis par la preuve de (?)OoAApBpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm2 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoAApBpacDDpadm3 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: Bp :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HAApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HOoAApBpacDDpadm4 : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HOoACApBpacDDpadeq : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoACApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpacDDpadmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoACApBpacDDpadeq HOoACApBpacDDpadm4).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) ((A :: C :: ac :: nil) ++ (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpacDDpadmtmp;try rewrite HT2 in HOoACApBpacDDpadmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (A :: ac :: nil) 4 2 2 HOoACApBpacDDpadmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

assert(HOoAApBpacDDpadM : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoAApBpacDDpadm : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoAApBpacDDpadeq HOoAApBpacDDpadm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABpacDDpad : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABpacDDpad requis par la preuve de (?)OoABpacDDpad pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm2 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 2).
{
	assert(HABpeq : rk(A :: Bp :: nil) = 2) by (apply LABp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABpmtmp : rk(A :: Bp :: nil) >= 2) by (solve_hyps_min HABpeq HABpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Bp :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 2 2 HABpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABpacDDpadm3 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 3).
{
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) 3 3 HOoAacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad ::  de rang :  4 et 4 	 AiB : Oo :: A :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoABpacDDpadm4 : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoAApBpacDDpadeq : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) = 4) by (apply LOoAApBpacDDpad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpacDDpadmtmp : rk(Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) >= 4) by (solve_hyps_min HOoAApBpacDDpadeq HOoAApBpacDDpadm4).
	assert(HOoAaceq : rk(Oo :: A :: ac :: nil) = 3) by (apply LOoAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAacmtmp : rk(Oo :: A :: ac :: nil) >= 3) by (solve_hyps_min HOoAaceq HOoAacm3).
	assert(Hincl : incl (Oo :: A :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: Ap :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoAApBpacDDpadmtmp;try rewrite HT2 in HOoAApBpacDDpadmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: A :: Bp :: ac :: D :: Dp :: ad :: nil) (Oo :: A :: ac :: nil) 4 3 3 HOoAApBpacDDpadmtmp HOoAacmtmp HOoAApacMtmp Hincl); apply HT.
}

assert(HOoABpacDDpadM : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABpacDDpadm : rk(Oo :: A :: Bp :: ac :: D :: Dp :: ad ::  nil) >= 1) by (solve_hyps_min HOoABpacDDpadeq HOoABpacDDpadm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbd *)
(* dans la couche 0 *)
Lemma LBBpDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Bp :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BBpDpbd requis par la preuve de (?)BBpDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BBpDpbd requis par la preuve de (?)BBpDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BBpDpbd requis par la preuve de (?)BBpDpbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBBpDpbdM3 : rk(B :: Bp :: Dp :: bd :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Dp :: bd :: nil) (B :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Bp :: Dp :: bd :: nil) ((B :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (Bp :: Dp :: bd :: nil) (nil) 1 2 0 HBMtmp HBpDpbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDpbdm2 : rk(B :: Bp :: Dp :: bd :: nil) >= 2).
{
	assert(HBBpmtmp : rk(B :: Bp :: nil) >= 2) by (solve_hyps_min HBBpeq HBBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: nil) (B :: Bp :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: nil) (B :: Bp :: Dp :: bd :: nil) 2 2 HBBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBBpDpbdm3 : rk(B :: Bp :: Dp :: bd :: nil) >= 3).
{
	assert(HBBpDpmtmp : rk(B :: Bp :: Dp :: nil) >= 3) by (solve_hyps_min HBBpDpeq HBBpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Bp :: Dp :: nil) (B :: Bp :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Bp :: Dp :: nil) (B :: Bp :: Dp :: bd :: nil) 3 3 HBBpDpmtmp Hcomp Hincl);apply HT.
}

assert(HBBpDpbdM : rk(B :: Bp :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBBpDpbdm : rk(B :: Bp :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBBpDpbdeq HBBpDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Bbd requis par la preuve de (?)Bbd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HBbdm2 : rk(B :: bd :: nil) >= 2).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBBpDpbdeq : rk(B :: Bp :: Dp :: bd :: nil) = 3) by (apply LBBpDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBBpDpbdmtmp : rk(B :: Bp :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HBBpDpbdeq HBBpDpbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: bd :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Bp :: Dp :: bd :: nil) (B :: bd :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bd :: Bp :: Dp :: bd :: nil) ((B :: bd :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBBpDpbdmtmp;try rewrite HT2 in HBBpDpbdmtmp.
	assert(HT := rule_2 (B :: bd :: nil) (Bp :: Dp :: bd :: nil) (bd :: nil) 3 1 2 HBBpDpbdmtmp Hbdmtmp HBpDpbdMtmp Hincl);apply HT.
}

assert(HBbdM : rk(B :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HBbdeq HBbdM2).
assert(HBbdm : rk(B :: bd ::  nil) >= 1) by (solve_hyps_min HBbdeq HBbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBCbd *)
(* dans la couche 0 *)
Lemma LBCDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCDbd requis par la preuve de (?)BCDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDbd requis par la preuve de (?)BCDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDbd requis par la preuve de (?)BCDbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDbdM3 : rk(B :: C :: D :: bd :: nil) <= 3).
{
	assert(HCMtmp : rk(C :: nil) <= 1) by (solve_hyps_max HCeq HCM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (C :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: bd :: nil) (C :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: B :: D :: bd :: nil) ((C :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HCMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDbdm2 : rk(B :: C :: D :: bd :: nil) >= 2).
{
	assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: D :: bd :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDbdm3 : rk(B :: C :: D :: bd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: D :: bd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCDbdM : rk(B :: C :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCDbdm : rk(B :: C :: D :: bd ::  nil) >= 1) by (solve_hyps_min HBCDbdeq HBCDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbd requis par la preuve de (?)BCbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)BCbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)OoABCApbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbdm4 : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCbd requis par la preuve de (?)BCbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbdm2 : rk(B :: C :: bd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbdeq HOoABCApbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbdmtmp;try rewrite HT2 in HOoABCApbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bd :: nil) (nil) 4 0 2 HOoABCApbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBCbdm3 : rk(B :: C :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCDbdeq : rk(B :: C :: D :: bd :: nil) = 3) by (apply LBCDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDbdmtmp : rk(B :: C :: D :: bd :: nil) >= 3) by (solve_hyps_min HBCDbdeq HBCDbdm3).
	assert(HBbdeq : rk(B :: bd :: nil) = 2) by (apply LBbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbdmtmp : rk(B :: bd :: nil) >= 2) by (solve_hyps_min HBbdeq HBbdm2).
	assert(Hincl : incl (B :: bd :: nil) (list_inter (B :: C :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: bd :: nil) (B :: C :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bd :: B :: D :: bd :: nil) ((B :: C :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDbdmtmp;try rewrite HT2 in HBCDbdmtmp.
	assert(HT := rule_2 (B :: C :: bd :: nil) (B :: D :: bd :: nil) (B :: bd :: nil) 3 2 2 HBCDbdmtmp HBbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HBCbdM : rk(B :: C :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBCbdeq HBCbdM3).
assert(HBCbdm : rk(B :: C :: bd ::  nil) >= 1) by (solve_hyps_min HBCbdeq HBCbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbd requis par la preuve de (?)OoABCApbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbdm4 : rk(Oo :: A :: B :: C :: Ap :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbdM : rk(Oo :: A :: B :: C :: Ap :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbdm : rk(Oo :: A :: B :: C :: Ap :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbdeq HOoABCApbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDbd *)
(* dans la couche 0 *)
Lemma LBpDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Bp :: D :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BpDDpbd requis par la preuve de (?)BpDDpbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBpDDpbdM3 : rk(Bp :: D :: Dp :: bd :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Bp :: Dp :: bd :: nil) ((D :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Bp :: Dp :: bd :: nil) (nil) 1 2 0 HDMtmp HBpDpbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBpDDpbdm2 : rk(Bp :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBpDeq : rk(Bp :: D :: nil) = 2) by (apply LBpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDmtmp : rk(Bp :: D :: nil) >= 2) by (solve_hyps_min HBpDeq HBpDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Bp :: D :: nil) (Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: D :: nil) (Bp :: D :: Dp :: bd :: nil) 2 2 HBpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HBpDDpbdm3 : rk(Bp :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HBpDDpmtmp : rk(Bp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HBpDDpeq HBpDDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Bp :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Bp :: D :: Dp :: nil) (Bp :: D :: Dp :: bd :: nil) 3 3 HBpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HBpDDpbdM : rk(Bp :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBpDDpbdm : rk(Bp :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dbd requis par la preuve de (?)Dbd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDbdm2 : rk(D :: bd :: nil) >= 2).
{
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBpDDpbdeq : rk(Bp :: D :: Dp :: bd :: nil) = 3) by (apply LBpDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDDpbdmtmp : rk(Bp :: D :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HBpDDpbdeq HBpDDpbdm3).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (D :: bd :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Bp :: D :: Dp :: bd :: nil) (D :: bd :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: bd :: Bp :: Dp :: bd :: nil) ((D :: bd :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBpDDpbdmtmp;try rewrite HT2 in HBpDDpbdmtmp.
	assert(HT := rule_2 (D :: bd :: nil) (Bp :: Dp :: bd :: nil) (bd :: nil) 3 1 2 HBpDDpbdmtmp Hbdmtmp HBpDpbdMtmp Hincl);apply HT.
}

assert(HDbdM : rk(D :: bd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDbdeq HDbdM2).
assert(HDbdm : rk(D :: bd ::  nil) >= 1) by (solve_hyps_min HDbdeq HDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADbd *)
(* dans la couche 0 *)
Lemma LABDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDbd requis par la preuve de (?)ABDbd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HABDbdM3 : rk(A :: B :: D :: bd :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: D :: bd :: nil) ((A :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (B :: D :: bd :: nil) (nil) 1 2 0 HAMtmp HBDbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDbdm2 : rk(A :: B :: D :: bd :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (A :: B :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (A :: B :: D :: bd :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDbdm3 : rk(A :: B :: D :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABDbdM : rk(A :: B :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDbdm : rk(A :: B :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABDbdeq HABDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADbd requis par la preuve de (?)ADbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADbdm2 : rk(A :: D :: bd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: bd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HADbdm3 : rk(A :: D :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HABDbdeq : rk(A :: B :: D :: bd :: nil) = 3) by (apply LABDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDbdmtmp : rk(A :: B :: D :: bd :: nil) >= 3) by (solve_hyps_min HABDbdeq HABDbdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (A :: D :: bd :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: bd :: nil) (A :: D :: bd :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: bd :: B :: D :: bd :: nil) ((A :: D :: bd :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDbdmtmp;try rewrite HT2 in HABDbdmtmp.
	assert(HT := rule_2 (A :: D :: bd :: nil) (B :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HABDbdmtmp HDbdmtmp HBDbdMtmp Hincl);apply HT.
}

assert(HADbdM : rk(A :: D :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADbdeq HADbdM3).
assert(HADbdm : rk(A :: D :: bd ::  nil) >= 1) by (solve_hyps_min HADbdeq HADbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAabDbd *)
(* dans la couche 0 *)
Lemma LABabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDbdeq HOoABApabDbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDbdmtmp;try rewrite HT2 in HOoABApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabDbdm3 : rk(A :: B :: ab :: D :: bd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

assert(HABabDbdM : rk(A :: B :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabDbdm : rk(A :: B :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HABabDbdeq HABabDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDadbdeq HOoABApabDadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadbdmtmp;try rewrite HT2 in HOoABApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadbdm2 : rk(A :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDadbdm3 : rk(A :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ad :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ab :: ad :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HAabadmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ABabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDbd requis par la preuve de (?)OoABApabDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDbd requis par la preuve de (?)ABabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDbdm2 : rk(A :: B :: ab :: D :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDbdeq HOoABApabDbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDbdmtmp;try rewrite HT2 in HOoABApabDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HABabDbdM3 : rk(A :: B :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (A :: B :: ab :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: B :: ab :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HABabMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDbd requis par la preuve de (?)AabDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: bd ::  de rang :  2 et 3 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDbdm2 : rk(A :: ab :: D :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDbdmtmp : rk(A :: B :: ab :: D :: bd :: nil) >= 2) by (solve_hyps_min HABabDbdeq HABabDbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDbdmtmp;try rewrite HT2 in HABabDbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: ab :: D :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HAabDbdm3 : rk(A :: ab :: D :: bd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAabDadbdmtmp : rk(A :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HAabDadbdeq HAabDadbdm3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: ab :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: bd :: nil) (A :: D :: ad :: A :: ab :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: ab :: D :: bd :: nil) ((A :: D :: ad :: nil) ++ (A :: ab :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAabDadbdmtmp;try rewrite HT2 in HAabDadbdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: ab :: D :: bd :: nil) (A :: D :: nil) 3 2 2 HAabDadbdmtmp HADmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDbdM3 : rk(A :: ab :: D :: bd :: nil) <= 3).
{
	assert(HABabDbdeq : rk(A :: B :: ab :: D :: bd :: nil) = 3) by (apply LABabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDbdMtmp : rk(A :: B :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HABabDbdeq HABabDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: D :: bd :: nil) (A :: B :: ab :: D :: bd :: nil) 3 3 HABabDbdMtmp Hcomp Hincl);apply HT.
}

assert(HAabDbdM : rk(A :: ab :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDbdm : rk(A :: ab :: D :: bd ::  nil) >= 1) by (solve_hyps_min HAabDbdeq HAabDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCbcDbd *)
(* dans la couche 0 *)
Lemma LBCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdm3 : rk(B :: C :: bc :: D :: bd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCbcDbdM : rk(B :: C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdm : rk(B :: C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbd requis par la preuve de (?)BCbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdm2 : rk(B :: C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdmtmp;try rewrite HT2 in HOoABCApbcDbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: nil) (nil) 4 0 2 HOoABCApbcDbdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDbdM3 : rk(B :: C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBmtmp : rk(B :: nil) >= 1) by (solve_hyps_min HBeq HBm1).
	assert(Hincl : incl (B :: nil) (list_inter (B :: C :: bc :: nil) (B :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: B :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (B :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (B :: D :: bd :: nil) (B :: nil) 2 2 1 HBCbcMtmp HBDbdMtmp HBmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbd requis par la preuve de (?)CbcDbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  2 et 3 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdm2 : rk(C :: bc :: D :: bd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 2) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdm3 : rk(C :: bc :: D :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdmtmp : rk(B :: C :: bc :: D :: bd :: nil) >= 3) by (solve_hyps_min HBCbcDbdeq HBCbcDbdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdmtmp;try rewrite HT2 in HBCbcDbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCbcDbdM3 : rk(C :: bc :: D :: bd :: nil) <= 3).
{
	assert(HBCbcDbdeq : rk(B :: C :: bc :: D :: bd :: nil) = 3) by (apply LBCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdMtmp : rk(B :: C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HBCbcDbdeq HBCbcDbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (C :: bc :: D :: bd :: nil) (B :: C :: bc :: D :: bd :: nil) 3 3 HBCbcDbdMtmp Hcomp Hincl);apply HT.
}

assert(HCbcDbdM : rk(C :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdm : rk(C :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HCbcDbdeq HCbcDbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbd requis par la preuve de (?)OoABCApbcDbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdeq HOoABCApbcDbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpbd *)
(* dans constructLemma(), requis par LBApDDpbd *)
(* dans constructLemma(), requis par LOoBApDDpbd *)
(* dans constructLemma(), requis par LOoBCApDDpbd *)
(* dans constructLemma(), requis par LOoBCApbcDDpbd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDDpbd requis par la preuve de (?)OoABCApbcDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDDpbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDDpbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDDpbdeq HOoABCApbcDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDDpbd requis par la preuve de (?)OoBCApbcDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDDpbd requis par la preuve de (?)OoBCApbcDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDDpbdm3 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDDpbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) = 4) by (apply LOoABCApbcDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpbdeq HOoABCApbcDDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpbdmtmp;try rewrite HT2 in HOoABCApbcDDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDDpbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDDpbdm4 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDDpbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) = 4) by (apply LOoABCApbcDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpbdeq HOoABCApbcDDpbdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpbdmtmp;try rewrite HT2 in HOoABCApbcDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDDpbdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDDpbdM : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDDpbdm : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDDpbdeq HOoBCApbcDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpbd requis par la preuve de (?)OoBCApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpbd requis par la preuve de (?)OoBCApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpbd requis par la preuve de (?)OoABCApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpbd requis par la preuve de (?)OoBCApDDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpbdm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpbdeq HOoABCApDDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpbdmtmp;try rewrite HT2 in HOoABCApDDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDDpbdm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDDpbdeq : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) = 4) by (apply LOoBCApbcDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDDpbdmtmp : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDDpbdeq HOoBCApbcDDpbdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: D :: Dp :: bd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDDpbdmtmp;try rewrite HT2 in HOoBCApbcDDpbdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDDpbdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDDpbdM : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDDpbdm : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApDDpbdeq HOoBCApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApacDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApacDDpbd requis par la preuve de (?)OoBApacDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacDDpbd requis par la preuve de (?)OoABApacDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacDDpbd requis par la preuve de (?)OoABApacDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacDDpbd requis par la preuve de (?)OoABApacDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpbdm2 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpbdm3 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacDDpbdm4 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApacDDpbd requis par la preuve de (?)OoBApacDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApacDDpbd requis par la preuve de (?)OoBApacDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApacDDpbd requis par la preuve de (?)OoBApacDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpbdm2 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpbdm3 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBaceq : rk(Oo :: B :: ac :: nil) = 3) by (apply LOoBac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBacmtmp : rk(Oo :: B :: ac :: nil) >= 3) by (solve_hyps_min HOoBaceq HOoBacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 3 3 HOoBacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoBApacDDpbdm4 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoABApacDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApacDDpbdeq HOoABApacDDpbdm4).
	assert(HOoApaceq : rk(Oo :: Ap :: ac :: nil) = 3) by (apply LOoApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApacmtmp : rk(Oo :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoApaceq HOoApacm3).
	assert(Hincl : incl (Oo :: Ap :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacDDpbdmtmp;try rewrite HT2 in HOoABApacDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) (Oo :: Ap :: ac :: nil) 4 3 3 HOoABApacDDpbdmtmp HOoApacmtmp HOoAApacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApDDpbd requis par la preuve de (?)OoBApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApDDpbdm2 : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ac :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : B :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoBApDDpbdm3 : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HBApaceq : rk(B :: Ap :: ac :: nil) = 3) by (apply LBApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApacMtmp : rk(B :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HBApaceq HBApacM3).
	assert(HOoBApacDDpbdmtmp : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApacDDpbdeq HOoBApacDDpbdm4).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (B :: Ap :: ac :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) (B :: Ap :: ac :: Oo :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: ac :: Oo :: B :: Ap :: D :: Dp :: bd :: nil) ((B :: Ap :: ac :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApacDDpbdmtmp;try rewrite HT2 in HOoBApacDDpbdmtmp.
	assert(HT := rule_4 (B :: Ap :: ac :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (B :: Ap :: nil) 4 2 3 HOoBApacDDpbdmtmp HBApmtmp HBApacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: B :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HOoBApDDpbdm4 : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpbdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoBCApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpbdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpbdeq HOoBCApDDpbdm4).
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hincl : incl (Oo :: B :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) (Oo :: B :: C :: D :: Oo :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpbdmtmp;try rewrite HT2 in HOoBCApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: B :: D :: nil) 4 3 3 HOoBCApDDpbdmtmp HOoBDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HOoBApDDpbdM : rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApDDpbdm : rk(Oo :: B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApDDpbdeq HOoBApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpbd requis par la preuve de (?)BApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApDDpbdm2 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : B :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HBApDDpbdm3 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpbdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoBCApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpbdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpbdeq HOoBCApDDpbdm4).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: bd :: nil) (Oo :: B :: C :: D :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: B :: C :: D :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpbdmtmp;try rewrite HT2 in HOoBCApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (B :: D :: nil) 4 2 3 HOoBCApDDpbdmtmp HBDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApDDpbdm4 : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApDDpbdeq : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LOoBApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApDDpbdmtmp : rk(Oo :: B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBApDDpbdeq HOoBApDDpbdm4).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: D :: Dp :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApDDpbdmtmp;try rewrite HT2 in HOoBApDDpbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApDDpbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBApDDpbdM : rk(B :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpbdm : rk(B :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDpbd requis par la preuve de (?)ApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApbcDpbd requis par la preuve de (?)OoBCApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDpbd requis par la preuve de (?)OoBCApbcDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpbd requis par la preuve de (?)OoABCApbcDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpbd requis par la preuve de (?)OoBCApbcDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpbd requis par la preuve de (?)OoBCApbcDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpbdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpbdeq HOoABCApbcDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpbdmtmp;try rewrite HT2 in HOoABCApbcDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpbdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpbdeq HOoABCApbcDpbdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpbdmtmp;try rewrite HT2 in HOoABCApbcDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpbdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpbd requis par la preuve de (?)OoBCApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpbd requis par la preuve de (?)OoBCApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpbd requis par la preuve de (?)OoABCApDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpbd requis par la preuve de (?)OoBCApDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpbdm3 : rk(Oo :: B :: C :: Ap :: Dp :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDpbdeq HOoABCApDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpbdmtmp;try rewrite HT2 in HOoABCApDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: bd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpbdm4 : rk(Oo :: B :: C :: Ap :: Dp :: bd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpbdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpbdeq HOoBCApbcDpbdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: bd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpbdmtmp;try rewrite HT2 in HOoBCApbcDpbdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpbdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpbd requis par la preuve de (?)ApDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Dp ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Dp ::   de rang : 3 et 3 *)
assert(HApDpbdm2 : rk(Ap :: Dp :: bd :: nil) >= 2).
{
	assert(HOoBCDpeq : rk(Oo :: B :: C :: Dp :: nil) = 3) by (apply LOoBCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDpMtmp : rk(Oo :: B :: C :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCDpeq HOoBCDpM3).
	assert(HOoBCApDpbdmtmp : rk(Oo :: B :: C :: Ap :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApDpbdeq HOoBCApDpbdm4).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Dp :: bd :: nil) (Oo :: B :: C :: Dp :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Dp :: Ap :: Dp :: bd :: nil) ((Oo :: B :: C :: Dp :: nil) ++ (Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDpbdmtmp;try rewrite HT2 in HOoBCApDpbdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: bd :: nil) (Dp :: nil) 4 1 3 HOoBCApDpbdmtmp HDpmtmp HOoBCDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpbdm3 : rk(Ap :: Dp :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApDDpbdeq : rk(B :: Ap :: D :: Dp :: bd :: nil) = 4) by (apply LBApDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApDDpbdmtmp : rk(B :: Ap :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpbdeq HBApDDpbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpbdmtmp;try rewrite HT2 in HBApDDpbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HApDpbdM : rk(Ap :: Dp :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpbdeq HApDpbdM3).
assert(HApDpbdm : rk(Ap :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApDpbdeq HApDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApDpbd *)
(* dans constructLemma(), requis par LOoBCApbcDpbd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpbd requis par la preuve de (?)OoABCApbcDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDpbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDpbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDpbdeq HOoABCApbcDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpbd requis par la preuve de (?)OoBCApbcDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpbd requis par la preuve de (?)OoBCApbcDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpbdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) = 4) by (apply LOoABCApbcDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpbdeq HOoABCApbcDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpbdmtmp;try rewrite HT2 in HOoABCApbcDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpbdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) = 4) by (apply LOoABCApbcDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpbdeq HOoABCApbcDpbdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpbdmtmp;try rewrite HT2 in HOoABCApbcDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpbdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDpbdM : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDpbdm : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDpbdeq HOoBCApbcDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpbd requis par la preuve de (?)OoBCApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpbd requis par la preuve de (?)OoBCApDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpbd requis par la preuve de (?)OoABCApDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpbd requis par la preuve de (?)OoBCApDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpbdm3 : rk(Oo :: B :: C :: Ap :: Dp :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDpbdeq HOoABCApDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpbdmtmp;try rewrite HT2 in HOoABCApDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: bd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpbdm4 : rk(Oo :: B :: C :: Ap :: Dp :: bd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpbdeq : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) = 4) by (apply LOoBCApbcDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDpbdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpbdeq HOoBCApbcDpbdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: bd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: bd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpbdmtmp;try rewrite HT2 in HOoBCApbcDpbdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: bd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpbdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDpbdM : rk(Oo :: B :: C :: Ap :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDpbdm : rk(Oo :: B :: C :: Ap :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApDpbdeq HOoBCApDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpbd requis par la preuve de (?)OoABCApDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDpbdM : rk(Oo :: A :: B :: C :: Ap :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpbdm : rk(Oo :: A :: B :: C :: Ap :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDpbdeq HOoABCApDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApabDpbd *)
(* dans constructLemma(), requis par LApBpabDpbd *)
(* dans constructLemma(), requis par LOoCApBpabDpbd *)
(* dans constructLemma(), requis par LOoACApBpabDpbd *)
(* dans la couche 0 *)
Lemma LOoABCApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDpbd requis par la preuve de (?)OoABCApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabDpbdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDpbdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDpbdeq HOoABCApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDpbd requis par la preuve de (?)OoACApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDpbd requis par la preuve de (?)OoACApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDpbd requis par la preuve de (?)OoACApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDpbdm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDpbdm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDpbdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoABCApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpbdeq HOoABCApBpabDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpbdmtmp;try rewrite HT2 in HOoABCApBpabDpbdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDpbdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDpbdm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDpbdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoABCApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpbdeq HOoABCApBpabDpbdm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpbdmtmp;try rewrite HT2 in HOoABCApBpabDpbdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDpbdmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpabDpbdM : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpabDpbdm : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoACApBpabDpbdeq HOoACApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDpbd requis par la preuve de (?)OoCApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDpbd requis par la preuve de (?)OoCApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDpbd requis par la preuve de (?)OoCApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDpbd requis par la preuve de (?)OoBCApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDpbdm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDpbdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoABCApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpbdeq HOoABCApBpabDpbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpbdmtmp;try rewrite HT2 in HOoABCApBpabDpbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDpbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDpbd requis par la preuve de (?)OoCApBpabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDpbdm2 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDpbdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDpbdeq HOoBCApBpabDpbdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDpbdmtmp;try rewrite HT2 in HOoBCApBpabDpbdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDpbdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDpbdm3 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDpbdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoABCApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDpbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDpbdeq HOoABCApBpabDpbdm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDpbdmtmp;try rewrite HT2 in HOoABCApBpabDpbdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDpbdmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDpbdm4 : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDpbdeq : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoACApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpabDpbdmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoACApBpabDpbdeq HOoACApBpabDpbdm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDpbdmtmp;try rewrite HT2 in HOoACApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDpbdmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

assert(HOoCApBpabDpbdM : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpabDpbdm : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoCApBpabDpbdeq HOoCApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApBpabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApBpabDpbd requis par la preuve de (?)ApBpabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApBpabDpbdm2 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Bp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) 2 2 HApBpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApBpabDpbdM3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3).
{
	assert(HApBpabMtmp : rk(Ap :: Bp :: ab :: nil) <= 2) by (solve_hyps_max HApBpabeq HApBpabM2).
	assert(HBpDpbdMtmp : rk(Bp :: Dp :: bd :: nil) <= 2) by (solve_hyps_max HBpDpbdeq HBpDpbdM2).
	assert(HBpmtmp : rk(Bp :: nil) >= 1) by (solve_hyps_min HBpeq HBpm1).
	assert(Hincl : incl (Bp :: nil) (list_inter (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Bp :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Bp :: ab :: Bp :: Dp :: bd :: nil) ((Ap :: Bp :: ab :: nil) ++ (Bp :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Bp :: ab :: nil) (Bp :: Dp :: bd :: nil) (Bp :: nil) 2 2 1 HApBpabMtmp HBpDpbdMtmp HBpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Bp :: Dp ::  de rang :  2 et 2 	 A : Oo :: C :: Bp :: Dp ::   de rang : 3 et 3 *)
assert(HApBpabDpbdm3 : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HOoCBpDpeq : rk(Oo :: C :: Bp :: Dp :: nil) = 3) by (apply LOoCBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCBpDpMtmp : rk(Oo :: C :: Bp :: Dp :: nil) <= 3) by (solve_hyps_max HOoCBpDpeq HOoCBpDpM3).
	assert(HOoCApBpabDpbdeq : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) = 4) by (apply LOoCApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApBpabDpbdmtmp : rk(Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoCApBpabDpbdeq HOoCApBpabDpbdm4).
	assert(HBpDpeq : rk(Bp :: Dp :: nil) = 2) by (apply LBpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBpDpmtmp : rk(Bp :: Dp :: nil) >= 2) by (solve_hyps_min HBpDpeq HBpDpm2).
	assert(Hincl : incl (Bp :: Dp :: nil) (list_inter (Oo :: C :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: ab :: Dp :: bd :: nil) (Oo :: C :: Bp :: Dp :: Ap :: Bp :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Bp :: Dp :: Ap :: Bp :: ab :: Dp :: bd :: nil) ((Oo :: C :: Bp :: Dp :: nil) ++ (Ap :: Bp :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpabDpbdmtmp;try rewrite HT2 in HOoCApBpabDpbdmtmp.
	assert(HT := rule_4 (Oo :: C :: Bp :: Dp :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) (Bp :: Dp :: nil) 4 2 3 HOoCApBpabDpbdmtmp HBpDpmtmp HOoCBpDpMtmp Hincl); apply HT.
}

assert(HApBpabDpbdM : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApBpabDpbdm : rk(Ap :: Bp :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApBpabDpbdeq HApBpabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpbdm2 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpbdm3 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabDpbdm4 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 4).
{
	assert(HABApDpeq : rk(A :: B :: Ap :: Dp :: nil) = 4) by (apply LABApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApDpmtmp : rk(A :: B :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HABApDpeq HABApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 4 4 HABApDpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpbd requis par la preuve de (?)ApabDpbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpbdm2 : rk(Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpbdeq HABApabDpbdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpbdmtmp;try rewrite HT2 in HABApabDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: bd ::  de rang :  4 et 4 	 AiB : ab :: Dp ::  de rang :  2 et 2 	 A : A :: B :: ab :: Dp ::   de rang : 3 et 3 *)
assert(HApabDpbdm3 : rk(Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HABabDpeq : rk(A :: B :: ab :: Dp :: nil) = 3) by (apply LABabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDpMtmp : rk(A :: B :: ab :: Dp :: nil) <= 3) by (solve_hyps_max HABabDpeq HABabDpM3).
	assert(HABApabDpbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HABApabDpbdeq HABApabDpbdm4).
	assert(HabDpeq : rk(ab :: Dp :: nil) = 2) by (apply LabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabDpmtmp : rk(ab :: Dp :: nil) >= 2) by (solve_hyps_min HabDpeq HabDpm2).
	assert(Hincl : incl (ab :: Dp :: nil) (list_inter (A :: B :: ab :: Dp :: nil) (Ap :: ab :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: bd :: nil) (A :: B :: ab :: Dp :: Ap :: ab :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Dp :: Ap :: ab :: Dp :: bd :: nil) ((A :: B :: ab :: Dp :: nil) ++ (Ap :: ab :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpbdmtmp;try rewrite HT2 in HABApabDpbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: Dp :: nil) (Ap :: ab :: Dp :: bd :: nil) (ab :: Dp :: nil) 4 2 3 HABApabDpbdmtmp HabDpmtmp HABabDpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApabDpbdM3 : rk(Ap :: ab :: Dp :: bd :: nil) <= 3).
{
	assert(HApBpabDpbdeq : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) = 3) by (apply LApBpabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpabDpbdMtmp : rk(Ap :: Bp :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApBpabDpbdeq HApBpabDpbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Bp :: ab :: Dp :: bd :: nil) 3 3 HApBpabDpbdMtmp Hcomp Hincl);apply HT.
}

assert(HApabDpbdM : rk(Ap :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpbdm : rk(Ap :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpbdeq HApabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABApabDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpbd requis par la preuve de (?)ABApabDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpbdm2 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpbdm3 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabDpbdm4 : rk(A :: B :: Ap :: ab :: Dp :: bd :: nil) >= 4).
{
	assert(HABApDpeq : rk(A :: B :: Ap :: Dp :: nil) = 4) by (apply LABApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApDpmtmp : rk(A :: B :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HABApDpeq HABApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: bd :: nil) 4 4 HABApDpmtmp Hcomp Hincl);apply HT.
}

assert(HABApabDpbdM : rk(A :: B :: Ap :: ab :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabDpbdm : rk(A :: B :: Ap :: ab :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HABApabDpbdeq HABApabDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpbd requis par la preuve de (?)OoABCApDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpbdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpbdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpbdeq HOoABCApDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApacDDpbd *)
(* dans la couche 0 *)
Lemma LOoABApacDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacDDpbd requis par la preuve de (?)OoABApacDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacDDpbd requis par la preuve de (?)OoABApacDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacDDpbd requis par la preuve de (?)OoABApacDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpbdm2 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpbdm3 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacDDpbdm4 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApacDDpbdM : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApacDDpbdm : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApacDDpbdeq HOoABApacDDpbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApacDDpbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApacDDpbd requis par la preuve de (?)OoBApacDDpbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApacDDpbd requis par la preuve de (?)OoBApacDDpbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApacDDpbd requis par la preuve de (?)OoBApacDDpbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpbdm2 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpbdm3 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 3).
{
	assert(HOoBaceq : rk(Oo :: B :: ac :: nil) = 3) by (apply LOoBac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBacmtmp : rk(Oo :: B :: ac :: nil) >= 3) by (solve_hyps_min HOoBaceq HOoBacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) 3 3 HOoBacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoBApacDDpbdm4 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoABApacDDpbdeq : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) = 4) by (apply LOoABApacDDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApacDDpbdmtmp : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) >= 4) by (solve_hyps_min HOoABApacDDpbdeq HOoABApacDDpbdm4).
	assert(HOoApaceq : rk(Oo :: Ap :: ac :: nil) = 3) by (apply LOoApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApacmtmp : rk(Oo :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoApaceq HOoApacm3).
	assert(Hincl : incl (Oo :: Ap :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: D :: Dp :: bd :: nil) (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacDDpbdmtmp;try rewrite HT2 in HOoABApacDDpbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: bd :: nil) (Oo :: Ap :: ac :: nil) 4 3 3 HOoABApacDDpbdmtmp HOoApacmtmp HOoAApacMtmp Hincl); apply HT.
}

assert(HOoBApacDDpbdM : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApacDDpbdm : rk(Oo :: B :: Ap :: ac :: D :: Dp :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApacDDpbdeq HOoBApacDDpbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LAabadbd *)
(* dans constructLemma(), requis par LAabDadbd *)
(* dans la couche 0 *)
Lemma LADadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadbd requis par la preuve de (?)ADadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadbdm2 : rk(A :: D :: ad :: bd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: ad :: bd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HADadbdM3 : rk(A :: D :: ad :: bd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: bd :: nil) ((A :: D :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (bd :: nil) (nil) 2 1 0 HADadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadbdm3 : rk(A :: D :: ad :: bd :: nil) >= 3).
{
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) 3 3 HADbdmtmp Hcomp Hincl);apply HT.
}

assert(HADadbdM : rk(A :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadbdm : rk(A :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HADadbdeq HADadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabDadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: D :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabDadbd requis par la preuve de (?)OoABApabDadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabDadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabDadbd requis par la preuve de (?)ABabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: D :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabDadbdm2 : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabDadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabDadbdeq HOoABApabDadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: D :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: D :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabDadbdmtmp;try rewrite HT2 in HOoABApabDadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabDadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AabDadbd requis par la preuve de (?)AabDadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: D :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabDadbdm2 : rk(A :: ab :: D :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabDadbdmtmp : rk(A :: B :: ab :: D :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabDadbdeq HABabDadbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: D :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: D :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabDadbdmtmp;try rewrite HT2 in HABabDadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabDadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabDadbdm3 : rk(A :: ab :: D :: ad :: bd :: nil) >= 3).
{
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ad :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ab :: ad :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HAabadmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAabDadbdM3 : rk(A :: ab :: D :: ad :: bd :: nil) <= 3).
{
	assert(HAabDbdeq : rk(A :: ab :: D :: bd :: nil) = 3) by (apply LAabDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabDbdMtmp : rk(A :: ab :: D :: bd :: nil) <= 3) by (solve_hyps_max HAabDbdeq HAabDbdM3).
	assert(HADadbdeq : rk(A :: D :: ad :: bd :: nil) = 3) by (apply LADadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadbdMtmp : rk(A :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HADadbdeq HADadbdM3).
	assert(HADbdeq : rk(A :: D :: bd :: nil) = 3) by (apply LADbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADbdmtmp : rk(A :: D :: bd :: nil) >= 3) by (solve_hyps_min HADbdeq HADbdm3).
	assert(Hincl : incl (A :: D :: bd :: nil) (list_inter (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ab :: D :: ad :: bd :: nil) (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: D :: bd :: A :: D :: ad :: bd :: nil) ((A :: ab :: D :: bd :: nil) ++ (A :: D :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ab :: D :: bd :: nil) (A :: D :: ad :: bd :: nil) (A :: D :: bd :: nil) 3 3 3 HAabDbdMtmp HADadbdMtmp HADbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAabDadbdM : rk(A :: ab :: D :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabDadbdm : rk(A :: ab :: D :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAabDadbdeq HAabDadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAabadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ab :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aabadbd requis par la preuve de (?)Aabadbd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aabadbd requis par la preuve de (?)Aabadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabadbd requis par la preuve de (?)Aabadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)ABabadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)OoABApabadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)OoABApabadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabadbd requis par la preuve de (?)ABabadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadbdm2 : rk(A :: B :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabadbdeq HOoABApabadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadbdmtmp;try rewrite HT2 in HOoABApabadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aabadbd requis par la preuve de (?)Aabadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: ad :: bd ::  de rang :  2 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAabadbdm2 : rk(A :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabadbdmtmp : rk(A :: B :: ab :: ad :: bd :: nil) >= 2) by (solve_hyps_min HABabadbdeq HABabadbdm2).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: bd :: nil) (A :: B :: ab :: A :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: ab :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadbdmtmp;try rewrite HT2 in HABabadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: ab :: ad :: bd :: nil) (A :: ab :: nil) 2 2 2 HABabadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabadbdm3 : rk(A :: ab :: ad :: bd :: nil) >= 3).
{
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ad :: nil) (A :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ab :: ad :: nil) (A :: ab :: ad :: bd :: nil) 3 3 HAabadmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAabadbdM3 : rk(A :: ab :: ad :: bd :: nil) <= 3).
{
	assert(HAabDadbdeq : rk(A :: ab :: D :: ad :: bd :: nil) = 3) by (apply LAabDadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabDadbdMtmp : rk(A :: ab :: D :: ad :: bd :: nil) <= 3) by (solve_hyps_max HAabDadbdeq HAabDadbdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ab :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ab :: ad :: bd :: nil) (A :: ab :: D :: ad :: bd :: nil) 3 3 HAabDadbdMtmp Hcomp Hincl);apply HT.
}

assert(HAabadbdM : rk(A :: ab :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAabadbdm : rk(A :: ab :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAabadbdeq HAabadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LApabDpadbd *)
(* dans constructLemma(), requis par LApDpadbd *)
(* dans constructLemma(), requis par LBApDDpadbd *)
(* dans constructLemma(), requis par LOoBApDDpadbd *)
(* dans constructLemma(), requis par LOoBCApDDpadbd *)
(* dans constructLemma(), requis par LOoBCApbcDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDDpadbd requis par la preuve de (?)OoABCApbcDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDDpadbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDDpadbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDDpadbdeq HOoABCApbcDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDDpadbd requis par la preuve de (?)OoBCApbcDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDDpadbd requis par la preuve de (?)OoBCApbcDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDDpadbdm3 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDDpadbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABCApbcDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadbdeq HOoABCApbcDDpadbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadbdmtmp;try rewrite HT2 in HOoABCApbcDDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDDpadbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDDpadbdm4 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDDpadbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABCApbcDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadbdeq HOoABCApbcDDpadbdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadbdmtmp;try rewrite HT2 in HOoABCApbcDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDDpadbdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDDpadbdM : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDDpadbdm : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDDpadbdeq HOoBCApbcDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpadbd requis par la preuve de (?)OoBCApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadbd requis par la preuve de (?)OoBCApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadbd requis par la preuve de (?)OoABCApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpadbd requis par la preuve de (?)OoBCApDDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpadbdm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadbdeq HOoABCApDDpadbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadbdmtmp;try rewrite HT2 in HOoABCApDDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDDpadbdm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDDpadbdeq : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBCApbcDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDDpadbdmtmp : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDDpadbdeq HOoBCApbcDDpadbdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: bd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDDpadbdmtmp;try rewrite HT2 in HOoBCApbcDDpadbdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDDpadbdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDDpadbdM : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDDpadbdm : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApDDpadbdeq HOoBCApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBApacDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABApacDDpadbd requis par la preuve de (?)OoBApacDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacDDpadbd requis par la preuve de (?)OoABApacDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacDDpadbd requis par la preuve de (?)OoABApacDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacDDpadbd requis par la preuve de (?)OoABApacDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApacDDpadbd requis par la preuve de (?)OoBApacDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApacDDpadbd requis par la preuve de (?)OoBApacDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApacDDpadbd requis par la preuve de (?)OoBApacDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpadbdm2 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpadbdm3 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBaceq : rk(Oo :: B :: ac :: nil) = 3) by (apply LOoBac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBacmtmp : rk(Oo :: B :: ac :: nil) >= 3) by (solve_hyps_min HOoBaceq HOoBacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoBApacDDpadbdm4 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoABApacDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApacDDpadbdeq HOoABApacDDpadbdm4).
	assert(HOoApaceq : rk(Oo :: Ap :: ac :: nil) = 3) by (apply LOoApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApacmtmp : rk(Oo :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoApaceq HOoApacm3).
	assert(Hincl : incl (Oo :: Ap :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacDDpadbdmtmp;try rewrite HT2 in HOoABApacDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: ac :: nil) 4 3 3 HOoABApacDDpadbdmtmp HOoApacmtmp HOoAApacMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApDDpadbd requis par la preuve de (?)OoBApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApDDpadbdm2 : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : B :: Ap ::  de rang :  2 et 2 	 A : B :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoBApDDpadbdm3 : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HBApaceq : rk(B :: Ap :: ac :: nil) = 3) by (apply LBApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApacMtmp : rk(B :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HBApaceq HBApacM3).
	assert(HOoBApacDDpadbdmtmp : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApacDDpadbdeq HOoBApacDDpadbdm4).
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hincl : incl (B :: Ap :: nil) (list_inter (B :: Ap :: ac :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: ac :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: ac :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((B :: Ap :: ac :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApacDDpadbdmtmp;try rewrite HT2 in HOoBApacDDpadbdmtmp.
	assert(HT := rule_4 (B :: Ap :: ac :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: Ap :: nil) 4 2 3 HOoBApacDDpadbdmtmp HBApmtmp HBApacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: B :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HOoBApDDpadbdm4 : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpadbdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBCApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpadbdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpadbdeq HOoBCApDDpadbdm4).
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hincl : incl (Oo :: B :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: C :: D :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpadbdmtmp;try rewrite HT2 in HOoBCApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: D :: nil) 4 3 3 HOoBCApDDpadbdmtmp HOoBDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HOoBApDDpadbdM : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApDDpadbdm : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApDDpadbdeq HOoBApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BApDDpadbd requis par la preuve de (?)BApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBApDDpadbdm2 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : B :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HBApDDpadbdm3 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpadbdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBCApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpadbdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpadbdeq HOoBCApDDpadbdm4).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: B :: C :: D :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: B :: C :: D :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpadbdmtmp;try rewrite HT2 in HOoBCApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: D :: nil) 4 2 3 HOoBCApDDpadbdmtmp HBDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HBApDDpadbdm4 : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoBApDDpadbdeq : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApDDpadbdmtmp : rk(Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBApDDpadbdeq HOoBApDDpadbdm4).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: D :: Dp :: ad :: bd :: nil) (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: B :: Ap :: D :: Dp :: ad :: bd :: nil) ((Oo :: D :: Dp :: nil) ++ (B :: Ap :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApDDpadbdmtmp;try rewrite HT2 in HOoBApDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (B :: Ap :: D :: Dp :: ad :: bd :: nil) (D :: Dp :: nil) 4 2 2 HOoBApDDpadbdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HBApDDpadbdM : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBApDDpadbdm : rk(B :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApbcDpadbd requis par la preuve de (?)OoBCApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDpadbd requis par la preuve de (?)OoBCApbcDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpadbd requis par la preuve de (?)OoABCApbcDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpadbd requis par la preuve de (?)OoBCApbcDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpadbd requis par la preuve de (?)OoBCApbcDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpadbdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadbdeq HOoABCApbcDpadbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadbdmtmp;try rewrite HT2 in HOoABCApbcDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpadbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpadbdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadbdeq HOoABCApbcDpadbdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadbdmtmp;try rewrite HT2 in HOoABCApbcDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpadbdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpadbd requis par la preuve de (?)OoBCApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpadbd requis par la preuve de (?)OoBCApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpadbd requis par la preuve de (?)OoABCApDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpadbd requis par la preuve de (?)OoBCApDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpadbdm3 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDpadbdeq HOoABCApDpadbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadbdmtmp;try rewrite HT2 in HOoABCApDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpadbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpadbdm4 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpadbdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpadbdeq HOoBCApbcDpadbdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpadbdmtmp;try rewrite HT2 in HOoBCApbcDpadbdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpadbdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadbd requis par la preuve de (?)ApDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Dp ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Dp ::   de rang : 3 et 3 *)
assert(HApDpadbdm2 : rk(Ap :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HOoBCDpeq : rk(Oo :: B :: C :: Dp :: nil) = 3) by (apply LOoBCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDpMtmp : rk(Oo :: B :: C :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCDpeq HOoBCDpM3).
	assert(HOoBCApDpadbdmtmp : rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApDpadbdeq HOoBCApDpadbdm4).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) (Oo :: B :: C :: Dp :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Dp :: Ap :: Dp :: ad :: bd :: nil) ((Oo :: B :: C :: Dp :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDpadbdmtmp;try rewrite HT2 in HOoBCApDpadbdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: ad :: bd :: nil) (Dp :: nil) 4 1 3 HOoBCApDpadbdmtmp HDpmtmp HOoBCDpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApDpadbdM3 : rk(Ap :: Dp :: ad :: bd :: nil) <= 3).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HbdMtmp : rk(bd :: nil) <= 1) by (solve_hyps_max Hbdeq HbdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: bd :: nil) ((Ap :: Dp :: ad :: nil) ++ (bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (bd :: nil) (nil) 2 1 0 HApDpadMtmp HbdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : B :: Ap :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : bd ::  de rang :  1 et 1 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HApDpadbdm3 : rk(Ap :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBApDDpadbdeq : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LBApDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApDDpadbdmtmp : rk(B :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HBApDDpadbdeq HBApDDpadbdm4).
	assert(Hbdmtmp : rk(bd :: nil) >= 1) by (solve_hyps_min Hbdeq Hbdm1).
	assert(Hincl : incl (bd :: nil) (list_inter (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: Ap :: D :: Dp :: ad :: bd :: nil) (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: Ap :: Dp :: ad :: bd :: nil) ((B :: D :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBApDDpadbdmtmp;try rewrite HT2 in HBApDDpadbdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (bd :: nil) 4 1 2 HBApDDpadbdmtmp Hbdmtmp HBDbdMtmp Hincl); apply HT.
}

assert(HApDpadbdM : rk(Ap :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadbdm : rk(Ap :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApDpadbdeq HApDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ab :: Dp :: ad :: bd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm2 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabDpadbdm4 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HABApDpeq : rk(A :: B :: Ap :: Dp :: nil) = 4) by (apply LABApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApDpmtmp : rk(A :: B :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HABApDpeq HABApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 4 4 HABApDpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApabDpadbd requis par la preuve de (?)ApabDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HApabDpadbdm2 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: nil) 3 1 2 HABApabDpadbdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : ab :: Dp ::  de rang :  2 et 2 	 A : A :: B :: ab :: Dp ::   de rang : 3 et 3 *)
assert(HApabDpadbdm3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabDpeq : rk(A :: B :: ab :: Dp :: nil) = 3) by (apply LABabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabDpMtmp : rk(A :: B :: ab :: Dp :: nil) <= 3) by (solve_hyps_max HABabDpeq HABabDpM3).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm4).
	assert(HabDpeq : rk(ab :: Dp :: nil) = 2) by (apply LabDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabDpmtmp : rk(ab :: Dp :: nil) >= 2) by (solve_hyps_min HabDpeq HabDpm2).
	assert(Hincl : incl (ab :: Dp :: nil) (list_inter (A :: B :: ab :: Dp :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: Dp :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Dp :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: Dp :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: Dp :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: Dp :: nil) 4 2 3 HABApabDpadbdmtmp HabDpmtmp HABabDpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApabDpadbdM3 : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3).
{
	assert(HApabDpbdeq : rk(Ap :: ab :: Dp :: bd :: nil) = 3) by (apply LApabDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDpbdMtmp : rk(Ap :: ab :: Dp :: bd :: nil) <= 3) by (solve_hyps_max HApabDpbdeq HApabDpbdM3).
	assert(HApDpadbdeq : rk(Ap :: Dp :: ad :: bd :: nil) = 3) by (apply LApDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpadbdMtmp : rk(Ap :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApDpadbdeq HApDpadbdM3).
	assert(HApDpbdeq : rk(Ap :: Dp :: bd :: nil) = 3) by (apply LApDpbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpbdmtmp : rk(Ap :: Dp :: bd :: nil) >= 3) by (solve_hyps_min HApDpbdeq HApDpbdm3).
	assert(Hincl : incl (Ap :: Dp :: bd :: nil) (list_inter (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ab :: Dp :: ad :: bd :: nil) (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ab :: Dp :: bd :: Ap :: Dp :: ad :: bd :: nil) ((Ap :: ab :: Dp :: bd :: nil) ++ (Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ab :: Dp :: bd :: nil) (Ap :: Dp :: ad :: bd :: nil) (Ap :: Dp :: bd :: nil) 3 3 3 HApabDpbdMtmp HApDpadbdMtmp HApDpbdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApabDpadbdM : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApabDpadbdm : rk(Ap :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HApabDpadbdeq HApabDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadbd *)
(* dans constructLemma(), requis par LAApabDpadbd *)
(* dans la couche 0 *)
Lemma LABApabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: Ap :: ab :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm2 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABApabDpadbdm4 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HABApDpeq : rk(A :: B :: Ap :: Dp :: nil) = 4) by (apply LABApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApDpmtmp : rk(A :: B :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HABApDpeq HABApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Dp :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 4 4 HABApDpmtmp Hcomp Hincl);apply HT.
}

assert(HABApabDpadbdM : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABApabDpadbdm : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApabDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: ab :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABApabDpadbd requis par la preuve de (?)ABApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm2 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABApabDpadbdm3 : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApabDpadbd requis par la preuve de (?)AApabDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApabDpadbdm2 : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HAApabDpadbdm3 : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: A :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: nil) ++ (A :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: ab :: nil) 3 2 2 HABApabDpadbdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: Ap :: ab :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HAApabDpadbdm4 : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABApabDpadbdeq : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) = 4) by (apply LABApabDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApabDpadbdmtmp : rk(A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HABApabDpadbdeq HABApabDpadbdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: B :: ab :: ad :: A :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABApabDpadbdmtmp;try rewrite HT2 in HABApabDpadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABApabDpadbdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HAApabDpadbdM : rk(A :: Ap :: ab :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApabDpadbdm : rk(A :: Ap :: ab :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HAApabDpadbdeq HAApabDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad :: bd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabadbd requis par la preuve de (?)ABabadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)ABabadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)OoABApabadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabadbd requis par la preuve de (?)OoABApabadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabadbd requis par la preuve de (?)ABabadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad :: bd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadbdm2 : rk(A :: B :: ab :: ad :: bd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadbdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) >= 3) by (solve_hyps_min HOoABApabadbdeq HOoABApabadbdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: bd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadbdmtmp;try rewrite HT2 in HOoABApabadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: nil) (A :: B :: nil) 3 2 3 HOoABApabadbdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabadbdm3 : rk(A :: B :: ab :: ad :: bd :: nil) >= 3).
{
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ad :: nil) (A :: B :: ab :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ad :: nil) (A :: B :: ab :: ad :: bd :: nil) 3 3 HABadmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abadbd requis par la preuve de (?)abadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: ad :: bd ::  de rang :  3 et 4 	 AiB : ab :: ad ::  de rang :  2 et 2 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(Habadbdm2 : rk(ab :: ad :: bd :: nil) >= 2).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABabadbdmtmp : rk(A :: B :: ab :: ad :: bd :: nil) >= 3) by (solve_hyps_min HABabadbdeq HABabadbdm3).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (ab :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: bd :: nil) (A :: B :: ab :: ad :: ab :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: ab :: ad :: bd :: nil) ((A :: B :: ab :: ad :: nil) ++ (ab :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadbdmtmp;try rewrite HT2 in HABabadbdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (ab :: ad :: bd :: nil) (ab :: ad :: nil) 3 2 3 HABabadbdmtmp Habadmtmp HABabadMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HabadbdM2 : rk(ab :: ad :: bd :: nil) <= 2).
{
	assert(HAabadbdeq : rk(A :: ab :: ad :: bd :: nil) = 3) by (apply LAabadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadbdMtmp : rk(A :: ab :: ad :: bd :: nil) <= 3) by (solve_hyps_max HAabadbdeq HAabadbdM3).
	assert(HApabDpadbdeq : rk(Ap :: ab :: Dp :: ad :: bd :: nil) = 3) by (apply LApabDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApabDpadbdMtmp : rk(Ap :: ab :: Dp :: ad :: bd :: nil) <= 3) by (solve_hyps_max HApabDpadbdeq HApabDpadbdM3).
	assert(HAApabDpadbdeq : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) = 4) by (apply LAApabDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApabDpadbdmtmp : rk(A :: Ap :: ab :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HAApabDpadbdeq HAApabDpadbdm4).
	assert(Hincl : incl (ab :: ad :: bd :: nil) (list_inter (A :: ab :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: ab :: Dp :: ad :: bd :: nil) (A :: ab :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ab :: ad :: bd :: Ap :: ab :: Dp :: ad :: bd :: nil) ((A :: ab :: ad :: bd :: nil) ++ (Ap :: ab :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApabDpadbdmtmp;try rewrite HT2 in HAApabDpadbdmtmp.
	assert(HT := rule_3 (A :: ab :: ad :: bd :: nil) (Ap :: ab :: Dp :: ad :: bd :: nil) (ab :: ad :: bd :: nil) 3 3 4 HAabadbdMtmp HApabDpadbdMtmp HAApabDpadbdmtmp Hincl);apply HT.
}


assert(HabadbdM : rk(ab :: ad :: bd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habadbdeq HabadbdM3).
assert(Habadbdm : rk(ab :: ad :: bd ::  nil) >= 1) by (solve_hyps_min Habadbdeq Habadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApDpadbd *)
(* dans constructLemma(), requis par LOoBCApbcDpadbd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpadbd requis par la preuve de (?)OoABCApbcDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDpadbdM : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDpadbdm : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDpadbdeq HOoABCApbcDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpadbd requis par la preuve de (?)OoBCApbcDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpadbd requis par la preuve de (?)OoBCApbcDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpadbdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpadbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABCApbcDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadbdeq HOoABCApbcDpadbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadbdmtmp;try rewrite HT2 in HOoABCApbcDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpadbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpadbdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpadbdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABCApbcDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadbdeq HOoABCApbcDpadbdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadbdmtmp;try rewrite HT2 in HOoABCApbcDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpadbdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDpadbdM : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDpadbdm : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDpadbdeq HOoBCApbcDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpadbd requis par la preuve de (?)OoBCApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpadbd requis par la preuve de (?)OoBCApDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpadbd requis par la preuve de (?)OoABCApDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpadbd requis par la preuve de (?)OoBCApDpadbd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpadbdm3 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpadbdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABCApDpadbdeq HOoABCApDpadbdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadbdmtmp;try rewrite HT2 in HOoABCApDpadbdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpadbdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpadbdm4 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpadbdeq : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) = 4) by (apply LOoBCApbcDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDpadbdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpadbdeq HOoBCApbcDpadbdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: bd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpadbdmtmp;try rewrite HT2 in HOoBCApbcDpadbdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: bd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpadbdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDpadbdM : rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDpadbdm : rk(Oo :: B :: C :: Ap :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBCApDpadbdeq HOoBCApDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpadbd requis par la preuve de (?)OoABCApDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDpadbdM : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpadbdm : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDpadbdeq HOoABCApDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadbd requis par la preuve de (?)OoABCApDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadbdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpadbdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpadbdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpadbdeq HOoABCApDDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBApacDDpadbd *)
(* dans la couche 0 *)
Lemma LOoABApacDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacDDpadbd requis par la preuve de (?)OoABApacDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacDDpadbd requis par la preuve de (?)OoABApacDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacDDpadbd requis par la preuve de (?)OoABApacDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpadbdm2 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacDDpadbdm3 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApacDDpadbdm4 : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApacDDpadbdM : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApacDDpadbdm : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoABApacDDpadbdeq HOoABApacDDpadbdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApacDDpadbd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApacDDpadbd requis par la preuve de (?)OoBApacDDpadbd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApacDDpadbd requis par la preuve de (?)OoBApacDDpadbd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApacDDpadbd requis par la preuve de (?)OoBApacDDpadbd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpadbdm2 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApacDDpadbdm3 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 3).
{
	assert(HOoBaceq : rk(Oo :: B :: ac :: nil) = 3) by (apply LOoBac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBacmtmp : rk(Oo :: B :: ac :: nil) >= 3) by (solve_hyps_min HOoBaceq HOoBacm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) 3 3 HOoBacmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoBApacDDpadbdm4 : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoABApacDDpadbdeq : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) = 4) by (apply LOoABApacDDpadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApacDDpadbdmtmp : rk(Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) >= 4) by (solve_hyps_min HOoABApacDDpadbdeq HOoABApacDDpadbdm4).
	assert(HOoApaceq : rk(Oo :: Ap :: ac :: nil) = 3) by (apply LOoApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApacmtmp : rk(Oo :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoApaceq HOoApacm3).
	assert(Hincl : incl (Oo :: Ap :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacDDpadbdmtmp;try rewrite HT2 in HOoABApacDDpadbdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd :: nil) (Oo :: Ap :: ac :: nil) 4 3 3 HOoABApacDDpadbdmtmp HOoApacmtmp HOoAApacMtmp Hincl); apply HT.
}

assert(HOoBApacDDpadbdM : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApacDDpadbdm : rk(Oo :: B :: Ap :: ac :: D :: Dp :: ad :: bd ::  nil) >= 1) by (solve_hyps_min HOoBApacDDpadbdeq HOoBApacDDpadbdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LDcd *)
(* dans la couche 0 *)
Lemma LCpDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Cp :: D :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CpDDpcd requis par la preuve de (?)CpDDpcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HCpDDpcdM3 : rk(Cp :: D :: Dp :: cd :: nil) <= 3).
{
	assert(HDMtmp : rk(D :: nil) <= 1) by (solve_hyps_max HDeq HDM1).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (D :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: Cp :: Dp :: cd :: nil) ((D :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (D :: nil) (Cp :: Dp :: cd :: nil) (nil) 1 2 0 HDMtmp HCpDpcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HCpDDpcdm2 : rk(Cp :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HCpDeq : rk(Cp :: D :: nil) = 2) by (apply LCpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDmtmp : rk(Cp :: D :: nil) >= 2) by (solve_hyps_min HCpDeq HCpDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Cp :: D :: nil) (Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Cp :: D :: nil) (Cp :: D :: Dp :: cd :: nil) 2 2 HCpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HCpDDpcdm3 : rk(Cp :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HCpDDpmtmp : rk(Cp :: D :: Dp :: nil) >= 3) by (solve_hyps_min HCpDDpeq HCpDDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Cp :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Cp :: D :: Dp :: nil) (Cp :: D :: Dp :: cd :: nil) 3 3 HCpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HCpDDpcdM : rk(Cp :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCpDDpcdm : rk(Cp :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(D :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 2 pour Dcd requis par la preuve de (?)Dcd pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 -2 et -4*)
assert(HDcdm2 : rk(D :: cd :: nil) >= 2).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpDDpcdeq : rk(Cp :: D :: Dp :: cd :: nil) = 3) by (apply LCpDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDDpcdmtmp : rk(Cp :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HCpDDpcdeq HCpDDpcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (D :: cd :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Cp :: D :: Dp :: cd :: nil) (D :: cd :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (D :: cd :: Cp :: Dp :: cd :: nil) ((D :: cd :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCpDDpcdmtmp;try rewrite HT2 in HCpDDpcdmtmp.
	assert(HT := rule_2 (D :: cd :: nil) (Cp :: Dp :: cd :: nil) (cd :: nil) 3 1 2 HCpDDpcdmtmp Hcdmtmp HCpDpcdMtmp Hincl);apply HT.
}

assert(HDcdM : rk(D :: cd ::  nil) <= 2) (* dim : 3 *) by (solve_hyps_max HDcdeq HDcdM2).
assert(HDcdm : rk(D :: cd ::  nil) >= 1) by (solve_hyps_min HDcdeq HDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LADcd *)
(* dans la couche 0 *)
Lemma LACDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACDcd requis par la preuve de (?)ACDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HACDcdM3 : rk(A :: C :: D :: cd :: nil) <= 3).
{
	assert(HAMtmp : rk(A :: nil) <= 1) by (solve_hyps_max HAeq HAM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: D :: cd :: nil) ((A :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HAMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDcdm2 : rk(A :: C :: D :: cd :: nil) >= 2).
{
	assert(HACeq : rk(A :: C :: nil) = 2) by (apply LAC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACmtmp : rk(A :: C :: nil) >= 2) by (solve_hyps_min HACeq HACm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: C :: nil) (A :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: nil) (A :: C :: D :: cd :: nil) 2 2 HACmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACDcdm3 : rk(A :: C :: D :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACDcdM : rk(A :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACDcdm : rk(A :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACDcdeq HACDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LADcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ADcd requis par la preuve de (?)ADcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADcdm2 : rk(A :: D :: cd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: cd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HADcdm3 : rk(A :: D :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HACDcdeq : rk(A :: C :: D :: cd :: nil) = 3) by (apply LACDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDcdmtmp : rk(A :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HACDcdeq HACDcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (A :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: D :: cd :: nil) (A :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: cd :: C :: D :: cd :: nil) ((A :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACDcdmtmp;try rewrite HT2 in HACDcdmtmp.
	assert(HT := rule_2 (A :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HACDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}

assert(HADcdM : rk(A :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HADcdeq HADcdM3).
assert(HADcdm : rk(A :: D :: cd ::  nil) >= 1) by (solve_hyps_min HADcdeq HADcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBDcd *)
(* dans la couche 0 *)
Lemma LBCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCDcd requis par la preuve de (?)BCDcd pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HBCDcdM3 : rk(B :: C :: D :: cd :: nil) <= 3).
{
	assert(HBMtmp : rk(B :: nil) <= 1) by (solve_hyps_max HBeq HBM1).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: D :: cd :: nil) ((B :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: nil) (C :: D :: cd :: nil) (nil) 1 2 0 HBMtmp HCDcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDcdm2 : rk(B :: C :: D :: cd :: nil) >= 2).
{
	assert(HBCeq : rk(B :: C :: nil) = 2) by (apply LBC with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCmtmp : rk(B :: C :: nil) >= 2) by (solve_hyps_min HBCeq HBCm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: C :: nil) (B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: nil) (B :: C :: D :: cd :: nil) 2 2 HBCmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCDcdm3 : rk(B :: C :: D :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCDcdM : rk(B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCDcdm : rk(B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCDcdeq HBCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour BDcd requis par la preuve de (?)BDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDcdm2 : rk(B :: D :: cd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et -4*)
assert(HBDcdm3 : rk(B :: D :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HBCDcdeq : rk(B :: C :: D :: cd :: nil) = 3) by (apply LBCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDcdmtmp : rk(B :: C :: D :: cd :: nil) >= 3) by (solve_hyps_min HBCDcdeq HBCDcdm3).
	assert(HDcdeq : rk(D :: cd :: nil) = 2) by (apply LDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDcdmtmp : rk(D :: cd :: nil) >= 2) by (solve_hyps_min HDcdeq HDcdm2).
	assert(Hincl : incl (D :: cd :: nil) (list_inter (B :: D :: cd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: D :: cd :: nil) (B :: D :: cd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: cd :: C :: D :: cd :: nil) ((B :: D :: cd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCDcdmtmp;try rewrite HT2 in HBCDcdmtmp.
	assert(HT := rule_2 (B :: D :: cd :: nil) (C :: D :: cd :: nil) (D :: cd :: nil) 3 2 2 HBCDcdmtmp HDcdmtmp HCDcdMtmp Hincl);apply HT.
}

assert(HBDcdM : rk(B :: D :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HBDcdeq HBDcdM3).
assert(HBDcdm : rk(B :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBDcdeq HBDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBDcd *)
(* dans la couche 0 *)
Lemma LOoBCDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCDcd requis par la preuve de (?)OoBCDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoBCDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCDcd requis par la preuve de (?)OoBCDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCDcd requis par la preuve de (?)OoBCDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDcdm2 : rk(Oo :: B :: C :: D :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (A :: Ap :: Oo :: B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: D :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: D :: cd :: nil) (nil) 4 0 2 HOoABCApDcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCDcdm3 : rk(Oo :: B :: C :: D :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: D :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApDcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et 4*)
assert(HOoBCDcdM3 : rk(Oo :: B :: C :: D :: cd :: nil) <= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: D :: cd :: nil) (Oo :: B :: C :: D :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: C :: D :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: B :: C :: D :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HOoBCDMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HOoBCDcdM : rk(Oo :: B :: C :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCDcdm : rk(Oo :: B :: C :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCDcdeq HOoBCDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBDcd requis par la preuve de (?)OoBDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBDcd requis par la preuve de (?)OoBDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoBDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBDcd requis par la preuve de (?)OoBDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: C :: Ap ::   de rang : 3 et 3 *)
assert(HOoBDcdm2 : rk(Oo :: B :: D :: cd :: nil) >= 2).
{
	assert(HOoACApeq : rk(Oo :: A :: C :: Ap :: nil) = 3) by (apply LOoACAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApMtmp : rk(Oo :: A :: C :: Ap :: nil) <= 3) by (solve_hyps_max HOoACApeq HOoACApM3).
	assert(HOoABCApDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) (Oo :: A :: C :: Ap :: Oo :: B :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: C :: Ap :: Oo :: B :: D :: cd :: nil) ((Oo :: A :: C :: Ap :: nil) ++ (Oo :: B :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDcdmtmp;try rewrite HT2 in HOoABCApDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: C :: Ap :: nil) (Oo :: B :: D :: cd :: nil) (Oo :: nil) 4 1 3 HOoABCApDcdmtmp HOomtmp HOoACApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBDcdm3 : rk(Oo :: B :: D :: cd :: nil) >= 3).
{
	assert(HOoBDeq : rk(Oo :: B :: D :: nil) = 3) by (apply LOoBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDmtmp : rk(Oo :: B :: D :: nil) >= 3) by (solve_hyps_min HOoBDeq HOoBDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: nil) (Oo :: B :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: B :: D :: nil) (Oo :: B :: D :: cd :: nil) 3 3 HOoBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBDcdM3 : rk(Oo :: B :: D :: cd :: nil) <= 3).
{
	assert(HOoBCDcdeq : rk(Oo :: B :: C :: D :: cd :: nil) = 3) by (apply LOoBCDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDcdMtmp : rk(Oo :: B :: C :: D :: cd :: nil) <= 3) by (solve_hyps_max HOoBCDcdeq HOoBCDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Oo :: B :: D :: cd :: nil) (Oo :: B :: C :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Oo :: B :: D :: cd :: nil) (Oo :: B :: C :: D :: cd :: nil) 3 3 HOoBCDcdMtmp Hcomp Hincl);apply HT.
}

assert(HOoBDcdM : rk(Oo :: B :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBDcdm : rk(Oo :: B :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoBDcdeq HOoBDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDcd requis par la preuve de (?)OoABCApDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDcdM : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDcdm : rk(Oo :: A :: B :: C :: Ap :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDcdeq HOoABCApDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAacDcd *)
(* dans la couche 0 *)
Lemma LACacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDcdeq HABCApacDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDcdmtmp;try rewrite HT2 in HABCApacDcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (nil) 4 0 2 HABCApacDcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACacDcdm3 : rk(A :: C :: ac :: D :: cd :: nil) >= 3).
{
	assert(HACDeq : rk(A :: C :: D :: nil) = 3) by (apply LACD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACDmtmp : rk(A :: C :: D :: nil) >= 3) by (solve_hyps_min HACDeq HACDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: D :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACDmtmp Hcomp Hincl);apply HT.
}

assert(HACacDcdM : rk(A :: C :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACacDcdm : rk(A :: C :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HACacDcdeq HACacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadcdmtmp;try rewrite HT2 in HABCApacDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApacDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadcdm2 : rk(A :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDadcdm3 : rk(A :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HAacadeq : rk(A :: ac :: ad :: nil) = 3) by (apply LAacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacadmtmp : rk(A :: ac :: ad :: nil) >= 3) by (solve_hyps_min HAacadeq HAacadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: ad :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ac :: ad :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HAacadmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ACacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDcd requis par la preuve de (?)ACacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDcdm2 : rk(A :: C :: ac :: D :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDcdeq HABCApacDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDcdmtmp;try rewrite HT2 in HABCApacDcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: cd :: nil) (nil) 4 0 2 HABCApacDcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HACacDcdM3 : rk(A :: C :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (A :: C :: ac :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: C :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: C :: ac :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HACacMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDcd requis par la preuve de (?)AacDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: cd ::  de rang :  2 et 3 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDcdm2 : rk(A :: ac :: D :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDcdmtmp : rk(A :: C :: ac :: D :: cd :: nil) >= 2) by (solve_hyps_min HACacDcdeq HACacDcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDcdmtmp;try rewrite HT2 in HACacDcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: ac :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: D ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HAacDcdm3 : rk(A :: ac :: D :: cd :: nil) >= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HAacDadcdmtmp : rk(A :: ac :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HAacDadcdeq HAacDadcdm3).
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hincl : incl (A :: D :: nil) (list_inter (A :: D :: ad :: nil) (A :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: cd :: nil) (A :: D :: ad :: A :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: ac :: D :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAacDadcdmtmp;try rewrite HT2 in HAacDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: ac :: D :: cd :: nil) (A :: D :: nil) 3 2 2 HAacDadcdmtmp HADmtmp HADadMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDcdM3 : rk(A :: ac :: D :: cd :: nil) <= 3).
{
	assert(HACacDcdeq : rk(A :: C :: ac :: D :: cd :: nil) = 3) by (apply LACacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDcdMtmp : rk(A :: C :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HACacDcdeq HACacDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ac :: D :: cd :: nil) (A :: C :: ac :: D :: cd :: nil) 3 3 HACacDcdMtmp Hcomp Hincl);apply HT.
}

assert(HAacDcdM : rk(A :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDcdm : rk(A :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HAacDcdeq HAacDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDcd requis par la preuve de (?)OoABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDcd requis par la preuve de (?)ABCApacDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) = 4) by (apply LOoABCApacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDcdeq HOoABCApacDcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDcdmtmp;try rewrite HT2 in HOoABCApacDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDcdM : rk(A :: B :: C :: Ap :: ac :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDcdm : rk(A :: B :: C :: Ap :: ac :: D :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDcdeq HABCApacDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LBbcDcd *)
(* dans la couche 0 *)
Lemma LBCbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDcdm3 : rk(B :: C :: bc :: D :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

assert(HBCbcDcdM : rk(B :: C :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDcdm : rk(B :: C :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BCbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDcd requis par la preuve de (?)BCbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDcdm2 : rk(B :: C :: bc :: D :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDcdmtmp;try rewrite HT2 in HOoABCApbcDcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: cd :: nil) (nil) 4 0 2 HOoABCApbcDcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HBCbcDcdM3 : rk(B :: C :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCmtmp : rk(C :: nil) >= 1) by (solve_hyps_min HCeq HCm1).
	assert(Hincl : incl (C :: nil) (list_inter (B :: C :: bc :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: C :: bc :: nil) (C :: D :: cd :: nil) (C :: nil) 2 2 1 HBCbcMtmp HCDcdMtmp HCmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDcd requis par la preuve de (?)BbcDcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: cd ::  de rang :  2 et 3 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDcdm2 : rk(B :: bc :: D :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDcdmtmp : rk(B :: C :: bc :: D :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDcdeq HBCbcDcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDcdmtmp;try rewrite HT2 in HBCbcDcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdm3 : rk(B :: bc :: D :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDcdM3 : rk(B :: bc :: D :: cd :: nil) <= 3).
{
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: bc :: D :: cd :: nil) (B :: C :: bc :: D :: cd :: nil) 3 3 HBCbcDcdMtmp Hcomp Hincl);apply HT.
}

assert(HBbcDcdM : rk(B :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDcdm : rk(B :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDcdeq HBbcDcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDcd requis par la preuve de (?)OoABCApbcDcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDcdeq HOoABCApbcDcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApDpcd *)
(* dans constructLemma(), requis par LCApDDpcd *)
(* dans constructLemma(), requis par LOoCApDDpcd *)
(* dans constructLemma(), requis par LOoBCApDDpcd *)
(* dans constructLemma(), requis par LOoBCApbcDDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDDpcd requis par la preuve de (?)OoABCApbcDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDDpcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDDpcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDDpcdeq HOoABCApbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDDpcd requis par la preuve de (?)OoBCApbcDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDDpcd requis par la preuve de (?)OoBCApbcDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDDpcdm3 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpcdeq HOoABCApbcDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpcdmtmp;try rewrite HT2 in HOoABCApbcDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDDpcdm4 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpcdeq HOoABCApbcDDpcdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpcdmtmp;try rewrite HT2 in HOoABCApbcDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDDpcdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDDpcdM : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDDpcdm : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDDpcdeq HOoBCApbcDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpcd requis par la preuve de (?)OoBCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoBCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpcd requis par la preuve de (?)OoBCApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpcdm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDDpcdm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDDpcdeq : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCApbcDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDDpcdmtmp : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDDpcdeq HOoBCApbcDDpcdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: D :: Dp :: cd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDDpcdmtmp;try rewrite HT2 in HOoBCApbcDDpcdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDDpcdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDDpcdM : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDDpcdm : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApDDpcdeq HOoBCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpabDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabDDpcd requis par la preuve de (?)OoACApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDDpcd requis par la preuve de (?)OoABCApBpabDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDDpcd requis par la preuve de (?)OoACApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDDpcd requis par la preuve de (?)OoACApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDDpcd requis par la preuve de (?)OoACApBpabDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDDpcdm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDDpcdm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDDpcdm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDDpcdmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDDpcd requis par la preuve de (?)OoBCApBpabDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDDpcdm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDDpcdm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDDpcdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDDpcdeq HOoBCApBpabDDpcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDDpcdmtmp;try rewrite HT2 in HOoBCApBpabDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpcdm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDDpcdmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpcdm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDDpcdmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApBpabDDpcdeq HOoACApBpabDDpcdm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDDpcdmtmp;try rewrite HT2 in HOoACApBpabDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDDpcdmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoBCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpcd requis par la preuve de (?)OoBCApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpcdm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApDDpcd requis par la preuve de (?)OoCApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApDDpcdm2 : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApDDpcdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCApDDpcdeq HOoBCApDDpcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpcdmtmp;try rewrite HT2 in HOoBCApDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 3 1 2 HOoBCApDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : C :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApDDpcdm3 : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HCApBpabeq : rk(C :: Ap :: Bp :: ab :: nil) = 3) by (apply LCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApBpabMtmp : rk(C :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HCApBpabeq HCApBpabM3).
	assert(HOoCApBpabDDpcdmtmp : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApBpabDDpcdeq HOoCApBpabDDpcdm4).
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (C :: Ap :: Bp :: ab :: Oo :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: Oo :: C :: Ap :: D :: Dp :: cd :: nil) ((C :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpabDDpcdmtmp;try rewrite HT2 in HOoCApBpabDDpcdmtmp.
	assert(HT := rule_4 (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (C :: Ap :: nil) 4 2 3 HOoCApBpabDDpcdmtmp HCApmtmp HCApBpabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HOoCApDDpcdm4 : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpcdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpcdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpcdeq HOoBCApDDpcdm4).
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hincl : incl (Oo :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: B :: C :: D :: Oo :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpcdmtmp;try rewrite HT2 in HOoBCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: C :: D :: nil) 4 3 3 HOoBCApDDpcdmtmp HOoCDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HOoCApDDpcdM : rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApDDpcdm : rk(Oo :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApDDpcdeq HOoCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)BCApDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApDDpcd requis par la preuve de (?)BCApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApDDpcdm3 : rk(B :: C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpcdmtmp;try rewrite HT2 in HOoABCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpcd requis par la preuve de (?)CApDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApDDpcdm2 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApDDpcdmtmp : rk(B :: C :: Ap :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HBCApDDpcdeq HBCApDDpcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: D :: Dp :: cd :: nil) (B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApDDpcdmtmp;try rewrite HT2 in HBCApDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (Ap :: nil) 3 1 2 HBCApDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : C :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HCApDDpcdm3 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpcdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoBCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpcdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpcdeq HOoBCApDDpcdm4).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: B :: C :: D :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpcdmtmp;try rewrite HT2 in HOoBCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (C :: D :: nil) 4 2 3 HOoBCApDDpcdmtmp HCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApDDpcdm4 : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApDDpcdeq : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LOoCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApDDpcdmtmp : rk(Oo :: C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoCApDDpcdeq HOoCApDDpcdm4).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: D :: Dp :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApDDpcdmtmp;try rewrite HT2 in HOoCApDDpcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApDDpcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCApDDpcdM : rk(C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpcdm : rk(C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDpcd requis par la preuve de (?)ApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApbcDpcd requis par la preuve de (?)OoBCApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDpcd requis par la preuve de (?)OoBCApbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpcd requis par la preuve de (?)OoABCApbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpcd requis par la preuve de (?)OoBCApbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpcd requis par la preuve de (?)OoBCApbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpcdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpcdeq HOoABCApbcDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpcdmtmp;try rewrite HT2 in HOoABCApbcDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpcdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpcdeq HOoABCApbcDpcdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpcdmtmp;try rewrite HT2 in HOoABCApbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpcdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpcd requis par la preuve de (?)OoBCApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpcd requis par la preuve de (?)OoBCApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpcd requis par la preuve de (?)OoABCApDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpcd requis par la preuve de (?)OoBCApDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpcdm3 : rk(Oo :: B :: C :: Ap :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDpcdeq HOoABCApDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpcdmtmp;try rewrite HT2 in HOoABCApDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpcdm4 : rk(Oo :: B :: C :: Ap :: Dp :: cd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpcdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpcdeq HOoBCApbcDpcdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: cd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpcdmtmp;try rewrite HT2 in HOoBCApbcDpcdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpcdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour ApDpcd requis par la preuve de (?)ApDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Dp ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Dp ::   de rang : 3 et 3 *)
assert(HApDpcdm2 : rk(Ap :: Dp :: cd :: nil) >= 2).
{
	assert(HOoBCDpeq : rk(Oo :: B :: C :: Dp :: nil) = 3) by (apply LOoBCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDpMtmp : rk(Oo :: B :: C :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCDpeq HOoBCDpM3).
	assert(HOoBCApDpcdmtmp : rk(Oo :: B :: C :: Ap :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApDpcdeq HOoBCApDpcdm4).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Dp :: cd :: nil) (Oo :: B :: C :: Dp :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Dp :: Ap :: Dp :: cd :: nil) ((Oo :: B :: C :: Dp :: nil) ++ (Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDpcdmtmp;try rewrite HT2 in HOoBCApDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: cd :: nil) (Dp :: nil) 4 1 3 HOoBCApDpcdmtmp HDpmtmp HOoBCDpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpcdm3 : rk(Ap :: Dp :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApDDpcdeq : rk(C :: Ap :: D :: Dp :: cd :: nil) = 4) by (apply LCApDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApDDpcdmtmp : rk(C :: Ap :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpcdeq HCApDDpcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpcdmtmp;try rewrite HT2 in HCApDDpcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HApDpcdM : rk(Ap :: Dp :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HApDpcdeq HApDpcdM3).
assert(HApDpcdm : rk(Ap :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApDpcdeq HApDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApDpcd *)
(* dans constructLemma(), requis par LOoBCApbcDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpcd requis par la preuve de (?)OoABCApbcDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDpcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDpcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDpcdeq HOoABCApbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpcd requis par la preuve de (?)OoBCApbcDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpcd requis par la preuve de (?)OoBCApbcDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpcdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) = 4) by (apply LOoABCApbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpcdeq HOoABCApbcDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpcdmtmp;try rewrite HT2 in HOoABCApbcDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpcdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) = 4) by (apply LOoABCApbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpcdeq HOoABCApbcDpcdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpcdmtmp;try rewrite HT2 in HOoABCApbcDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpcdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDpcdM : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDpcdm : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDpcdeq HOoBCApbcDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpcd requis par la preuve de (?)OoBCApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpcd requis par la preuve de (?)OoBCApDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpcd requis par la preuve de (?)OoABCApDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpcd requis par la preuve de (?)OoBCApDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpcdm3 : rk(Oo :: B :: C :: Ap :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDpcdeq HOoABCApDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpcdmtmp;try rewrite HT2 in HOoABCApDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpcdm4 : rk(Oo :: B :: C :: Ap :: Dp :: cd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpcdeq : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) = 4) by (apply LOoBCApbcDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDpcdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpcdeq HOoBCApbcDpcdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: cd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: cd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpcdmtmp;try rewrite HT2 in HOoBCApbcDpcdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: cd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpcdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDpcdM : rk(Oo :: B :: C :: Ap :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDpcdm : rk(Oo :: B :: C :: Ap :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApDpcdeq HOoBCApDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpcd requis par la preuve de (?)OoABCApDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDpcdM : rk(Oo :: A :: B :: C :: Ap :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpcdm : rk(Oo :: A :: B :: C :: Ap :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDpcdeq HOoABCApDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LApacDpcd *)
(* dans constructLemma(), requis par LApCpacDpcd *)
(* dans constructLemma(), requis par LOoBApCpacDpcd *)
(* dans la couche 0 *)
Lemma LOoABApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApCpacDpcd requis par la preuve de (?)OoABApCpacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApCpacDpcd requis par la preuve de (?)OoABApCpacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApCpacDpcd requis par la preuve de (?)OoABApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpacDpcdm2 : rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApCpacDpcdm3 : rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABApCpacDpcdm4 : rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HABApCpeq : rk(A :: B :: Ap :: Cp :: nil) = 4) by (apply LABApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApCpmtmp : rk(A :: B :: Ap :: Cp :: nil) >= 4) by (solve_hyps_min HABApCpeq HABApCpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: Cp :: nil) (Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) 4 4 HABApCpmtmp Hcomp Hincl);apply HT.
}

assert(HOoABApCpacDpcdM : rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABApCpacDpcdm : rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABApCpacDpcdeq HOoABApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBApCpacDpcd requis par la preuve de (?)OoBApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBApCpacDpcd requis par la preuve de (?)OoBApCpacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBApCpacDpcd requis par la preuve de (?)OoBApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpacDpcdm2 : rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApmtmp : rk(B :: Ap :: nil) >= 2) by (solve_hyps_min HBApeq HBApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: nil) (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) 2 2 HBApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoBApCpacDpcdm3 : rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HBApCpeq : rk(B :: Ap :: Cp :: nil) = 3) by (apply LBApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApCpmtmp : rk(B :: Ap :: Cp :: nil) >= 3) by (solve_hyps_min HBApCpeq HBApCpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: Ap :: Cp :: nil) (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) 3 3 HBApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: ac ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: ac ::   de rang : 3 et 3 *)
assert(HOoBApCpacDpcdm4 : rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApaceq : rk(Oo :: A :: Ap :: ac :: nil) = 3) by (apply LOoAApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApacMtmp : rk(Oo :: A :: Ap :: ac :: nil) <= 3) by (solve_hyps_max HOoAApaceq HOoAApacM3).
	assert(HOoABApCpacDpcdeq : rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) = 4) by (apply LOoABApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApCpacDpcdmtmp : rk(Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABApCpacDpcdeq HOoABApCpacDpcdm4).
	assert(HOoApaceq : rk(Oo :: Ap :: ac :: nil) = 3) by (apply LOoApac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApacmtmp : rk(Oo :: Ap :: ac :: nil) >= 3) by (solve_hyps_min HOoApaceq HOoApacm3).
	assert(Hincl : incl (Oo :: Ap :: ac :: nil) (list_inter (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: ac :: Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: ac :: nil) ++ (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApCpacDpcdmtmp;try rewrite HT2 in HOoABApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: ac :: nil) (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: Ap :: ac :: nil) 4 3 3 HOoABApCpacDpcdmtmp HOoApacmtmp HOoAApacMtmp Hincl); apply HT.
}

assert(HOoBApCpacDpcdM : rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBApCpacDpcdm : rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoBApCpacDpcdeq HOoBApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApCpacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApCpacDpcd requis par la preuve de (?)ApCpacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApCpacDpcdm2 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HApCpeq : rk(Ap :: Cp :: nil) = 2) by (apply LApCp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpmtmp : rk(Ap :: Cp :: nil) >= 2) by (solve_hyps_min HApCpeq HApCpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (Ap :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Ap :: Cp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) 2 2 HApCpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -4 et -2*)
assert(HApCpacDpcdM3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3).
{
	assert(HApCpacMtmp : rk(Ap :: Cp :: ac :: nil) <= 2) by (solve_hyps_max HApCpaceq HApCpacM2).
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HCpmtmp : rk(Cp :: nil) >= 1) by (solve_hyps_min HCpeq HCpm1).
	assert(Hincl : incl (Cp :: nil) (list_inter (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Cp :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Cp :: ac :: Cp :: Dp :: cd :: nil) ((Ap :: Cp :: ac :: nil) ++ (Cp :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Cp :: ac :: nil) (Cp :: Dp :: cd :: nil) (Cp :: nil) 2 2 1 HApCpacMtmp HCpDpcdMtmp HCpmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: Ap :: Cp :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Cp :: Dp ::  de rang :  2 et 2 	 A : Oo :: B :: Cp :: Dp ::   de rang : 3 et 3 *)
assert(HApCpacDpcdm3 : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HOoBCpDpeq : rk(Oo :: B :: Cp :: Dp :: nil) = 3) by (apply LOoBCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCpDpMtmp : rk(Oo :: B :: Cp :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCpDpeq HOoBCpDpM3).
	assert(HOoBApCpacDpcdeq : rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) = 4) by (apply LOoBApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBApCpacDpcdmtmp : rk(Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoBApCpacDpcdeq HOoBApCpacDpcdm4).
	assert(HCpDpeq : rk(Cp :: Dp :: nil) = 2) by (apply LCpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCpDpmtmp : rk(Cp :: Dp :: nil) >= 2) by (solve_hyps_min HCpDpeq HCpDpm2).
	assert(Hincl : incl (Cp :: Dp :: nil) (list_inter (Oo :: B :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: Ap :: Cp :: ac :: Dp :: cd :: nil) (Oo :: B :: Cp :: Dp :: Ap :: Cp :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: Cp :: Dp :: Ap :: Cp :: ac :: Dp :: cd :: nil) ((Oo :: B :: Cp :: Dp :: nil) ++ (Ap :: Cp :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBApCpacDpcdmtmp;try rewrite HT2 in HOoBApCpacDpcdmtmp.
	assert(HT := rule_4 (Oo :: B :: Cp :: Dp :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) (Cp :: Dp :: nil) 4 2 3 HOoBApCpacDpcdmtmp HCpDpmtmp HOoBCpDpMtmp Hincl); apply HT.
}

assert(HApCpacDpcdM : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApCpacDpcdm : rk(Ap :: Cp :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApCpacDpcdeq HApCpacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpcdmtmp;try rewrite HT2 in HOoABCApacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpcdm2 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpcdm3 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpcdeq HABCApacDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpcdmtmp;try rewrite HT2 in HABCApacDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpcdm4 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HACApDpeq : rk(A :: C :: Ap :: Dp :: nil) = 4) by (apply LACApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApDpmtmp : rk(A :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HACApDpeq HACApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HACApDpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpcd requis par la preuve de (?)ApacDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpcdm2 : rk(Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpcdeq HACApacDpcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpcdmtmp;try rewrite HT2 in HACApacDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : ac :: Dp ::  de rang :  2 et 2 	 A : A :: C :: ac :: Dp ::   de rang : 3 et 3 *)
assert(HApacDpcdm3 : rk(Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HACacDpeq : rk(A :: C :: ac :: Dp :: nil) = 3) by (apply LACacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDpMtmp : rk(A :: C :: ac :: Dp :: nil) <= 3) by (solve_hyps_max HACacDpeq HACacDpM3).
	assert(HACApacDpcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HACApacDpcdeq HACApacDpcdm4).
	assert(HacDpeq : rk(ac :: Dp :: nil) = 2) by (apply LacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HacDpmtmp : rk(ac :: Dp :: nil) >= 2) by (solve_hyps_min HacDpeq HacDpm2).
	assert(Hincl : incl (ac :: Dp :: nil) (list_inter (A :: C :: ac :: Dp :: nil) (Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: C :: ac :: Dp :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Dp :: Ap :: ac :: Dp :: cd :: nil) ((A :: C :: ac :: Dp :: nil) ++ (Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpcdmtmp;try rewrite HT2 in HACApacDpcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: Dp :: nil) (Ap :: ac :: Dp :: cd :: nil) (ac :: Dp :: nil) 4 2 3 HACApacDpcdmtmp HacDpmtmp HACacDpMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HApacDpcdM3 : rk(Ap :: ac :: Dp :: cd :: nil) <= 3).
{
	assert(HApCpacDpcdeq : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) = 3) by (apply LApCpacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApCpacDpcdMtmp : rk(Ap :: Cp :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApCpacDpcdeq HApCpacDpcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Cp :: ac :: Dp :: cd :: nil) 3 3 HApCpacDpcdMtmp Hcomp Hincl);apply HT.
}

assert(HApacDpcdM : rk(Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpcdm : rk(Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpcdeq HApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpcdmtmp;try rewrite HT2 in HOoABCApacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpcd requis par la preuve de (?)ACApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpcdm2 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpcdm3 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpcdeq HABCApacDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpcdmtmp;try rewrite HT2 in HABCApacDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpcdm4 : rk(A :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HACApDpeq : rk(A :: C :: Ap :: Dp :: nil) = 4) by (apply LACApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApDpmtmp : rk(A :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HACApDpeq HACApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HACApDpmtmp Hcomp Hincl);apply HT.
}

assert(HACApacDpcdM : rk(A :: C :: Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacDpcdm : rk(A :: C :: Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HACApacDpcdeq HACApacDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpcd requis par la preuve de (?)OoABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpcd requis par la preuve de (?)ABCApacDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) = 4) by (apply LOoABCApacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpcdeq HOoABCApacDpcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpcdmtmp;try rewrite HT2 in HOoABCApacDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDpcdM : rk(A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDpcdm : rk(A :: B :: C :: Ap :: ac :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDpcdeq HABCApacDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpcd requis par la preuve de (?)OoABCApDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpcdeq HOoABCApDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpabDDpcd *)
(* dans constructLemma(), requis par LOoACApBpabDDpcd *)
(* dans la couche 0 *)
Lemma LOoABCApBpabDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDDpcd requis par la preuve de (?)OoABCApBpabDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDDpcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabDDpcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDDpcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpabDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDDpcd requis par la preuve de (?)OoACApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDDpcd requis par la preuve de (?)OoACApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDDpcd requis par la preuve de (?)OoACApBpabDDpcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDDpcdm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDDpcdm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApBpabDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDDpcdm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApBpabDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDDpcdmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpabDDpcdM : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpabDDpcdm : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApBpabDDpcdeq HOoACApBpabDDpcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpabDDpcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDDpcd requis par la preuve de (?)OoBCApBpabDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDDpcdm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApBpabDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDDpcd requis par la preuve de (?)OoCApBpabDDpcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDDpcdm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDDpcdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDDpcdeq HOoBCApBpabDDpcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDDpcdmtmp;try rewrite HT2 in HOoBCApBpabDDpcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDDpcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpcdm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) = 4) by (apply LOoABCApBpabDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpcdeq HOoABCApBpabDDpcdm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpcdmtmp;try rewrite HT2 in HOoABCApBpabDDpcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDDpcdmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpcdm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDDpcdeq : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) = 4) by (apply LOoACApBpabDDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpabDDpcdmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) >= 4) by (solve_hyps_min HOoACApBpabDDpcdeq HOoACApBpabDDpcdm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDDpcdmtmp;try rewrite HT2 in HOoACApBpabDDpcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDDpcdmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

assert(HOoCApBpabDDpcdM : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpabDDpcdm : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApBpabDDpcdeq HOoCApBpabDDpcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LAadcd *)
(* dans constructLemma(), requis par LACpDpadcd *)
(* dans la couche 0 *)
Lemma LACpDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpDDpadcd requis par la preuve de (?)ACpDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpDDpadcd requis par la preuve de (?)ACpDDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpDDpadcd requis par la preuve de (?)ACpDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpadcdm2 : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpadcdm3 : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACpDeq : rk(A :: Cp :: D :: nil) = 3) by (apply LACpD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDmtmp : rk(A :: Cp :: D :: nil) >= 3) by (solve_hyps_min HACpDeq HACpDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil) 3 3 HACpDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDDpadcdm4 : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HACpDDpeq : rk(A :: Cp :: D :: Dp :: nil) = 4) by (apply LACpDDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpmtmp : rk(A :: Cp :: D :: Dp :: nil) >= 4) by (solve_hyps_min HACpDDpeq HACpDDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: D :: Dp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: D :: Dp :: nil) (A :: Cp :: D :: Dp :: ad :: cd :: nil) 4 4 HACpDDpmtmp Hcomp Hincl);apply HT.
}

assert(HACpDDpadcdM : rk(A :: Cp :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpDDpadcdm : rk(A :: Cp :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACpDDpadcdeq HACpDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACpDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Cp :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACpDpadcd requis par la preuve de (?)ACpDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACpDpadcd requis par la preuve de (?)ACpDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACpDpadcd requis par la preuve de (?)ACpDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDpadcdm2 : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACpeq : rk(A :: Cp :: nil) = 2) by (apply LACp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpmtmp : rk(A :: Cp :: nil) >= 2) by (solve_hyps_min HACpeq HACpm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil) 2 2 HACpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACpDpadcdm3 : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACpDpeq : rk(A :: Cp :: Dp :: nil) = 3) by (apply LACpDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDpmtmp : rk(A :: Cp :: Dp :: nil) >= 3) by (solve_hyps_min HACpDpeq HACpDpm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: Cp :: Dp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Cp :: Dp :: nil) (A :: Cp :: Dp :: ad :: cd :: nil) 3 3 HACpDpmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: Cp :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HACpDpadcdm4 : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACpDDpadcdeq : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LACpDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDDpadcdmtmp : rk(A :: Cp :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACpDDpadcdeq HACpDDpadcdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (A :: D :: ad :: nil) (A :: Cp :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: D :: Dp :: ad :: cd :: nil) (A :: D :: ad :: A :: Cp :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: A :: Cp :: Dp :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (A :: Cp :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpDDpadcdmtmp;try rewrite HT2 in HACpDDpadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (A :: Cp :: Dp :: ad :: cd :: nil) (A :: ad :: nil) 4 2 2 HACpDDpadcdmtmp HAadmtmp HADadMtmp Hincl); apply HT.
}

assert(HACpDpadcdM : rk(A :: Cp :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACpDpadcdm : rk(A :: Cp :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACpDpadcdeq HACpDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Aadcd requis par la preuve de (?)Aadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCadcd requis par la preuve de (?)Aadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCadcd requis par la preuve de (?)OoABCadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCadcdm4 : rk(Oo :: A :: B :: C :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour Aadcd requis par la preuve de (?)Aadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ad ::  de rang :  2 et 2 	 A : Oo :: A :: B :: C :: ad ::   de rang : 4 et 4 *)
assert(HAadcdm2 : rk(A :: ad :: cd :: nil) >= 2).
{
	assert(HOoABCadeq : rk(Oo :: A :: B :: C :: ad :: nil) = 4) by (apply LOoABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCadMtmp : rk(Oo :: A :: B :: C :: ad :: nil) <= 4) by (solve_hyps_max HOoABCadeq HOoABCadM4).
	assert(HOoABCadcdmtmp : rk(Oo :: A :: B :: C :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCadcdeq HOoABCadcdm4).
	assert(HAadeq : rk(A :: ad :: nil) = 2) by (apply LAad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadmtmp : rk(A :: ad :: nil) >= 2) by (solve_hyps_min HAadeq HAadm2).
	assert(Hincl : incl (A :: ad :: nil) (list_inter (Oo :: A :: B :: C :: ad :: nil) (A :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ad :: cd :: nil) (Oo :: A :: B :: C :: ad :: A :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: C :: ad :: A :: ad :: cd :: nil) ((Oo :: A :: B :: C :: ad :: nil) ++ (A :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCadcdmtmp;try rewrite HT2 in HOoABCadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: C :: ad :: nil) (A :: ad :: cd :: nil) (A :: ad :: nil) 4 2 4 HOoABCadcdmtmp HAadmtmp HOoABCadMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : A :: Cp :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : Cp :: Dp :: cd ::   de rang : 2 et 2 *)
assert(HAadcdm3 : rk(A :: ad :: cd :: nil) >= 3).
{
	assert(HCpDpcdMtmp : rk(Cp :: Dp :: cd :: nil) <= 2) by (solve_hyps_max HCpDpcdeq HCpDpcdM2).
	assert(HACpDpadcdeq : rk(A :: Cp :: Dp :: ad :: cd :: nil) = 4) by (apply LACpDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACpDpadcdmtmp : rk(A :: Cp :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACpDpadcdeq HACpDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (Cp :: Dp :: cd :: nil) (A :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Cp :: Dp :: ad :: cd :: nil) (Cp :: Dp :: cd :: A :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Cp :: Dp :: cd :: A :: ad :: cd :: nil) ((Cp :: Dp :: cd :: nil) ++ (A :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACpDpadcdmtmp;try rewrite HT2 in HACpDpadcdmtmp.
	assert(HT := rule_4 (Cp :: Dp :: cd :: nil) (A :: ad :: cd :: nil) (cd :: nil) 4 1 2 HACpDpadcdmtmp Hcdmtmp HCpDpcdMtmp Hincl); apply HT.
}

assert(HAadcdM : rk(A :: ad :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max HAadcdeq HAadcdM3).
assert(HAadcdm : rk(A :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAadcdeq HAadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABadcd *)
(* dans constructLemma(), requis par LABDadcd *)
(* dans la couche 0 *)
Lemma LOoABDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABDadcd requis par la preuve de (?)OoABDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpDadcd requis par la preuve de (?)OoABDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDadcd requis par la preuve de (?)OoABCCpDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadcdm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABDadcd requis par la preuve de (?)OoABDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)OoABDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)OoABApDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)OoABApDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadcdm2 : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadcdm3 : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABDadcd requis par la preuve de (?)OoABDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABDadcdm2 : rk(Oo :: A :: B :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDadcdmtmp : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApDadcdeq HOoABApDadcdm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDadcdmtmp;try rewrite HT2 in HOoABApDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: D :: ad :: cd :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApDadcdmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABDadcdm3 : rk(Oo :: A :: B :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpDadcdmtmp : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCCpDadcdeq HOoABCCpDadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: D :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpDadcdmtmp;try rewrite HT2 in HOoABCCpDadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: D :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCCpDadcdmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABDadcdm4 : rk(Oo :: A :: B :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABDmtmp : rk(Oo :: A :: B :: D :: nil) >= 4) by (solve_hyps_min HOoABDeq HOoABDm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: D :: nil) (Oo :: A :: B :: D :: ad :: cd :: nil) 4 4 HOoABDmtmp Hcomp Hincl);apply HT.
}

assert(HOoABDadcdM : rk(Oo :: A :: B :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABDadcdm : rk(Oo :: A :: B :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABDadcdeq HOoABDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABDadcd requis par la preuve de (?)ABDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABDadcd requis par la preuve de (?)ABDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)ABDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)OoABApDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApDadcd requis par la preuve de (?)OoABApDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadcdm2 : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApDadcdm3 : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABDadcd requis par la preuve de (?)ABDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABDadcdm2 : rk(A :: B :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApDadcdmtmp : rk(Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApDadcdeq HOoABApDadcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: D :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: D :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApDadcdmtmp;try rewrite HT2 in HOoABApDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: D :: ad :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApDadcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABDadcdm3 : rk(A :: B :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABDeq : rk(A :: B :: D :: nil) = 3) by (apply LABD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDmtmp : rk(A :: B :: D :: nil) >= 3) by (solve_hyps_min HABDeq HABDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: D :: nil) (A :: B :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: D :: nil) (A :: B :: D :: ad :: cd :: nil) 3 3 HABDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: D :: cd ::  de rang :  3 et 3 	 A : Oo :: B :: D :: cd ::   de rang : 3 et 3 *)
assert(HABDadcdm4 : rk(A :: B :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoBDcdeq : rk(Oo :: B :: D :: cd :: nil) = 3) by (apply LOoBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBDcdMtmp : rk(Oo :: B :: D :: cd :: nil) <= 3) by (solve_hyps_max HOoBDcdeq HOoBDcdM3).
	assert(HOoABDadcdeq : rk(Oo :: A :: B :: D :: ad :: cd :: nil) = 4) by (apply LOoABDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABDadcdmtmp : rk(Oo :: A :: B :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABDadcdeq HOoABDadcdm4).
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hincl : incl (B :: D :: cd :: nil) (list_inter (Oo :: B :: D :: cd :: nil) (A :: B :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: D :: ad :: cd :: nil) (Oo :: B :: D :: cd :: A :: B :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: D :: cd :: A :: B :: D :: ad :: cd :: nil) ((Oo :: B :: D :: cd :: nil) ++ (A :: B :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABDadcdmtmp;try rewrite HT2 in HOoABDadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: D :: cd :: nil) (A :: B :: D :: ad :: cd :: nil) (B :: D :: cd :: nil) 4 3 3 HOoABDadcdmtmp HBDcdmtmp HOoBDcdMtmp Hincl); apply HT.
}

assert(HABDadcdM : rk(A :: B :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABDadcdm : rk(A :: B :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABDadcdeq HABDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABadcd *)
(* dans la couche 0 *)
Lemma LADadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ADadcd requis par la preuve de (?)ADadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadcdm2 : rk(A :: D :: ad :: cd :: nil) >= 2).
{
	assert(HADeq : rk(A :: D :: nil) = 2) by (apply LAD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADmtmp : rk(A :: D :: nil) >= 2) by (solve_hyps_min HADeq HADm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: D :: nil) (A :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: nil) (A :: D :: ad :: cd :: nil) 2 2 HADmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HADadcdM3 : rk(A :: D :: ad :: cd :: nil) <= 3).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: D :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: D :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: D :: ad :: nil) (cd :: nil) (nil) 2 1 0 HADadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HADadcdm3 : rk(A :: D :: ad :: cd :: nil) >= 3).
{
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) 3 3 HADcdmtmp Hcomp Hincl);apply HT.
}

assert(HADadcdM : rk(A :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HADadcdm : rk(A :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HADadcdeq HADadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABadcd requis par la preuve de (?)ABadcd pour la règle 2  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABadcd requis par la preuve de (?)ABadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)ABadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)OoABApadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApadcd requis par la preuve de (?)OoABApadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadcdm2 : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApadcdm3 : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABadcd requis par la preuve de (?)ABadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABadcdm2 : rk(A :: B :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApadcdmtmp : rk(Oo :: A :: B :: Ap :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApadcdeq HOoABApadcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApadcdmtmp;try rewrite HT2 in HOoABApadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ad :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApadcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABadcdm3 : rk(A :: B :: ad :: cd :: nil) >= 3).
{
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ad :: nil) (A :: B :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ad :: nil) (A :: B :: ad :: cd :: nil) 3 3 HABadmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 4 4 et 4*)
assert(HABadcdm4 : rk(A :: B :: ad :: cd :: nil) >= 4).
{
	assert(HADadcdeq : rk(A :: D :: ad :: cd :: nil) = 3) by (apply LADadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadcdMtmp : rk(A :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HADadcdeq HADadcdM3).
	assert(HABDadcdeq : rk(A :: B :: D :: ad :: cd :: nil) = 4) by (apply LABDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABDadcdmtmp : rk(A :: B :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABDadcdeq HABDadcdm4).
	assert(HAadcdeq : rk(A :: ad :: cd :: nil) = 3) by (apply LAadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAadcdmtmp : rk(A :: ad :: cd :: nil) >= 3) by (solve_hyps_min HAadcdeq HAadcdm3).
	assert(Hincl : incl (A :: ad :: cd :: nil) (list_inter (A :: B :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: D :: ad :: cd :: nil) (A :: B :: ad :: cd :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ad :: cd :: A :: D :: ad :: cd :: nil) ((A :: B :: ad :: cd :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABDadcdmtmp;try rewrite HT2 in HABDadcdmtmp.
	assert(HT := rule_2 (A :: B :: ad :: cd :: nil) (A :: D :: ad :: cd :: nil) (A :: ad :: cd :: nil) 4 3 3 HABDadcdmtmp HAadcdmtmp HADadcdMtmp Hincl);apply HT.
}

assert(HABadcdM : rk(A :: B :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABadcdm : rk(A :: B :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABadcdeq HABadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCadcd requis par la preuve de (?)OoABCadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCadcdm4 : rk(Oo :: A :: B :: C :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCadcdM : rk(Oo :: A :: B :: C :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCadcdm : rk(Oo :: A :: B :: C :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCadcdeq HOoABCadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labadcd *)
(* dans constructLemma(), requis par LCabDadcd *)
(* dans constructLemma(), requis par LACabDadcd *)
(* dans constructLemma(), requis par LABCabDadcd *)
(* dans la couche 0 *)
Lemma LOoABCabDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabDadcd requis par la preuve de (?)OoABCabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabDadcdm4 : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabDadcdM : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabDadcdm : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCabDadcdeq HOoABCabDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCabDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabDadcd requis par la preuve de (?)ABCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)ABCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)OoABCApabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabDadcd requis par la preuve de (?)ABCabDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabDadcdm3 : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabDadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCabDadcdm4 : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCabDadcdeq : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) = 4) by (apply LOoABCabDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDadcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadcdeq HOoABCabDadcdm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) (Oo :: B :: C :: D :: A :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: ab :: D :: ad :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadcdmtmp;try rewrite HT2 in HOoABCabDadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCabDadcdmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HABCabDadcdM : rk(A :: B :: C :: ab :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabDadcdm : rk(A :: B :: C :: ab :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCabDadcdeq HABCabDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabDadcd requis par la preuve de (?)ACabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabDadcd requis par la preuve de (?)ACabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)ABCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)OoABCApabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabDadcd requis par la preuve de (?)ABCabDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabDadcdm3 : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabDadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabDadcd requis par la preuve de (?)ACabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadcd requis par la preuve de (?)ACabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabDadcd requis par la preuve de (?)ABCApabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadcd requis par la preuve de (?)ABCApabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabDadcdm2 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadcdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabDadcd requis par la preuve de (?)ACabDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabDadcdm2 : rk(A :: C :: ab :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabDadcdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApabDadcdeq HABCApabDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadcdmtmp;try rewrite HT2 in HABCApabDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApabDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabDadcdm3 : rk(A :: C :: ab :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabDadcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabDadcdeq HABCabDadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadcdmtmp;try rewrite HT2 in HABCabDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: D :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabDadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabDadcdm4 : rk(A :: C :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabDadcdeq : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) = 4) by (apply LABCabDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabDadcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCabDadcdeq HABCabDadcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: D :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadcdmtmp;try rewrite HT2 in HABCabDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: D :: ad :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabDadcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HACabDadcdM : rk(A :: C :: ab :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabDadcdm : rk(A :: C :: ab :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACabDadcdeq HACabDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCabDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ab :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabDadcd requis par la preuve de (?)CabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCabDadcd requis par la preuve de (?)CabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)OoABCApabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadcdm2 : rk(Oo :: B :: C :: ab :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApabDadcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadcdm3 : rk(Oo :: B :: C :: ab :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApabDadcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBCabDadcdm4 : rk(Oo :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCabDadcdeq : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) = 4) by (apply LOoABCabDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDadcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadcdeq HOoABCabDadcdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadcdmtmp;try rewrite HT2 in HOoABCabDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil) (B :: ab :: nil) 4 2 2 HOoABCabDadcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabDadcd requis par la preuve de (?)CabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabDadcd requis par la preuve de (?)CabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabDadcd requis par la preuve de (?)ABCabDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabDadcdm3 : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabDadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabDadcd requis par la preuve de (?)CabDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabDadcdm2 : rk(C :: ab :: D :: ad :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabDadcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabDadcdeq HABCabDadcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: B :: ab :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadcdmtmp;try rewrite HT2 in HABCabDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: D :: ad :: cd :: nil) (ab :: nil) 3 1 2 HABCabDadcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : C :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HCabDadcdm3 : rk(C :: ab :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCabDadcdmtmp : rk(Oo :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoBCabDadcdeq HOoBCabDadcdm4).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: ab :: D :: ad :: cd :: nil) (Oo :: B :: C :: D :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: C :: ab :: D :: ad :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCabDadcdmtmp;try rewrite HT2 in HOoBCabDadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (C :: ab :: D :: ad :: cd :: nil) (C :: D :: nil) 4 2 3 HOoBCabDadcdmtmp HCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCabDadcdm4 : rk(C :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACabDadcdeq : rk(A :: C :: ab :: D :: ad :: cd :: nil) = 4) by (apply LACabDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabDadcdmtmp : rk(A :: C :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACabDadcdeq HACabDadcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ab :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabDadcdmtmp;try rewrite HT2 in HACabDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ab :: D :: ad :: cd :: nil) (D :: ad :: nil) 4 2 2 HACabDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

assert(HCabDadcdM : rk(C :: ab :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCabDadcdm : rk(C :: ab :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCabDadcdeq HCabDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour abadcd requis par la preuve de (?)abadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabadcd requis par la preuve de (?)abadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabadcd requis par la preuve de (?)ABabadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabadcd requis par la preuve de (?)ABabadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabadcd requis par la preuve de (?)OoABApabadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabadcd requis par la preuve de (?)OoABApabadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadcdm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadcdm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabadcd requis par la preuve de (?)ABabadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadcdm2 : rk(A :: B :: ab :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabadcdeq HOoABApabadcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadcdmtmp;try rewrite HT2 in HOoABApabadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApabadcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabadcdm3 : rk(A :: B :: ab :: ad :: cd :: nil) >= 3).
{
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ad :: nil) (A :: B :: ab :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ad :: nil) (A :: B :: ab :: ad :: cd :: nil) 3 3 HABadmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour abadcd requis par la preuve de (?)abadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: ad :: cd ::  de rang :  3 et 4 	 AiB : ab :: ad ::  de rang :  2 et 2 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(Habadcdm2 : rk(ab :: ad :: cd :: nil) >= 2).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABabadcdmtmp : rk(A :: B :: ab :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABabadcdeq HABabadcdm3).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (ab :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: cd :: nil) (A :: B :: ab :: ad :: ab :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: ab :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (ab :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadcdmtmp;try rewrite HT2 in HABabadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (ab :: ad :: cd :: nil) (ab :: ad :: nil) 3 2 3 HABabadcdmtmp Habadmtmp HABabadMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Habadcdm3 : rk(ab :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCabDadcdeq : rk(C :: ab :: D :: ad :: cd :: nil) = 4) by (apply LCabDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCabDadcdmtmp : rk(C :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCabDadcdeq HCabDadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ab :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ab :: D :: ad :: cd :: nil) (C :: D :: cd :: ab :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ab :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (ab :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCabDadcdmtmp;try rewrite HT2 in HCabDadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ab :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCabDadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HabadcdM : rk(ab :: ad :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Habadcdeq HabadcdM3).
assert(Habadcdm : rk(ab :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Habadcdeq Habadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LAacadcd *)
(* dans la couche 0 *)
Lemma LAacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: D :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacDadcd requis par la preuve de (?)ACacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacDadcdm2 : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDadcdmtmp : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDadcdmtmp;try rewrite HT2 in HABCApacDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApacDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AacDadcd requis par la preuve de (?)AacDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: D :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacDadcdm2 : rk(A :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacDadcdmtmp : rk(A :: C :: ac :: D :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacDadcdeq HACacDadcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: D :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: D :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacDadcdmtmp;try rewrite HT2 in HACacDadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacDadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacDadcdm3 : rk(A :: ac :: D :: ad :: cd :: nil) >= 3).
{
	assert(HAacadeq : rk(A :: ac :: ad :: nil) = 3) by (apply LAacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacadmtmp : rk(A :: ac :: ad :: nil) >= 3) by (solve_hyps_min HAacadeq HAacadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: ad :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ac :: ad :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HAacadmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HAacDadcdM3 : rk(A :: ac :: D :: ad :: cd :: nil) <= 3).
{
	assert(HAacDcdeq : rk(A :: ac :: D :: cd :: nil) = 3) by (apply LAacDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacDcdMtmp : rk(A :: ac :: D :: cd :: nil) <= 3) by (solve_hyps_max HAacDcdeq HAacDcdM3).
	assert(HADadcdeq : rk(A :: D :: ad :: cd :: nil) = 3) by (apply LADadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADadcdMtmp : rk(A :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HADadcdeq HADadcdM3).
	assert(HADcdeq : rk(A :: D :: cd :: nil) = 3) by (apply LADcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HADcdmtmp : rk(A :: D :: cd :: nil) >= 3) by (solve_hyps_min HADcdeq HADcdm3).
	assert(Hincl : incl (A :: D :: cd :: nil) (list_inter (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: ac :: D :: ad :: cd :: nil) (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: D :: cd :: A :: D :: ad :: cd :: nil) ((A :: ac :: D :: cd :: nil) ++ (A :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (A :: ac :: D :: cd :: nil) (A :: D :: ad :: cd :: nil) (A :: D :: cd :: nil) 3 3 3 HAacDcdMtmp HADadcdMtmp HADcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HAacDadcdM : rk(A :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacDadcdm : rk(A :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAacDadcdeq HAacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: ac :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Aacadcd requis par la preuve de (?)Aacadcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Aacadcd requis par la preuve de (?)Aacadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACacadcd requis par la preuve de (?)Aacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ACacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacadcd requis par la preuve de (?)OoABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacadcdm2 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacadcdm4 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacadcdeq HOoABCApacadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadcdmtmp;try rewrite HT2 in HOoABCApacadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACacadcd requis par la preuve de (?)ACacadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACacadcdm2 : rk(A :: C :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacadcdmtmp : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacadcdeq HABCApacadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (B :: Ap :: A :: C :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ac :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacadcdmtmp;try rewrite HT2 in HABCApacadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ac :: ad :: cd :: nil) (nil) 4 0 2 HABCApacadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Aacadcd requis par la preuve de (?)Aacadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ac :: ad :: cd ::  de rang :  2 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAacadcdm2 : rk(A :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACacadcdmtmp : rk(A :: C :: ac :: ad :: cd :: nil) >= 2) by (solve_hyps_min HACacadcdeq HACacadcdm2).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ac :: ad :: cd :: nil) (A :: C :: ac :: A :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: ac :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACacadcdmtmp;try rewrite HT2 in HACacadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: ac :: ad :: cd :: nil) (A :: ac :: nil) 2 2 2 HACacadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacadcdm3 : rk(A :: ac :: ad :: cd :: nil) >= 3).
{
	assert(HAacadeq : rk(A :: ac :: ad :: nil) = 3) by (apply LAacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacadmtmp : rk(A :: ac :: ad :: nil) >= 3) by (solve_hyps_min HAacadeq HAacadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: ad :: nil) (A :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: ac :: ad :: nil) (A :: ac :: ad :: cd :: nil) 3 3 HAacadmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HAacadcdM3 : rk(A :: ac :: ad :: cd :: nil) <= 3).
{
	assert(HAacDadcdeq : rk(A :: ac :: D :: ad :: cd :: nil) = 3) by (apply LAacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacDadcdMtmp : rk(A :: ac :: D :: ad :: cd :: nil) <= 3) by (solve_hyps_max HAacDadcdeq HAacDadcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: ac :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (A :: ac :: ad :: cd :: nil) (A :: ac :: D :: ad :: cd :: nil) 3 3 HAacDadcdMtmp Hcomp Hincl);apply HT.
}

assert(HAacadcdM : rk(A :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAacadcdm : rk(A :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAacadcdeq HAacadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LApacDpadcd *)
(* dans constructLemma(), requis par LApDpadcd *)
(* dans constructLemma(), requis par LCApDDpadcd *)
(* dans constructLemma(), requis par LOoCApDDpadcd *)
(* dans constructLemma(), requis par LOoBCApDDpadcd *)
(* dans constructLemma(), requis par LOoBCApbcDDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDDpadcd requis par la preuve de (?)OoABCApbcDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDDpadcdeq HOoABCApbcDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDDpadcd requis par la preuve de (?)OoBCApbcDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDDpadcd requis par la preuve de (?)OoBCApbcDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDDpadcdm3 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApbcDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadcdeq HOoABCApbcDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadcdmtmp;try rewrite HT2 in HOoABCApbcDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDDpadcdm4 : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApbcDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDDpadcdeq HOoABCApbcDDpadcdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDDpadcdmtmp;try rewrite HT2 in HOoABCApbcDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDDpadcdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDDpadcdM : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDDpadcdm : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDDpadcdeq HOoBCApbcDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpadcd requis par la preuve de (?)OoBCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoBCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpadcd requis par la preuve de (?)OoBCApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpadcdm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDDpadcdm4 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDDpadcdeq : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoBCApbcDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDDpadcdmtmp : rk(Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDDpadcdeq HOoBCApbcDDpadcdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: D :: Dp :: ad :: cd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDDpadcdmtmp;try rewrite HT2 in HOoBCApbcDDpadcdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDDpadcdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDDpadcdM : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDDpadcdm : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApDDpadcdeq HOoBCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoCApBpabDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoACApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApBpabDDpadcd requis par la preuve de (?)OoACApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDDpadcd requis par la preuve de (?)OoABCApBpabDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDDpadcd requis par la preuve de (?)OoACApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDDpadcd requis par la preuve de (?)OoACApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDDpadcd requis par la preuve de (?)OoACApBpabDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDDpadcdm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDDpadcdm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDDpadcdm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDDpadcdmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDDpadcd requis par la preuve de (?)OoBCApBpabDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDDpadcdm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDDpadcdm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDDpadcdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDDpadcdeq HOoBCApBpabDDpadcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDDpadcdmtmp;try rewrite HT2 in HOoBCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpadcdm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDDpadcdmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpadcdm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApBpabDDpadcdeq HOoACApBpabDDpadcdm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDDpadcdmtmp;try rewrite HT2 in HOoACApBpabDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDDpadcdmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoBCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDDpadcd requis par la preuve de (?)OoBCApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDDpadcdm3 : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApDDpadcd requis par la preuve de (?)OoCApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApDDpadcdm2 : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApDDpadcdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoBCApDDpadcdeq HOoBCApDDpadcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpadcdmtmp;try rewrite HT2 in HOoBCApDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 3 1 2 HOoBCApDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : C :: Ap ::  de rang :  2 et 2 	 A : C :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApDDpadcdm3 : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HCApBpabeq : rk(C :: Ap :: Bp :: ab :: nil) = 3) by (apply LCApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApBpabMtmp : rk(C :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HCApBpabeq HCApBpabM3).
	assert(HOoCApBpabDDpadcdmtmp : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApBpabDDpadcdeq HOoCApBpabDDpadcdm4).
	assert(HCApeq : rk(C :: Ap :: nil) = 2) by (apply LCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApmtmp : rk(C :: Ap :: nil) >= 2) by (solve_hyps_min HCApeq HCApm2).
	assert(Hincl : incl (C :: Ap :: nil) (list_inter (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (C :: Ap :: Bp :: ab :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: Ap :: Bp :: ab :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((C :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApBpabDDpadcdmtmp;try rewrite HT2 in HOoCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (C :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (C :: Ap :: nil) 4 2 3 HOoCApBpabDDpadcdmtmp HCApmtmp HCApBpabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HOoCApDDpadcdm4 : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpadcdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoBCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpadcdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpadcdeq HOoBCApDDpadcdm4).
	assert(HOoCDeq : rk(Oo :: C :: D :: nil) = 3) by (apply LOoCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCDmtmp : rk(Oo :: C :: D :: nil) >= 3) by (solve_hyps_min HOoCDeq HOoCDm3).
	assert(Hincl : incl (Oo :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: B :: C :: D :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpadcdmtmp;try rewrite HT2 in HOoBCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: C :: D :: nil) 4 3 3 HOoBCApDDpadcdmtmp HOoCDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HOoCApDDpadcdM : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApDDpadcdm : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApDDpadcdeq HOoCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)BCApDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCApDDpadcd requis par la preuve de (?)BCApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCApDDpadcdm3 : rk(B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDDpadcdmtmp;try rewrite HT2 in HOoABCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDDpadcdmtmp HApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CApDDpadcd requis par la preuve de (?)CApDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HCApDDpadcdm2 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HBCApDDpadcdmtmp : rk(B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HBCApDDpadcdeq HBCApDDpadcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCApDDpadcdmtmp;try rewrite HT2 in HBCApDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 3 1 2 HBCApDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : C :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HCApDDpadcdm3 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCApDDpadcdeq : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoBCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApDDpadcdmtmp : rk(Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApDDpadcdeq HOoBCApDDpadcdm4).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: B :: C :: D :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDDpadcdmtmp;try rewrite HT2 in HOoBCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (C :: D :: nil) 4 2 3 HOoBCApDDpadcdmtmp HCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: Dp ::  de rang :  2 et 2 	 A : Oo :: D :: Dp ::   de rang : 2 et 2 *)
assert(HCApDDpadcdm4 : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoDDpMtmp : rk(Oo :: D :: Dp :: nil) <= 2) by (solve_hyps_max HOoDDpeq HOoDDpM2).
	assert(HOoCApDDpadcdeq : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoCApDDpadcdmtmp : rk(Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoCApDDpadcdeq HOoCApDDpadcdm4).
	assert(HDDpmtmp : rk(D :: Dp :: nil) >= 2) by (solve_hyps_min HDDpeq HDDpm2).
	assert(Hincl : incl (D :: Dp :: nil) (list_inter (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: C :: Ap :: D :: Dp :: ad :: cd :: nil) (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: D :: Dp :: C :: Ap :: D :: Dp :: ad :: cd :: nil) ((Oo :: D :: Dp :: nil) ++ (C :: Ap :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoCApDDpadcdmtmp;try rewrite HT2 in HOoCApDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: D :: Dp :: nil) (C :: Ap :: D :: Dp :: ad :: cd :: nil) (D :: Dp :: nil) 4 2 2 HOoCApDDpadcdmtmp HDDpmtmp HOoDDpMtmp Hincl); apply HT.
}

assert(HCApDDpadcdM : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCApDDpadcdm : rk(C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCApbcDpadcd requis par la preuve de (?)OoBCApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDpadcd requis par la preuve de (?)OoBCApbcDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpadcd requis par la preuve de (?)OoABCApbcDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpadcd requis par la preuve de (?)OoBCApbcDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpadcd requis par la preuve de (?)OoBCApbcDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpadcdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadcdeq HOoABCApbcDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadcdmtmp;try rewrite HT2 in HOoABCApbcDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpadcdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadcdeq HOoABCApbcDpadcdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadcdmtmp;try rewrite HT2 in HOoABCApbcDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpadcdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpadcd requis par la preuve de (?)OoBCApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpadcd requis par la preuve de (?)OoBCApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpadcd requis par la preuve de (?)OoABCApDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpadcd requis par la preuve de (?)OoBCApDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpadcdm3 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDpadcdeq HOoABCApDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadcdmtmp;try rewrite HT2 in HOoABCApDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpadcdm4 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpadcdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpadcdeq HOoBCApbcDpadcdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpadcdmtmp;try rewrite HT2 in HOoBCApbcDpadcdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpadcdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApDpadcd requis par la preuve de (?)ApDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Dp ::  de rang :  1 et 1 	 A : Oo :: B :: C :: Dp ::   de rang : 3 et 3 *)
assert(HApDpadcdm2 : rk(Ap :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HOoBCDpeq : rk(Oo :: B :: C :: Dp :: nil) = 3) by (apply LOoBCDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCDpMtmp : rk(Oo :: B :: C :: Dp :: nil) <= 3) by (solve_hyps_max HOoBCDpeq HOoBCDpM3).
	assert(HOoBCApDpadcdmtmp : rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApDpadcdeq HOoBCApDpadcdm4).
	assert(HDpmtmp : rk(Dp :: nil) >= 1) by (solve_hyps_min HDpeq HDpm1).
	assert(Hincl : incl (Dp :: nil) (list_inter (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) (Oo :: B :: C :: Dp :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: Dp :: Ap :: Dp :: ad :: cd :: nil) ((Oo :: B :: C :: Dp :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApDpadcdmtmp;try rewrite HT2 in HOoBCApDpadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: Dp :: nil) (Ap :: Dp :: ad :: cd :: nil) (Dp :: nil) 4 1 3 HOoBCApDpadcdmtmp HDpmtmp HOoBCDpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HApDpadcdM3 : rk(Ap :: Dp :: ad :: cd :: nil) <= 3).
{
	assert(HApDpadMtmp : rk(Ap :: Dp :: ad :: nil) <= 2) by (solve_hyps_max HApDpadeq HApDpadM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Ap :: Dp :: ad :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: Dp :: ad :: cd :: nil) ((Ap :: Dp :: ad :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: Dp :: ad :: nil) (cd :: nil) (nil) 2 1 0 HApDpadMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : C :: Ap :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(HApDpadcdm3 : rk(Ap :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCApDDpadcdeq : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LCApDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCApDDpadcdmtmp : rk(C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCApDDpadcdeq HCApDDpadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: Ap :: D :: Dp :: ad :: cd :: nil) (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: Ap :: Dp :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCApDDpadcdmtmp;try rewrite HT2 in HCApDDpadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCApDDpadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

assert(HApDpadcdM : rk(Ap :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApDpadcdm : rk(Ap :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApDpadcdeq HApDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Ap :: ac :: Dp :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpadcdm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpadcdm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpadcdeq HABCApacDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpadcdmtmp;try rewrite HT2 in HABCApacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpadcdm4 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HACApDpeq : rk(A :: C :: Ap :: Dp :: nil) = 4) by (apply LACApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApDpmtmp : rk(A :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HACApDpeq HACApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HACApDpmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ApacDpadcd requis par la preuve de (?)ApacDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HApacDpadcdm2 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACApacDpadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : ac :: Dp ::  de rang :  2 et 2 	 A : A :: C :: ac :: Dp ::   de rang : 3 et 3 *)
assert(HApacDpadcdm3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacDpeq : rk(A :: C :: ac :: Dp :: nil) = 3) by (apply LACacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacDpMtmp : rk(A :: C :: ac :: Dp :: nil) <= 3) by (solve_hyps_max HACacDpeq HACacDpM3).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm4).
	assert(HacDpeq : rk(ac :: Dp :: nil) = 2) by (apply LacDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HacDpmtmp : rk(ac :: Dp :: nil) >= 2) by (solve_hyps_min HacDpeq HacDpm2).
	assert(Hincl : incl (ac :: Dp :: nil) (list_inter (A :: C :: ac :: Dp :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: Dp :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: Dp :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: Dp :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: Dp :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: Dp :: nil) 4 2 3 HACApacDpadcdmtmp HacDpmtmp HACacDpMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HApacDpadcdM3 : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3).
{
	assert(HApacDpcdeq : rk(Ap :: ac :: Dp :: cd :: nil) = 3) by (apply LApacDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDpcdMtmp : rk(Ap :: ac :: Dp :: cd :: nil) <= 3) by (solve_hyps_max HApacDpcdeq HApacDpcdM3).
	assert(HApDpadcdeq : rk(Ap :: Dp :: ad :: cd :: nil) = 3) by (apply LApDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpadcdMtmp : rk(Ap :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApDpadcdeq HApDpadcdM3).
	assert(HApDpcdeq : rk(Ap :: Dp :: cd :: nil) = 3) by (apply LApDpcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApDpcdmtmp : rk(Ap :: Dp :: cd :: nil) >= 3) by (solve_hyps_min HApDpcdeq HApDpcdm3).
	assert(Hincl : incl (Ap :: Dp :: cd :: nil) (list_inter (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Ap :: ac :: Dp :: cd :: Ap :: Dp :: ad :: cd :: nil) ((Ap :: ac :: Dp :: cd :: nil) ++ (Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Ap :: ac :: Dp :: cd :: nil) (Ap :: Dp :: ad :: cd :: nil) (Ap :: Dp :: cd :: nil) 3 3 3 HApacDpcdMtmp HApDpadcdMtmp HApDpcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HApacDpadcdM : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HApacDpadcdm : rk(Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HApacDpadcdeq HApacDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lacadcd *)
(* dans constructLemma(), requis par LAApacDpadcd *)
(* dans la couche 0 *)
Lemma LACApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpadcdm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpadcdm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpadcdeq HABCApacDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpadcdmtmp;try rewrite HT2 in HABCApacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HACApacDpadcdm4 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HACApDpeq : rk(A :: C :: Ap :: Dp :: nil) = 4) by (apply LACApDp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApDpmtmp : rk(A :: C :: Ap :: Dp :: nil) >= 4) by (solve_hyps_min HACApDpeq HACApDpm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: C :: Ap :: Dp :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HACApDpmtmp Hcomp Hincl);apply HT.
}

assert(HACApacDpadcdM : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACApacDpadcdm : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LAApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour AApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACApacDpadcd requis par la preuve de (?)ACApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HACApacDpadcdm2 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACApacDpadcdm3 : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApacDpadcdmtmp : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApacDpadcdeq HABCApacDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApacDpadcdmtmp;try rewrite HT2 in HABCApacDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HABCApacDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour AApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour AApacDpadcd requis par la preuve de (?)AApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HAApacDpadcdm2 : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ac ::  de rang :  2 et 2 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(HAApacDpadcdm3 : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm3).
	assert(HAaceq : rk(A :: ac :: nil) = 2) by (apply LAac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacmtmp : rk(A :: ac :: nil) >= 2) by (solve_hyps_min HAaceq HAacm2).
	assert(Hincl : incl (A :: ac :: nil) (list_inter (A :: C :: ac :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: A :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: A :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (A :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: ac :: nil) 3 2 2 HACApacDpadcdmtmp HAacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ac :: ad ::  de rang :  3 et 3 	 A : A :: C :: ac :: ad ::   de rang : 3 et 3 *)
assert(HAApacDpadcdm4 : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HACacadeq : rk(A :: C :: ac :: ad :: nil) = 3) by (apply LACacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacadMtmp : rk(A :: C :: ac :: ad :: nil) <= 3) by (solve_hyps_max HACacadeq HACacadM3).
	assert(HACApacDpadcdeq : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) = 4) by (apply LACApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACApacDpadcdmtmp : rk(A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACApacDpadcdeq HACApacDpadcdm4).
	assert(HAacadeq : rk(A :: ac :: ad :: nil) = 3) by (apply LAacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacadmtmp : rk(A :: ac :: ad :: nil) >= 3) by (solve_hyps_min HAacadeq HAacadm3).
	assert(Hincl : incl (A :: ac :: ad :: nil) (list_inter (A :: C :: ac :: ad :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: C :: ac :: ad :: A :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: A :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: C :: ac :: ad :: nil) ++ (A :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACApacDpadcdmtmp;try rewrite HT2 in HACApacDpadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: ad :: nil) (A :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: ac :: ad :: nil) 4 3 3 HACApacDpadcdmtmp HAacadmtmp HACacadMtmp Hincl); apply HT.
}

assert(HAApacDpadcdM : rk(A :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HAApacDpadcdm : rk(A :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HAApacDpadcdeq HAApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ac :: ad :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABacadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABacadcd requis par la preuve de (?)OoABacadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpacadcd requis par la preuve de (?)OoABCCpacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacadcd requis par la preuve de (?)OoABApacadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacadcd requis par la preuve de (?)OoABApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacadcdm2 : rk(Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacadcdm3 : rk(Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABacadcdm2 : rk(Oo :: A :: B :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacadcdmtmp : rk(Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApacadcdeq HOoABApacadcdm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacadcdmtmp;try rewrite HT2 in HOoABApacadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApacadcdmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABacadcdm3 : rk(Oo :: A :: B :: ac :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpacadcdmtmp : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCCpacadcdeq HOoABCCpacadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ac :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpacadcdmtmp;try rewrite HT2 in HOoABCCpacadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCCpacadcdmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABacadcdm4 : rk(Oo :: A :: B :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour acadcd requis par la preuve de (?)acadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB : ac :: ad ::  de rang :  2 et 2 	 A : Oo :: A :: B :: ac :: ad ::   de rang : 4 et 4 *)
assert(Hacadcdm2 : rk(ac :: ad :: cd :: nil) >= 2).
{
	assert(HOoABacadeq : rk(Oo :: A :: B :: ac :: ad :: nil) = 4) by (apply LOoABacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacadMtmp : rk(Oo :: A :: B :: ac :: ad :: nil) <= 4) by (solve_hyps_max HOoABacadeq HOoABacadM4).
	assert(HOoABacadcdmtmp : rk(Oo :: A :: B :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABacadcdeq HOoABacadcdm4).
	assert(Hacadeq : rk(ac :: ad :: nil) = 2) by (apply Lacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Hacadmtmp : rk(ac :: ad :: nil) >= 2) by (solve_hyps_min Hacadeq Hacadm2).
	assert(Hincl : incl (ac :: ad :: nil) (list_inter (Oo :: A :: B :: ac :: ad :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ac :: ad :: cd :: nil) (Oo :: A :: B :: ac :: ad :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ac :: ad :: ac :: ad :: cd :: nil) ((Oo :: A :: B :: ac :: ad :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABacadcdmtmp;try rewrite HT2 in HOoABacadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: ac :: ad :: nil) (ac :: ad :: cd :: nil) (ac :: ad :: nil) 4 2 4 HOoABacadcdmtmp Hacadmtmp HOoABacadMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HacadcdM2 : rk(ac :: ad :: cd :: nil) <= 2).
{
	assert(HAacadcdeq : rk(A :: ac :: ad :: cd :: nil) = 3) by (apply LAacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAacadcdMtmp : rk(A :: ac :: ad :: cd :: nil) <= 3) by (solve_hyps_max HAacadcdeq HAacadcdM3).
	assert(HApacDpadcdeq : rk(Ap :: ac :: Dp :: ad :: cd :: nil) = 3) by (apply LApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApacDpadcdMtmp : rk(Ap :: ac :: Dp :: ad :: cd :: nil) <= 3) by (solve_hyps_max HApacDpadcdeq HApacDpadcdM3).
	assert(HAApacDpadcdeq : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) = 4) by (apply LAApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAApacDpadcdmtmp : rk(A :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HAApacDpadcdeq HAApacDpadcdm4).
	assert(Hincl : incl (ac :: ad :: cd :: nil) (list_inter (A :: ac :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: ac :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: ac :: ad :: cd :: Ap :: ac :: Dp :: ad :: cd :: nil) ((A :: ac :: ad :: cd :: nil) ++ (Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HAApacDpadcdmtmp;try rewrite HT2 in HAApacDpadcdmtmp.
	assert(HT := rule_3 (A :: ac :: ad :: cd :: nil) (Ap :: ac :: Dp :: ad :: cd :: nil) (ac :: ad :: cd :: nil) 3 3 4 HAacadcdMtmp HApacDpadcdMtmp HAApacDpadcdmtmp Hincl);apply HT.
}


assert(HacadcdM : rk(ac :: ad :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hacadcdeq HacadcdM3).
assert(Hacadcdm : rk(ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Hacadcdeq Hacadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: ac :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABacadcd requis par la preuve de (?)OoABacadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCCpacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpacadcd requis par la preuve de (?)OoABCCpacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApacadcd requis par la preuve de (?)OoABApacadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApacadcd requis par la preuve de (?)OoABApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacadcdm2 : rk(Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApacadcdm3 : rk(Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoAB requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour OoABab requis par la preuve de (?)OoAB pour la règle 2  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoABab requis par la preuve de (?)OoABab pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABab requis par la preuve de (?)OoABab pour la règle 1  *)
(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -2 -4 et 5*)
assert(HOoABabM3 : rk(Oo :: A :: B :: ab :: nil) <= 3).
{
	assert(HOoMtmp : rk(Oo :: nil) <= 1) by (solve_hyps_max HOoeq HOoM1).
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: ab :: nil) ((Oo :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (Oo :: nil) (A :: B :: ab :: nil) (nil) 1 2 0 HOoMtmp HABabMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABabm2 : rk(Oo :: A :: B :: ab :: nil) >= 2).
{
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: B :: nil) (Oo :: A :: B :: ab :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: nil) (Oo :: A :: B :: ab :: nil) 2 2 HABmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour OoAB requis par la preuve de (?)OoAB pour la règle 2  *)
(* Application de la règle 2 code (7 ou 8 dans la thèse) conclusion A*)
(* marque des antécédents AUB AiB B: 5 4 et -4*)
assert(HOoABm2 : rk(Oo :: A :: B :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABabmtmp : rk(Oo :: A :: B :: ab :: nil) >= 2) by (solve_hyps_min HOoABabeq HOoABabm2).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: nil) (A :: B :: ab :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: ab :: nil) (Oo :: A :: B :: A :: B :: ab :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: A :: B :: ab :: nil) ((Oo :: A :: B :: nil) ++ (A :: B :: ab :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABabmtmp;try rewrite HT2 in HOoABabmtmp.
	assert(HT := rule_2 (Oo :: A :: B :: nil) (A :: B :: ab :: nil) (A :: B :: nil) 2 2 2 HOoABabmtmp HABmtmp HABabMtmp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABacadcd requis par la preuve de (?)OoABacadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 5 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ac :: ad :: cd ::  de rang :  3 et 4 	 AiB : Oo :: A :: B ::  de rang :  2 et 3 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HOoABacadcdm2 : rk(Oo :: A :: B :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApacadcdmtmp : rk(Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoABApacadcdeq HOoABApacadcdm3).
	assert(HOoABmtmp : rk(Oo :: A :: B :: nil) >= 2) by (solve_hyps_min HOoABeq HOoABm2).
	assert(Hincl : incl (Oo :: A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ac :: ad :: cd :: nil) (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: Oo :: A :: B :: ac :: ad :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApacadcdmtmp;try rewrite HT2 in HOoABApacadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil) (Oo :: A :: B :: nil) 3 2 3 HOoABApacadcdmtmp HOoABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Cp :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: C :: Cp ::   de rang : 2 et 2 *)
assert(HOoABacadcdm3 : rk(Oo :: A :: B :: ac :: ad :: cd :: nil) >= 3).
{
	assert(HOoCCpMtmp : rk(Oo :: C :: Cp :: nil) <= 2) by (solve_hyps_max HOoCCpeq HOoCCpM2).
	assert(HOoABCCpacadcdmtmp : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCCpacadcdeq HOoABCCpacadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) (Oo :: C :: Cp :: Oo :: A :: B :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: C :: Cp :: Oo :: A :: B :: ac :: ad :: cd :: nil) ((Oo :: C :: Cp :: nil) ++ (Oo :: A :: B :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCCpacadcdmtmp;try rewrite HT2 in HOoABCCpacadcdmtmp.
	assert(HT := rule_4 (Oo :: C :: Cp :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCCpacadcdmtmp HOomtmp HOoCCpMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HOoABacadcdm4 : rk(Oo :: A :: B :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABaceq : rk(Oo :: A :: B :: ac :: nil) = 4) by (apply LOoABac with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABacmtmp : rk(Oo :: A :: B :: ac :: nil) >= 4) by (solve_hyps_min HOoABaceq HOoABacm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: ac :: nil) (Oo :: A :: B :: ac :: ad :: cd :: nil) 4 4 HOoABacmtmp Hcomp Hincl);apply HT.
}

assert(HOoABacadcdM : rk(Oo :: A :: B :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABacadcdm : rk(Oo :: A :: B :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABacadcdeq HOoABacadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacadcd *)
(* dans la couche 0 *)
Lemma LOoABCApacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacadcd requis par la preuve de (?)OoABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacadcdeq HOoABCApacadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacadcd requis par la preuve de (?)ABCApacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacadcdm2 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacadcdm4 : rk(A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacadcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) = 4) by (apply LOoABCApacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacadcdeq HOoABCApacadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacadcdmtmp;try rewrite HT2 in HOoABCApacadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacadcdM : rk(A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacadcdm : rk(A :: B :: C :: Ap :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacadcdeq HABCApacadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpacadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpacadcd requis par la preuve de (?)OoABCCpacadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpacadcdm4 : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: ac :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpacadcdM : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpacadcdm : rk(Oo :: A :: B :: C :: Cp :: ac :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCCpacadcdeq HOoABCCpacadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Labbcadcd *)
(* dans la couche 0 *)
Lemma Labacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCabacbcadcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HABCadeq : rk(A :: B :: C :: ad :: nil) = 4) by (apply LABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCadmtmp : rk(A :: B :: C :: ad :: nil) >= 4) by (solve_hyps_min HABCadeq HABCadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HABCadmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcadcdmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApabacbcadcdeq HABCApabacbcadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcadcdmtmp;try rewrite HT2 in HABCApabacbcadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (nil) 4 0 2 HABCApabacbcadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm4 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabacbcadcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadcd requis par la preuve de (?)abacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadcdm2 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadcdmtmp;try rewrite HT2 in HACabacbcadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : ac :: ad ::  de rang :  2 et 2 	 A : A :: C :: ac :: ad ::   de rang : 3 et 3 *)
assert(Habacbcadcdm3 : rk(ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HACacadeq : rk(A :: C :: ac :: ad :: nil) = 3) by (apply LACacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacadMtmp : rk(A :: C :: ac :: ad :: nil) <= 3) by (solve_hyps_max HACacadeq HACacadM3).
	assert(HACabacbcadcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm4).
	assert(Hacadeq : rk(ac :: ad :: nil) = 2) by (apply Lacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Hacadmtmp : rk(ac :: ad :: nil) >= 2) by (solve_hyps_min Hacadeq Hacadm2).
	assert(Hincl : incl (ac :: ad :: nil) (list_inter (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: C :: ac :: ad :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadcdmtmp;try rewrite HT2 in HACabacbcadcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ac :: ad :: nil) 4 2 3 HACabacbcadcdmtmp Hacadmtmp HACacadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et -2*)
assert(HabacbcadcdM3 : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3).
{
	assert(Habacbceq : rk(ab :: ac :: bc :: nil) = 2) by (apply Labacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabacbcMtmp : rk(ab :: ac :: bc :: nil) <= 2) by (solve_hyps_max Habacbceq HabacbcM2).
	assert(Hacadcdeq : rk(ac :: ad :: cd :: nil) = 2) by (apply Lacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HacadcdMtmp : rk(ac :: ad :: cd :: nil) <= 2) by (solve_hyps_max Hacadcdeq HacadcdM2).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ac :: bc :: ac :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ac :: bc :: ac :: ad :: cd :: nil) ((ab :: ac :: bc :: nil) ++ (ac :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ac :: bc :: nil) (ac :: ad :: cd :: nil) (ac :: nil) 2 2 1 HabacbcMtmp HacadcdMtmp Hacmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HabacbcadcdM : rk(ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadcdm : rk(ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadcdeq Habacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: bc :: ad :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abbcadcd requis par la preuve de (?)abbcadcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CabbcDadcd requis par la preuve de (?)abbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabbcDadcd requis par la preuve de (?)OoABCabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabbcDadcdm4 : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)OoABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCabbcDadcdm4 : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCabbcDadcdmtmp : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabbcDadcdeq HOoABCabbcDadcdm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabbcDadcdmtmp;try rewrite HT2 in HOoABCabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCabbcDadcdmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ABCApabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcDadcdm2 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcDadcdm4 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabbcDadcdm2 : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabbcDadcdmtmp : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApabbcDadcdeq HABCApabbcDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabbcDadcdmtmp;try rewrite HT2 in HABCApabbcDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApabbcDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcDadcdm3 : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabbcDadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabbcDadcdm4 : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabbcDadcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabbcDadcd requis par la preuve de (?)BCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabbcDadcd requis par la preuve de (?)BCabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabbcDadcdm2 : rk(B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApabbcDadcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabbcDadcdm3 : rk(B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabbcDadcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabbcDadcdm2 : rk(C :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil) (ab :: nil) 3 1 2 HABCabbcDadcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCabbcDadcdm3 : rk(C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCabbcDadcdmtmp : rk(B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HBCabbcDadcdeq HBCabbcDadcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: bc :: D :: ad :: cd :: nil) (B :: C :: bc :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: ab :: bc :: D :: ad :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabbcDadcdmtmp;try rewrite HT2 in HBCabbcDadcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCabbcDadcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCabbcDadcdm4 : rk(C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACabbcDadcdmtmp : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACabbcDadcdeq HACabbcDadcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabbcDadcdmtmp;try rewrite HT2 in HACabbcDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil) (D :: ad :: nil) 4 2 2 HACabbcDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abbcadcd requis par la preuve de (?)abbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabbcadcd requis par la preuve de (?)abbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcadcd requis par la preuve de (?)BCabbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcadcd requis par la preuve de (?)ABCabbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcadcd requis par la preuve de (?)OoABCApabbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcadcd requis par la preuve de (?)ABCabbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcadcdm3 : rk(A :: B :: C :: ab :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcadcdeq HOoABCApabbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcadcdmtmp;try rewrite HT2 in HOoABCApabbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabbcadcd requis par la preuve de (?)BCabbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabbcadcd requis par la preuve de (?)BCabbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabbcadcdm2 : rk(B :: C :: ab :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcadcdeq HOoABCApabbcadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcadcdmtmp;try rewrite HT2 in HOoABCApabbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApabbcadcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabbcadcdm3 : rk(B :: C :: ab :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcadcdmtmp : rk(A :: B :: C :: ab :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcadcdeq HABCabbcadcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: ad :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcadcdmtmp;try rewrite HT2 in HABCabbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: bc :: ad :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabbcadcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abbcadcd requis par la preuve de (?)abbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(Habbcadcdm2 : rk(ab :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCabbcadcdmtmp : rk(B :: C :: ab :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HBCabbcadcdeq HBCabbcadcdm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (ab :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: bc :: ad :: cd :: nil) (B :: C :: bc :: ab :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: ab :: bc :: ad :: cd :: nil) ((B :: C :: bc :: nil) ++ (ab :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabbcadcdmtmp;try rewrite HT2 in HBCabbcadcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (ab :: bc :: ad :: cd :: nil) (bc :: nil) 3 1 2 HBCabbcadcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Habbcadcdm3 : rk(ab :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCabbcDadcdmtmp : rk(C :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HCabbcDadcdeq HCabbcDadcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ab :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ab :: bc :: D :: ad :: cd :: nil) (C :: D :: cd :: ab :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ab :: bc :: ad :: cd :: nil) ((C :: D :: cd :: nil) ++ (ab :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCabbcDadcdmtmp;try rewrite HT2 in HCabbcDadcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ab :: bc :: ad :: cd :: nil) (cd :: nil) 4 1 2 HCabbcDadcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HabbcadcdM3 : rk(ab :: bc :: ad :: cd :: nil) <= 3).
{
	assert(Habacbcadcdeq : rk(ab :: ac :: bc :: ad :: cd :: nil) = 3) by (apply Labacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabacbcadcdMtmp : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3) by (solve_hyps_max Habacbcadcdeq HabacbcadcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (ab :: bc :: ad :: cd :: nil) (ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (ab :: bc :: ad :: cd :: nil) (ab :: ac :: bc :: ad :: cd :: nil) 3 3 HabacbcadcdMtmp Hcomp Hincl);apply HT.
}

assert(HabbcadcdM : rk(ab :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habbcadcdm : rk(ab :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min Habbcadcdeq Habbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcadcd requis par la preuve de (?)OoABCApabbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabbcadcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcadcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabbcadcdeq HOoABCApabbcadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACabacbcadcd *)
(* dans la couche 0 *)
Lemma LABCabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCabacbcadcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HABCadeq : rk(A :: B :: C :: ad :: nil) = 4) by (apply LABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCadmtmp : rk(A :: B :: C :: ad :: nil) >= 4) by (solve_hyps_min HABCadeq HABCadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HABCadmtmp Hcomp Hincl);apply HT.
}

assert(HABCabacbcadcdM : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabacbcadcdm : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadcd requis par la preuve de (?)ABCabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadcd requis par la preuve de (?)ACabacbcadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcadcdmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApabacbcadcdeq HABCApabacbcadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcadcdmtmp;try rewrite HT2 in HABCApabacbcadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (nil) 4 0 2 HABCApabacbcadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabacbcadcdm4 : rk(A :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabacbcadcdeq : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LABCabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabacbcadcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcadcdeq HABCabacbcadcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadcdmtmp;try rewrite HT2 in HABCabacbcadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabacbcadcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HACabacbcadcdM : rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcadcdm : rk(A :: C :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACabacbcadcdeq HACabacbcadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbcadcd *)
(* dans la couche 0 *)
Lemma LOoABCApabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadcd requis par la preuve de (?)OoABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcadcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbcadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadcd requis par la preuve de (?)ABCApabacbcadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) = 4) by (apply LOoABCApabacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadcdeq HOoABCApabacbcadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadcdmtmp;try rewrite HT2 in HOoABCApabacbcadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabacbcadcdM : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcadcdm : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabacbcadcdeq HABCApabacbcadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCCpDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Cp :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCCpDadcd requis par la preuve de (?)OoABCCpDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCCpDadcdm4 : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Cp :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCCpDadcdM : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCCpDadcdm : rk(Oo :: A :: B :: C :: Cp :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCCpDadcdeq HOoABCCpDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCabDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: ab :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)OoABCApabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCabDadcd requis par la preuve de (?)OoBCabDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadcdm2 : rk(Oo :: B :: C :: ab :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApabDadcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadcdm3 : rk(Oo :: B :: C :: ab :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApabDadcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBCabDadcdm4 : rk(Oo :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCabDadcdeq : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) = 4) by (apply LOoABCabDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDadcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadcdeq HOoABCabDadcdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: cd :: nil) (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadcdmtmp;try rewrite HT2 in HOoABCabDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: cd :: nil) (B :: ab :: nil) 4 2 2 HOoABCabDadcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBCabDadcdM : rk(Oo :: B :: C :: ab :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCabDadcdm : rk(Oo :: B :: C :: ab :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCabDadcdeq HOoBCabDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDadcd *)
(* dans la couche 0 *)
Lemma LOoABCApabDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadcd requis par la preuve de (?)OoABCApabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabDadcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDadcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabDadcd requis par la preuve de (?)ABCApabDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadcd requis par la preuve de (?)ABCApabDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabDadcdm2 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadcdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) = 4) by (apply LOoABCApabDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadcdeq HOoABCApabDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadcdmtmp;try rewrite HT2 in HOoABCApabDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabDadcdM : rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDadcdm : rk(A :: B :: C :: Ap :: ab :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabDadcdeq HABCApabDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDadcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDadcd requis par la preuve de (?)OoABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDadcd requis par la preuve de (?)ABCApacDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDadcdm2 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDadcdm4 : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDadcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) = 4) by (apply LOoABCApacDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDadcdeq HOoABCApacDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDadcdmtmp;try rewrite HT2 in HOoABCApacDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDadcdM : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDadcdm : rk(A :: B :: C :: Ap :: ac :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDadcdeq HABCApacDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCabbcDadcd *)
(* dans constructLemma(), requis par LACabbcDadcd *)
(* dans constructLemma(), requis par LABCabbcDadcd *)
(* dans la couche 0 *)
Lemma LOoABCabbcDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabbcDadcd requis par la preuve de (?)OoABCabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabbcDadcdm4 : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabbcDadcdM : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabbcDadcdm : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCabbcDadcdeq HOoABCabbcDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCabbcDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: bc :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)OoABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCabbcDadcdm4 : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCabbcDadcdeq : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) = 4) by (apply LOoABCabbcDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabbcDadcdmtmp : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabbcDadcdeq HOoABCabbcDadcdm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabbcDadcdmtmp;try rewrite HT2 in HOoABCabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCabbcDadcdmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HABCabbcDadcdM : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabbcDadcdm : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabbcDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: bc :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)OoABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ABCApabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcDadcdm2 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcDadcdm4 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbcDadcd requis par la preuve de (?)ACabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabbcDadcdm2 : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabbcDadcdmtmp : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCApabbcDadcdeq HABCApabbcDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabbcDadcdmtmp;try rewrite HT2 in HABCApabbcDadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (nil) 4 0 2 HABCApabbcDadcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcDadcdm3 : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabbcDadcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabbcDadcdm4 : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabbcDadcdeq : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) = 4) by (apply LABCabbcDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabbcDadcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HACabbcDadcdM : rk(A :: C :: ab :: bc :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabbcDadcdm : rk(A :: C :: ab :: bc :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HACabbcDadcdeq HACabbcDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCabbcDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ab :: bc :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)BCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)OoABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadcd requis par la preuve de (?)ABCabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabbcDadcd requis par la preuve de (?)BCabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabbcDadcd requis par la preuve de (?)BCabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabbcDadcdm2 : rk(B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil) (nil) 4 0 2 HOoABCApabbcDadcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabbcDadcdm3 : rk(B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabbcDadcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabbcDadcd requis par la preuve de (?)CabbcDadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabbcDadcdm2 : rk(C :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadcdeq HABCabbcDadcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: B :: ab :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadcdmtmp;try rewrite HT2 in HABCabbcDadcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil) (ab :: nil) 3 1 2 HABCabbcDadcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCabbcDadcdm3 : rk(C :: ab :: bc :: D :: ad :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCabbcDadcdmtmp : rk(B :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 3) by (solve_hyps_min HBCabbcDadcdeq HBCabbcDadcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: bc :: D :: ad :: cd :: nil) (B :: C :: bc :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: ab :: bc :: D :: ad :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabbcDadcdmtmp;try rewrite HT2 in HBCabbcDadcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCabbcDadcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCabbcDadcdm4 : rk(C :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACabbcDadcdeq : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) = 4) by (apply LACabbcDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabbcDadcdmtmp : rk(A :: C :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HACabbcDadcdeq HACabbcDadcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: bc :: D :: ad :: cd :: nil) (A :: D :: ad :: C :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ab :: bc :: D :: ad :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabbcDadcdmtmp;try rewrite HT2 in HACabbcDadcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: cd :: nil) (D :: ad :: nil) 4 2 2 HACabbcDadcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

assert(HCabbcDadcdM : rk(C :: ab :: bc :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCabbcDadcdm : rk(C :: ab :: bc :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HCabbcDadcdeq HCabbcDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabbcDadcd *)
(* dans la couche 0 *)
Lemma LOoABCApabbcDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadcd requis par la preuve de (?)OoABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabbcDadcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcDadcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabbcDadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ABCApabbcDadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbcDadcd requis par la preuve de (?)ABCApabbcDadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcDadcdm2 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcDadcdm4 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) = 4) by (apply LOoABCApabbcDadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabbcDadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadcdeq HOoABCApabbcDadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadcdmtmp;try rewrite HT2 in HOoABCApabbcDadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcDadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabbcDadcdM : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabbcDadcdm : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabbcDadcdeq HABCApabbcDadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoBCApDpadcd *)
(* dans constructLemma(), requis par LOoBCApbcDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApbcDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDpadcd requis par la preuve de (?)OoABCApbcDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDpadcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDpadcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDpadcdeq HOoABCApbcDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApbcDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApbcDpadcd requis par la preuve de (?)OoBCApbcDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApbcDpadcd requis par la preuve de (?)OoBCApbcDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApbcDpadcdm3 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApbcDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApbcDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadcdeq HOoABCApbcDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadcdmtmp;try rewrite HT2 in HOoABCApbcDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApbcDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: bc ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApbcDpadcdm4 : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApbceq : rk(Oo :: A :: Ap :: bc :: nil) = 3) by (apply LOoAApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApbcMtmp : rk(Oo :: A :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HOoAApbceq HOoAApbcM3).
	assert(HOoABCApbcDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApbcDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApbcDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDpadcdeq HOoABCApbcDpadcdm4).
	assert(HOoApbceq : rk(Oo :: Ap :: bc :: nil) = 3) by (apply LOoApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApbcmtmp : rk(Oo :: Ap :: bc :: nil) >= 3) by (solve_hyps_min HOoApbceq HOoApbcm3).
	assert(Hincl : incl (Oo :: Ap :: bc :: nil) (list_inter (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: bc :: Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDpadcdmtmp;try rewrite HT2 in HOoABCApbcDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (Oo :: Ap :: bc :: nil) 4 3 3 HOoABCApbcDpadcdmtmp HOoApbcmtmp HOoAApbcMtmp Hincl); apply HT.
}

assert(HOoBCApbcDpadcdM : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApbcDpadcdm : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApbcDpadcdeq HOoBCApbcDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCApDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApDpadcd requis par la preuve de (?)OoBCApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApDpadcd requis par la preuve de (?)OoBCApDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpadcd requis par la preuve de (?)OoABCApDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApDpadcd requis par la preuve de (?)OoBCApDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApDpadcdm3 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApDpadcdeq HOoABCApDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApDpadcdmtmp;try rewrite HT2 in HOoABCApDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: Ap ::  de rang :  3 et 3 	 A : B :: C :: Ap :: bc ::   de rang : 3 et 3 *)
assert(HOoBCApDpadcdm4 : rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HBCApbceq : rk(B :: C :: Ap :: bc :: nil) = 3) by (apply LBCApbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApbcMtmp : rk(B :: C :: Ap :: bc :: nil) <= 3) by (solve_hyps_max HBCApbceq HBCApbcM3).
	assert(HOoBCApbcDpadcdeq : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) = 4) by (apply LOoBCApbcDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoBCApbcDpadcdmtmp : rk(Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoBCApbcDpadcdeq HOoBCApbcDpadcdm4).
	assert(HBCApeq : rk(B :: C :: Ap :: nil) = 3) by (apply LBCAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCApmtmp : rk(B :: C :: Ap :: nil) >= 3) by (solve_hyps_min HBCApeq HBCApm3).
	assert(Hincl : incl (B :: C :: Ap :: nil) (list_inter (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: bc :: Dp :: ad :: cd :: nil) (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: Ap :: bc :: Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) ((B :: C :: Ap :: bc :: nil) ++ (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApbcDpadcdmtmp;try rewrite HT2 in HOoBCApbcDpadcdmtmp.
	assert(HT := rule_4 (B :: C :: Ap :: bc :: nil) (Oo :: B :: C :: Ap :: Dp :: ad :: cd :: nil) (B :: C :: Ap :: nil) 4 3 3 HOoBCApbcDpadcdmtmp HBCApmtmp HBCApbcMtmp Hincl); apply HT.
}

assert(HOoBCApDpadcdM : rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCApDpadcdm : rk(Oo :: B :: C :: Ap :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCApDpadcdeq HOoBCApDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDpadcd requis par la preuve de (?)OoABCApDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDpadcdM : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDpadcdm : rk(Oo :: A :: B :: C :: Ap :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDpadcdeq HOoABCApDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApacDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApacDpadcd requis par la preuve de (?)OoABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApacDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApacDpadcdM : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApacDpadcdm : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApacDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApacDpadcd requis par la preuve de (?)ABCApacDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApacDpadcdm2 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApacDpadcdm4 : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApacDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApacDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApacDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApacDpadcdeq HOoABCApacDpadcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApacDpadcdmtmp;try rewrite HT2 in HOoABCApacDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ac :: Dp :: ad :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApacDpadcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApacDpadcdM : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApacDpadcdm : rk(A :: B :: C :: Ap :: ac :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HABCApacDpadcdeq HABCApacDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApDDpadcd requis par la preuve de (?)OoABCApDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApDDpadcdeq HOoABCApDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LOoCApBpabDDpadcd *)
(* dans constructLemma(), requis par LOoACApBpabDDpadcd *)
(* dans la couche 0 *)
Lemma LOoABCApBpabDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApBpabDDpadcd requis par la preuve de (?)OoABCApBpabDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApBpabDDpadcdm4 : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApBpabDDpadcdM : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApBpabDDpadcdm : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoACApBpabDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoACApBpabDDpadcd requis par la preuve de (?)OoACApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoACApBpabDDpadcd requis par la preuve de (?)OoACApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoACApBpabDDpadcd requis par la preuve de (?)OoACApBpabDDpadcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoACApBpabDDpadcdm2 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoACApBpabDDpadcdm3 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoABCApBpabDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApBpabDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap :: Bp ::  de rang :  3 et 3 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoACApBpabDDpadcdm4 : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApBpabDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HAApBpmtmp : rk(A :: Ap :: Bp :: nil) >= 3) by (solve_hyps_min HAApBpeq HAApBpm3).
	assert(Hincl : incl (A :: Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: Bp :: nil) 4 3 3 HOoABCApBpabDDpadcdmtmp HAApBpmtmp HABApBpMtmp Hincl); apply HT.
}

assert(HOoACApBpabDDpadcdM : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoACApBpabDDpadcdm : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoACApBpabDDpadcdeq HOoACApBpabDDpadcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoCApBpabDDpadcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCApBpabDDpadcd requis par la preuve de (?)OoBCApBpabDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCApBpabDDpadcdm3 : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApBpabDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApBpabDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 4 1 2 HOoABCApBpabDDpadcdmtmp HApmtmp HAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoCApBpabDDpadcd requis par la preuve de (?)OoCApBpabDDpadcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et 4*)
(* ensembles concernés AUB : Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  3 et 4 	 AiB : Ap ::  de rang :  1 et 1 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HOoCApBpabDDpadcdm2 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HOoBCApBpabDDpadcdmtmp : rk(Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3) by (solve_hyps_min HOoBCApBpabDDpadcdeq HOoBCApBpabDDpadcdm3).
	assert(HApmtmp : rk(Ap :: nil) >= 1) by (solve_hyps_min HApeq HApm1).
	assert(Hincl : incl (Ap :: nil) (list_inter (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((B :: Ap :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCApBpabDDpadcdmtmp;try rewrite HT2 in HOoBCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: nil) 3 1 2 HOoBCApBpabDDpadcdmtmp HApmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Ap :: Bp ::  de rang :  2 et 2 	 A : A :: B :: Ap :: Bp ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpadcdm3 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 3).
{
	assert(HABApBpeq : rk(A :: B :: Ap :: Bp :: nil) = 3) by (apply LABApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABApBpMtmp : rk(A :: B :: Ap :: Bp :: nil) <= 3) by (solve_hyps_max HABApBpeq HABApBpM3).
	assert(HOoABCApBpabDDpadcdeq : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoABCApBpabDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApBpabDDpadcdmtmp : rk(Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApBpabDDpadcdeq HOoABCApBpabDDpadcdm4).
	assert(HApBpeq : rk(Ap :: Bp :: nil) = 2) by (apply LApBp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HApBpmtmp : rk(Ap :: Bp :: nil) >= 2) by (solve_hyps_min HApBpeq HApBpm2).
	assert(Hincl : incl (Ap :: Bp :: nil) (list_inter (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: Ap :: Bp :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((A :: B :: Ap :: Bp :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApBpabDDpadcdmtmp;try rewrite HT2 in HOoABCApBpabDDpadcdmtmp.
	assert(HT := rule_4 (A :: B :: Ap :: Bp :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Ap :: Bp :: nil) 4 2 3 HOoABCApBpabDDpadcdmtmp HApBpmtmp HABApBpMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  de rang :  4 et 4 	 AiB : Oo :: Ap :: Bp :: ab ::  de rang :  3 et 3 	 A : Oo :: A :: Ap :: Bp :: ab ::   de rang : 3 et 3 *)
assert(HOoCApBpabDDpadcdm4 : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4).
{
	assert(HOoAApBpabeq : rk(Oo :: A :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoAApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoAApBpabMtmp : rk(Oo :: A :: Ap :: Bp :: ab :: nil) <= 3) by (solve_hyps_max HOoAApBpabeq HOoAApBpabM3).
	assert(HOoACApBpabDDpadcdeq : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) = 4) by (apply LOoACApBpabDDpadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoACApBpabDDpadcdmtmp : rk(Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) >= 4) by (solve_hyps_min HOoACApBpabDDpadcdeq HOoACApBpabDDpadcdm4).
	assert(HOoApBpabeq : rk(Oo :: Ap :: Bp :: ab :: nil) = 3) by (apply LOoApBpab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoApBpabmtmp : rk(Oo :: Ap :: Bp :: ab :: nil) >= 3) by (solve_hyps_min HOoApBpabeq HOoApBpabm3).
	assert(Hincl : incl (Oo :: Ap :: Bp :: ab :: nil) (list_inter (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Bp :: ab :: Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) ((Oo :: A :: Ap :: Bp :: ab :: nil) ++ (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoACApBpabDDpadcdmtmp;try rewrite HT2 in HOoACApBpabDDpadcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: Bp :: ab :: nil) (Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd :: nil) (Oo :: Ap :: Bp :: ab :: nil) 4 3 3 HOoACApBpabDDpadcdmtmp HOoApBpabmtmp HOoAApBpabMtmp Hincl); apply HT.
}

assert(HOoCApBpabDDpadcdM : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoCApBpabDDpadcdm : rk(Oo :: C :: Ap :: Bp :: ab :: D :: Dp :: ad :: cd ::  nil) >= 1) by (solve_hyps_min HOoCApBpabDDpadcdeq HOoCApBpabDDpadcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBbcbdcd *)
(* dans constructLemma(), requis par LBCbcbdcd *)
(* dans la couche 0 *)
Lemma LBCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcDbdcdm3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: D :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 4 et 4*)
assert(HBCbcDbdcdM3 : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDcdeq : rk(B :: C :: bc :: D :: cd :: nil) = 3) by (apply LBCbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDcdMtmp : rk(B :: C :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDcdeq HBCbcDcdM3).
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hincl : incl (B :: D :: nil) (list_inter (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: B :: C :: bc :: D :: cd :: nil) ((B :: D :: bd :: nil) ++ (B :: C :: bc :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (B :: C :: bc :: D :: cd :: nil) (B :: D :: nil) 2 3 2 HBDbdMtmp HBCbcDcdMtmp HBDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBCbcDbdcdM : rk(B :: C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcDbdcdm : rk(B :: C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBCbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: C :: bc :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)OoABCApbcbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcbdcdm2 : rk(B :: C :: bc :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcbdcdeq HOoABCApbcbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcbdcdmtmp;try rewrite HT2 in HOoABCApbcbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcbdcdm3 : rk(B :: C :: bc :: bd :: cd :: nil) >= 3).
{
	assert(HBCbdeq : rk(B :: C :: bd :: nil) = 3) by (apply LBCbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbdmtmp : rk(B :: C :: bd :: nil) >= 3) by (solve_hyps_min HBCbdeq HBCbdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: bd :: nil) (B :: C :: bc :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: C :: bd :: nil) (B :: C :: bc :: bd :: cd :: nil) 3 3 HBCbdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBCbcbdcdM3 : rk(B :: C :: bc :: bd :: cd :: nil) <= 3).
{
	assert(HBCbcDbdcdeq : rk(B :: C :: bc :: D :: bd :: cd :: nil) = 3) by (apply LBCbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdcdMtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBCbcDbdcdeq HBCbcDbdcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: C :: bc :: bd :: cd :: nil) (B :: C :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: C :: bc :: bd :: cd :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) 3 3 HBCbcDbdcdMtmp Hcomp Hincl);apply HT.
}

assert(HBCbcbdcdM : rk(B :: C :: bc :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBCbcbdcdm : rk(B :: C :: bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBCbcbdcdeq HBCbcbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour Bbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BbcDbdcd requis par la preuve de (?)Bbcbdcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour BDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm2 : rk(B :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: bd :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBDbdcdM3 : rk(B :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: D :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: D :: bd :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBDbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm3 : rk(B :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDbdcdm2 : rk(B :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDbdcdm3 : rk(B :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 5 et 4*)
assert(HBbcDbdcdM3 : rk(B :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBbcDcdeq : rk(B :: bc :: D :: cd :: nil) = 3) by (apply LBbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcDcdMtmp : rk(B :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBbcDcdeq HBbcDcdM3).
	assert(HBDbdcdMtmp : rk(B :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBDbdcdeq HBDbdcdM3).
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hincl : incl (B :: D :: cd :: nil) (list_inter (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil) ((B :: bc :: D :: cd :: nil) ++ (B :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) (B :: D :: cd :: nil) 3 3 3 HBbcDcdMtmp HBDbdcdMtmp HBDcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Bbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 6  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)OoABCApbcbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcbdcd requis par la preuve de (?)BCbcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcbdcdm2 : rk(B :: C :: bc :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcbdcdeq HOoABCApbcbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcbdcdmtmp;try rewrite HT2 in HOoABCApbcbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Bbcbdcd requis par la preuve de (?)Bbcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcbdcdm2 : rk(B :: bc :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcbdcdmtmp : rk(B :: C :: bc :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcbdcdeq HBCbcbdcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcbdcdmtmp;try rewrite HT2 in HBCbcbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 6 (code, 3 ou 4 dans la thèse) *)
(* marque de l'antécédent : 5 *)
assert(HBbcbdcdM3 : rk(B :: bc :: bd :: cd :: nil) <= 3).
{
	assert(HBbcDbdcdMtmp : rk(B :: bc :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBbcDbdcdeq HBbcDbdcdM3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: bc :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_6 (B :: bc :: bd :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBbcDbdcdMtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 3) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: bd :: cd ::  de rang :  3 et 3 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcbdcdm3 : rk(B :: bc :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcbdcdeq : rk(B :: C :: bc :: bd :: cd :: nil) = 3) by (apply LBCbcbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcbdcdmtmp : rk(B :: C :: bc :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcbdcdeq HBCbcbdcdm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcbdcdmtmp;try rewrite HT2 in HBCbcbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: bd :: cd :: nil) (B :: bc :: nil) 3 2 2 HBCbcbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

assert(HBbcbdcdM : rk(B :: bc :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcbdcdm : rk(B :: bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBbcbdcdeq HBbcbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par Labbcadbdcd *)
(* dans la couche 0 *)
Lemma Labadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ad :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abadbdcd requis par la preuve de (?)abadbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CabDadbdcd requis par la preuve de (?)abadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabDadbdcd requis par la preuve de (?)OoABCabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabDadbdcdm4 : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabDadbdcdm3 : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCabDadbdcdm4 : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCabDadbdcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadbdcdeq HOoABCabDadbdcdm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: B :: C :: D :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadbdcdmtmp;try rewrite HT2 in HOoABCabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCabDadbdcdmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ABCApabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabDadbdcdm2 : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabDadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdcdeq HABCApabDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: D :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdcdmtmp;try rewrite HT2 in HABCApabDadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabDadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabDadbdcdm3 : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabDadbdcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabDadbdcdeq HABCabDadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadbdcdmtmp;try rewrite HT2 in HABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabDadbdcdm4 : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabDadbdcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabDadbdcdeq HABCabDadbdcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadbdcdmtmp;try rewrite HT2 in HABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabDadbdcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm2 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabDadbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm3 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApabDadbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm4 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCabDadbdcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadbdcdeq HOoABCabDadbdcdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadbdcdmtmp;try rewrite HT2 in HOoABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 4 2 2 HOoABCabDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabDadbdcdm2 : rk(C :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabDadbdcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabDadbdcdeq HABCabDadbdcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadbdcdmtmp;try rewrite HT2 in HABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : C :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HCabDadbdcdm3 : rk(C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCabDadbdcdmtmp : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCabDadbdcdeq HOoBCabDadbdcdm4).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: B :: C :: D :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCabDadbdcdmtmp;try rewrite HT2 in HOoBCabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil) (C :: D :: nil) 4 2 3 HOoBCabDadbdcdmtmp HCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCabDadbdcdm4 : rk(C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACabDadbdcdmtmp : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HACabDadbdcdeq HACabDadbdcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabDadbdcdmtmp;try rewrite HT2 in HACabDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HACabDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abadbdcd requis par la preuve de (?)abadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabadbdcd requis par la preuve de (?)abadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabadbdcd requis par la preuve de (?)ABabadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabadbdcd requis par la preuve de (?)ABabadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabadbdcd requis par la preuve de (?)OoABApabadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabadbdcd requis par la preuve de (?)OoABApabadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdcdm2 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabadbdcdm3 : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabadbdcd requis par la preuve de (?)ABabadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabadbdcdm2 : rk(A :: B :: ab :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabadbdcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabadbdcdeq HOoABApabadbdcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabadbdcdmtmp;try rewrite HT2 in HOoABApabadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: ad :: bd :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApabadbdcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabadbdcdm3 : rk(A :: B :: ab :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABadeq : rk(A :: B :: ad :: nil) = 3) by (apply LABad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadmtmp : rk(A :: B :: ad :: nil) >= 3) by (solve_hyps_min HABadeq HABadm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ad :: nil) (A :: B :: ab :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ad :: nil) (A :: B :: ab :: ad :: bd :: cd :: nil) 3 3 HABadmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abadbdcd requis par la preuve de (?)abadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: ab :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab :: ad ::  de rang :  2 et 2 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(Habadbdcdm2 : rk(ab :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABabadbdcdmtmp : rk(A :: B :: ab :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABabadbdcdeq HABabadbdcdm3).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (ab :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: ad :: bd :: cd :: nil) (A :: B :: ab :: ad :: ab :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: ab :: ad :: bd :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (ab :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabadbdcdmtmp;try rewrite HT2 in HABabadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (ab :: ad :: bd :: cd :: nil) (ab :: ad :: nil) 3 2 3 HABabadbdcdmtmp Habadmtmp HABabadMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Habadbdcdm3 : rk(ab :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCabDadbdcdmtmp : rk(C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCabDadbdcdeq HCabDadbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ab :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ab :: D :: ad :: bd :: cd :: nil) (C :: D :: cd :: ab :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ab :: ad :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (ab :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCabDadbdcdmtmp;try rewrite HT2 in HCabDadbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ab :: ad :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCabDadbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -2 et 5*)
assert(HabadbdcdM3 : rk(ab :: ad :: bd :: cd :: nil) <= 3).
{
	assert(Habadbdeq : rk(ab :: ad :: bd :: nil) = 2) by (apply Labadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabadbdMtmp : rk(ab :: ad :: bd :: nil) <= 2) by (solve_hyps_max Habadbdeq HabadbdM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (ab :: ad :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ad :: bd :: cd :: nil) (ab :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: bd :: cd :: nil) ((ab :: ad :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ad :: bd :: nil) (cd :: nil) (nil) 2 1 0 HabadbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HabadbdcdM : rk(ab :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habadbdcdm : rk(ab :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Habadbdcdeq Habadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: bc :: ad :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abbcadbdcd requis par la preuve de (?)abbcadbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour CabbcDadbdcd requis par la preuve de (?)abbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ACabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabbcDadbdcd requis par la preuve de (?)OoABCabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabbcDadbdcdm4 : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)OoABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadbdcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCabbcDadbdcdm4 : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabbcDadbdcdeq HOoABCabbcDadbdcdm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabbcDadbdcdmtmp;try rewrite HT2 in HOoABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCabbcDadbdcdmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ABCApabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabbcDadbdcdm2 : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabbcDadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabbcDadbdcdeq HABCApabbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabbcDadbdcdmtmp;try rewrite HT2 in HABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabbcDadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcDadbdcdm3 : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabbcDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabbcDadbdcdm4 : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabbcDadbdcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabbcDadbdcd requis par la preuve de (?)BCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabbcDadbdcd requis par la preuve de (?)BCabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabbcDadbdcdm2 : rk(B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabbcDadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabbcDadbdcdm3 : rk(B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabbcDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabbcDadbdcdm2 : rk(C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabbcDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCabbcDadbdcdm3 : rk(C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCabbcDadbdcdmtmp : rk(B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCabbcDadbdcdeq HBCabbcDadbdcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: C :: bc :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabbcDadbdcdmtmp;try rewrite HT2 in HBCabbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCabbcDadbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCabbcDadbdcdm4 : rk(C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACabbcDadbdcdmtmp : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HACabbcDadbdcdeq HACabbcDadbdcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabbcDadbdcdmtmp;try rewrite HT2 in HACabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HACabbcDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abbcadbdcd requis par la preuve de (?)abbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabbcadbdcd requis par la preuve de (?)abbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcadbdcd requis par la preuve de (?)BCabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcadbdcd requis par la preuve de (?)ABCabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcadbdcd requis par la preuve de (?)OoABCApabbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcadbdcd requis par la preuve de (?)ABCabbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcadbdcdm3 : rk(A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcadbdcdeq HOoABCApabbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcadbdcdmtmp;try rewrite HT2 in HOoABCApabbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabbcadbdcd requis par la preuve de (?)BCabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabbcadbdcd requis par la preuve de (?)BCabbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabbcadbdcdm2 : rk(B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcadbdcdeq HOoABCApabbcadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcadbdcdmtmp;try rewrite HT2 in HOoABCApabbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabbcadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabbcadbdcdm3 : rk(B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcadbdcdeq HABCabbcadbdcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcadbdcdmtmp;try rewrite HT2 in HABCabbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabbcadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abbcadbdcd requis par la preuve de (?)abbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : bc ::  de rang :  1 et 1 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(Habbcadbdcdm2 : rk(ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCabbcadbdcdmtmp : rk(B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCabbcadbdcdeq HBCabbcadbdcdm3).
	assert(Hbcmtmp : rk(bc :: nil) >= 1) by (solve_hyps_min Hbceq Hbcm1).
	assert(Hincl : incl (bc :: nil) (list_inter (B :: C :: bc :: nil) (ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (B :: C :: bc :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: ab :: bc :: ad :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabbcadbdcdmtmp;try rewrite HT2 in HBCabbcadbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (ab :: bc :: ad :: bd :: cd :: nil) (bc :: nil) 3 1 2 HBCabbcadbdcdmtmp Hbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Habbcadbdcdm3 : rk(ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCabbcDadbdcdmtmp : rk(C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HCabbcDadbdcdeq HCabbcDadbdcdm4).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (C :: D :: cd :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: ab :: bc :: ad :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCabbcDadbdcdmtmp;try rewrite HT2 in HCabbcDadbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (ab :: bc :: ad :: bd :: cd :: nil) (cd :: nil) 4 1 2 HCabbcDadbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HabbcadbdcdM3 : rk(ab :: bc :: ad :: bd :: cd :: nil) <= 3).
{
	assert(Habbcadcdeq : rk(ab :: bc :: ad :: cd :: nil) = 3) by (apply Labbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabbcadcdMtmp : rk(ab :: bc :: ad :: cd :: nil) <= 3) by (solve_hyps_max Habbcadcdeq HabbcadcdM3).
	assert(Habadbdcdeq : rk(ab :: ad :: bd :: cd :: nil) = 3) by (apply Labadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabadbdcdMtmp : rk(ab :: ad :: bd :: cd :: nil) <= 3) by (solve_hyps_max Habadbdcdeq HabadbdcdM3).
	assert(Habadcdeq : rk(ab :: ad :: cd :: nil) = 3) by (apply Labadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadcdmtmp : rk(ab :: ad :: cd :: nil) >= 3) by (solve_hyps_min Habadcdeq Habadcdm3).
	assert(Hincl : incl (ab :: ad :: cd :: nil) (list_inter (ab :: bc :: ad :: cd :: nil) (ab :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: bc :: ad :: bd :: cd :: nil) (ab :: bc :: ad :: cd :: ab :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: bc :: ad :: cd :: ab :: ad :: bd :: cd :: nil) ((ab :: bc :: ad :: cd :: nil) ++ (ab :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: bc :: ad :: cd :: nil) (ab :: ad :: bd :: cd :: nil) (ab :: ad :: cd :: nil) 3 3 3 HabbcadcdMtmp HabadbdcdMtmp Habadcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HabbcadbdcdM : rk(ab :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habbcadbdcdm : rk(ab :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Habbcadbdcdeq Habbcadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par Lbcbdcd *)
(* dans constructLemma(), requis par LBabbcadbdcd *)
(* dans la couche 0 *)
Lemma LABabbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: ab :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABabbcadbdcd requis par la preuve de (?)ABabbcadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabbcadbdcd requis par la preuve de (?)ABabbcadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabbcadbdcd requis par la preuve de (?)ABabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabbcadbdcd requis par la preuve de (?)OoABApabbcadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabbcadbdcd requis par la preuve de (?)OoABApabbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabbcadbdcdm2 : rk(Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabbcadbdcdm3 : rk(Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabbcadbdcd requis par la preuve de (?)ABabbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabbcadbdcdm2 : rk(A :: B :: ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabbcadbdcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabbcadbdcdeq HOoABApabbcadbdcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabbcadbdcdmtmp;try rewrite HT2 in HOoABApabbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApabbcadbdcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabbcadbdcdm3 : rk(A :: B :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABbceq : rk(A :: B :: bc :: nil) = 3) by (apply LABbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABbcmtmp : rk(A :: B :: bc :: nil) >= 3) by (solve_hyps_min HABbceq HABbcm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: bc :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: bc :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil) 3 3 HABbcmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABabbcadbdcdm4 : rk(A :: B :: ab :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABadcdeq : rk(A :: B :: ad :: cd :: nil) = 4) by (apply LABadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABadcdmtmp : rk(A :: B :: ad :: cd :: nil) >= 4) by (solve_hyps_min HABadcdeq HABadcdm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: ad :: cd :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: ad :: cd :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil) 4 4 HABadcdmtmp Hcomp Hincl);apply HT.
}

assert(HABabbcadbdcdM : rk(A :: B :: ab :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABabbcadbdcdm : rk(A :: B :: ab :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABabbcadbdcdeq HABabbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBabbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: ab :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour Babbcadbdcd requis par la preuve de (?)Babbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabbcadbdcd requis par la preuve de (?)Babbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcadbdcd requis par la preuve de (?)BCabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcadbdcd requis par la preuve de (?)ABCabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcadbdcd requis par la preuve de (?)OoABCApabbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcadbdcd requis par la preuve de (?)ABCabbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcadbdcdm3 : rk(A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcadbdcdeq HOoABCApabbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcadbdcdmtmp;try rewrite HT2 in HOoABCApabbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabbcadbdcd requis par la preuve de (?)BCabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabbcadbdcd requis par la preuve de (?)BCabbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabbcadbdcdm2 : rk(B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcadbdcdeq HOoABCApabbcadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcadbdcdmtmp;try rewrite HT2 in HOoABCApabbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabbcadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabbcadbdcdm3 : rk(B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcadbdcdeq HABCabbcadbdcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcadbdcdmtmp;try rewrite HT2 in HABCabbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabbcadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour Babbcadbdcd requis par la preuve de (?)Babbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABabbcadbdcd requis par la preuve de (?)Babbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoABApabbcadbdcd requis par la preuve de (?)ABabbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoABApabbcadbdcd requis par la preuve de (?)OoABApabbcadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABApabbcadbdcd requis par la preuve de (?)OoABApabbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabbcadbdcdm2 : rk(Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABApabbcadbdcdm3 : rk(Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABApmtmp : rk(A :: B :: Ap :: nil) >= 3) by (solve_hyps_min HABApeq HABApm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: Ap :: nil) (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) 3 3 HABApmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABabbcadbdcd requis par la preuve de (?)ABabbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et 4*)
(* ensembles concernés AUB : Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: B ::  de rang :  2 et 2 	 A : Oo :: A :: B :: Ap ::   de rang : 3 et 3 *)
assert(HABabbcadbdcdm2 : rk(A :: B :: ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoABApeq : rk(Oo :: A :: B :: Ap :: nil) = 3) by (apply LOoABAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABApMtmp : rk(Oo :: A :: B :: Ap :: nil) <= 3) by (solve_hyps_max HOoABApeq HOoABApM3).
	assert(HOoABApabbcadbdcdmtmp : rk(Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HOoABApabbcadbdcdeq HOoABApabbcadbdcdm3).
	assert(HABeq : rk(A :: B :: nil) = 2) by (apply LAB with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABmtmp : rk(A :: B :: nil) >= 2) by (solve_hyps_min HABeq HABm2).
	assert(Hincl : incl (A :: B :: nil) (list_inter (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: B :: Ap :: A :: B :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: B :: Ap :: A :: B :: ab :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: B :: Ap :: nil) ++ (A :: B :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABApabbcadbdcdmtmp;try rewrite HT2 in HOoABApabbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: B :: Ap :: nil) (A :: B :: ab :: bc :: ad :: bd :: cd :: nil) (A :: B :: nil) 3 2 3 HOoABApabbcadbdcdmtmp HABmtmp HOoABApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour Babbcadbdcd requis par la preuve de (?)Babbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: bc :: ad :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabbcadbdcdm2 : rk(B :: ab :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabbcadbdcdmtmp : rk(A :: B :: ab :: bc :: ad :: bd :: cd :: nil) >= 2) by (solve_hyps_min HABabbcadbdcdeq HABabbcadbdcdm2).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabbcadbdcdmtmp;try rewrite HT2 in HABabbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: bc :: ad :: bd :: cd :: nil) (B :: ab :: nil) 2 2 2 HABabbcadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBabbcadbdcdm3 : rk(B :: ab :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCabbcadbdcdmtmp : rk(B :: C :: ab :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCabbcadbdcdeq HBCabbcadbdcdm3).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: bc :: ad :: bd :: cd :: nil) (B :: C :: bc :: B :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: ab :: bc :: ad :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabbcadbdcdmtmp;try rewrite HT2 in HBCabbcadbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: ab :: bc :: ad :: bd :: cd :: nil) (B :: bc :: nil) 3 2 2 HBCabbcadbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: B :: ab :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBabbcadbdcdm4 : rk(B :: ab :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABabbcadbdcdeq : rk(A :: B :: ab :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LABabbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabbcadbdcdmtmp : rk(A :: B :: ab :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABabbcadbdcdeq HABabbcadbdcdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: ab :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: ab :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABabbcadbdcdmtmp;try rewrite HT2 in HABabbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: ab :: bc :: ad :: bd :: cd :: nil) (B :: ab :: nil) 4 2 2 HABabbcadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HBabbcadbdcdM : rk(B :: ab :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBabbcadbdcdm : rk(B :: ab :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBabbcadbdcdeq HBabbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Lbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(bc :: bd :: cd ::  nil) = 2.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 3  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 3 pour CbcDbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdeq : rk(B :: C :: bc :: D :: bd :: cd :: nil) = 3) by (apply LBCbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 3 pour bcbdcd requis par la preuve de (?)bcbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 3) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : cd ::  de rang :  1 et 1 	 A : C :: D :: cd ::   de rang : 2 et 2 *)
assert(Hbcbdcdm2 : rk(bc :: bd :: cd :: nil) >= 2).
{
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCbcDbdcdmtmp : rk(C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm3).
	assert(Hcdmtmp : rk(cd :: nil) >= 1) by (solve_hyps_min Hcdeq Hcdm1).
	assert(Hincl : incl (cd :: nil) (list_inter (C :: D :: cd :: nil) (bc :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: D :: cd :: bc :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: D :: cd :: bc :: bd :: cd :: nil) ((C :: D :: cd :: nil) ++ (bc :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HCbcDbdcdmtmp;try rewrite HT2 in HCbcDbdcdmtmp.
	assert(HT := rule_4 (C :: D :: cd :: nil) (bc :: bd :: cd :: nil) (cd :: nil) 3 1 2 HCbcDbdcdmtmp Hcdmtmp HCDcdMtmp Hincl); apply HT.
}

(* Application de la règle 3 code (6 dans la thèse) *)
(* marque des antécédents A B AUB: 4 4 et 4*)
assert(HbcbdcdM2 : rk(bc :: bd :: cd :: nil) <= 2).
{
	assert(HBbcbdcdeq : rk(B :: bc :: bd :: cd :: nil) = 3) by (apply LBbcbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcbdcdMtmp : rk(B :: bc :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBbcbdcdeq HBbcbdcdM3).
	assert(Habbcadbdcdeq : rk(ab :: bc :: ad :: bd :: cd :: nil) = 3) by (apply Labbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabbcadbdcdMtmp : rk(ab :: bc :: ad :: bd :: cd :: nil) <= 3) by (solve_hyps_max Habbcadbdcdeq HabbcadbdcdM3).
	assert(HBabbcadbdcdeq : rk(B :: ab :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LBabbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabbcadbdcdmtmp : rk(B :: ab :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HBabbcadbdcdeq HBabbcadbdcdm4).
	assert(Hincl : incl (bc :: bd :: cd :: nil) (list_inter (B :: bc :: bd :: cd :: nil) (ab :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: ab :: bc :: ad :: bd :: cd :: nil) (B :: bc :: bd :: cd :: ab :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: bd :: cd :: ab :: bc :: ad :: bd :: cd :: nil) ((B :: bc :: bd :: cd :: nil) ++ (ab :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBabbcadbdcdmtmp;try rewrite HT2 in HBabbcadbdcdmtmp.
	assert(HT := rule_3 (B :: bc :: bd :: cd :: nil) (ab :: bc :: ad :: bd :: cd :: nil) (bc :: bd :: cd :: nil) 3 3 4 HBbcbdcdMtmp HabbcadbdcdMtmp HBabbcadbdcdmtmp Hincl);apply HT.
}


assert(HbcbdcdM : rk(bc :: bd :: cd ::  nil) <= 3) (* dim : 3 *) by (solve_hyps_max Hbcbdcdeq HbcbdcdM3).
assert(Hbcbdcdm : rk(bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Hbcbdcdeq Hbcbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcbdcd requis par la preuve de (?)OoABCApbcbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcbdcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcbdcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcbdcdeq HOoABCApbcbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 3 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BDbdcd requis par la preuve de (?)BDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm2 : rk(B :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBDeq : rk(B :: D :: nil) = 2) by (apply LBD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDmtmp : rk(B :: D :: nil) >= 2) by (solve_hyps_min HBDeq HBDm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (B :: D :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: nil) (B :: D :: bd :: cd :: nil) 2 2 HBDmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : -4 -2 et 5*)
assert(HBDbdcdM3 : rk(B :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HcdMtmp : rk(cd :: nil) <= 1) by (solve_hyps_max Hcdeq HcdM1).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: D :: bd :: nil) (cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: D :: bd :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: D :: bd :: nil) (cd :: nil) (nil) 2 1 0 HBDbdMtmp HcdMtmp Hmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBDbdcdm3 : rk(B :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

assert(HBDbdcdM : rk(B :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBDbdcdm : rk(B :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBDbdcdeq HBDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LBbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(B :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BbcDbdcd requis par la preuve de (?)BbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : B :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HBbcDbdcdm2 : rk(B :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HBbceq : rk(B :: bc :: nil) = 2) by (apply LBbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcmtmp : rk(B :: bc :: nil) >= 2) by (solve_hyps_min HBbceq HBbcm2).
	assert(Hincl : incl (B :: bc :: nil) (list_inter (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: B :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (B :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HBbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HBbcDbdcdm3 : rk(B :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hcomp : 3 <= 3) by (repeat constructor).
	assert(Hincl : incl (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (B :: D :: cd :: nil) (B :: bc :: D :: bd :: cd :: nil) 3 3 HBDcdmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HBbcDbdcdM3 : rk(B :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HBbcDcdeq : rk(B :: bc :: D :: cd :: nil) = 3) by (apply LBbcDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBbcDcdMtmp : rk(B :: bc :: D :: cd :: nil) <= 3) by (solve_hyps_max HBbcDcdeq HBbcDcdM3).
	assert(HBDbdcdeq : rk(B :: D :: bd :: cd :: nil) = 3) by (apply LBDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDbdcdMtmp : rk(B :: D :: bd :: cd :: nil) <= 3) by (solve_hyps_max HBDbdcdeq HBDbdcdM3).
	assert(HBDcdeq : rk(B :: D :: cd :: nil) = 3) by (apply LBDcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBDcdmtmp : rk(B :: D :: cd :: nil) >= 3) by (solve_hyps_min HBDcdeq HBDcdm3).
	assert(Hincl : incl (B :: D :: cd :: nil) (list_inter (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: bc :: D :: bd :: cd :: nil) (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: bc :: D :: cd :: B :: D :: bd :: cd :: nil) ((B :: bc :: D :: cd :: nil) ++ (B :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (B :: bc :: D :: cd :: nil) (B :: D :: bd :: cd :: nil) (B :: D :: cd :: nil) 3 3 3 HBbcDcdMtmp HBDbdcdMtmp HBDcdmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HBbcDbdcdM : rk(B :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HBbcDbdcdm : rk(B :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HBbcDbdcdeq HBbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: bc :: D :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCbcDbdcd requis par la preuve de (?)BCbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCbcDbdcdm2 : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApbcDbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: bc :: D :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApbcDbdcdmtmp;try rewrite HT2 in HOoABCApbcDbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: bc :: D :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApbcDbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CbcDbdcd requis par la preuve de (?)CbcDbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  2 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm2 : rk(C :: bc :: D :: bd :: cd :: nil) >= 2).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 2) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm2).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: bc :: D :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: nil) 2 2 2 HBCbcDbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : B :: C :: bc :: D :: bd :: cd ::  de rang :  3 et 3 	 AiB : D :: bd ::  de rang :  2 et 2 	 A : B :: D :: bd ::   de rang : 2 et 2 *)
assert(HCbcDbdcdm3 : rk(C :: bc :: D :: bd :: cd :: nil) >= 3).
{
	assert(HBDbdMtmp : rk(B :: D :: bd :: nil) <= 2) by (solve_hyps_max HBDbdeq HBDbdM2).
	assert(HBCbcDbdcdeq : rk(B :: C :: bc :: D :: bd :: cd :: nil) = 3) by (apply LBCbcDbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCbcDbdcdmtmp : rk(B :: C :: bc :: D :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCbcDbdcdeq HBCbcDbdcdm3).
	assert(HDbdeq : rk(D :: bd :: nil) = 2) by (apply LDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDbdmtmp : rk(D :: bd :: nil) >= 2) by (solve_hyps_min HDbdeq HDbdm2).
	assert(Hincl : incl (D :: bd :: nil) (list_inter (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: bc :: D :: bd :: cd :: nil) (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: D :: bd :: C :: bc :: D :: bd :: cd :: nil) ((B :: D :: bd :: nil) ++ (C :: bc :: D :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCbcDbdcdmtmp;try rewrite HT2 in HBCbcDbdcdmtmp.
	assert(HT := rule_4 (B :: D :: bd :: nil) (C :: bc :: D :: bd :: cd :: nil) (D :: bd :: nil) 3 2 2 HBCbcDbdcdmtmp HDbdmtmp HBDbdMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 -4 et 4*)
assert(HCbcDbdcdM3 : rk(C :: bc :: D :: bd :: cd :: nil) <= 3).
{
	assert(HCbcDbdeq : rk(C :: bc :: D :: bd :: nil) = 3) by (apply LCbcDbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcDbdMtmp : rk(C :: bc :: D :: bd :: nil) <= 3) by (solve_hyps_max HCbcDbdeq HCbcDbdM3).
	assert(HCDcdMtmp : rk(C :: D :: cd :: nil) <= 2) by (solve_hyps_max HCDcdeq HCDcdM2).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (C :: bc :: D :: bd :: cd :: nil) (C :: bc :: D :: bd :: C :: D :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (C :: bc :: D :: bd :: C :: D :: cd :: nil) ((C :: bc :: D :: bd :: nil) ++ (C :: D :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (C :: bc :: D :: bd :: nil) (C :: D :: cd :: nil) (C :: D :: nil) 3 2 2 HCbcDbdMtmp HCDcdMtmp HCDmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HCbcDbdcdM : rk(C :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCbcDbdcdm : rk(C :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCbcDbdcdeq HCbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApbcDbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApbcDbdcd requis par la preuve de (?)OoABCApbcDbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApbcDbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApbcDbdcdM : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApbcDbdcdm : rk(Oo :: A :: B :: C :: Ap :: bc :: D :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApbcDbdcdeq HOoABCApbcDbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoABCApabbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcadbdcd requis par la preuve de (?)OoABCApabbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabbcadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabbcadbdcdeq HOoABCApabbcadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LACabacbcadbdcd *)
(* dans la couche 0 *)
Lemma LABCabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 5  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)OoABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : 4 *)
assert(HABCabacbcadbdcdm4 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABCadeq : rk(A :: B :: C :: ad :: nil) = 4) by (apply LABCad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCadmtmp : rk(A :: B :: C :: ad :: nil) >= 4) by (solve_hyps_min HABCadeq HABCadm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: B :: C :: ad :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HABCadmtmp Hcomp Hincl);apply HT.
}

assert(HABCabacbcadbdcdM : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabacbcadbdcdm : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCabacbcadbdcdeq HABCabacbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)OoABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadbdcd requis par la preuve de (?)ABCApabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadbdcd requis par la preuve de (?)ABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabacbcadbdcdeq HABCApabacbcadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcadbdcdmtmp;try rewrite HT2 in HABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabacbcadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadbdcdeq HABCabacbcadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadbdcdmtmp;try rewrite HT2 in HABCabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabacbcadbdcdm4 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabacbcadbdcdeq : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LABCabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabacbcadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabacbcadbdcdeq HABCabacbcadbdcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadbdcdmtmp;try rewrite HT2 in HABCabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabacbcadbdcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HACabacbcadbdcdM : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabacbcadbdcdm : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HACabacbcadbdcdeq HACabacbcadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabacbcadbdcd *)
(* dans la couche 0 *)
Lemma LOoABCApabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabacbcadbdcd requis par la preuve de (?)OoABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabacbcadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabacbcadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabacbcadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabacbcadbdcd requis par la preuve de (?)ABCApabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabacbcadbdcd requis par la preuve de (?)ABCApabacbcadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabacbcadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabacbcadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabacbcadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabacbcadbdcdM : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabacbcadbdcdm : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabacbcadbdcdeq HABCApabacbcadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCabDadbdcd *)
(* dans constructLemma(), requis par LACabDadbdcd *)
(* dans constructLemma(), requis par LABCabDadbdcd *)
(* dans la couche 0 *)
Lemma LOoABCabDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabDadbdcd requis par la preuve de (?)OoABCabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabDadbdcdm4 : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabDadbdcdM : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabDadbdcdm : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCabDadbdcdeq HOoABCabDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCabDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabDadbdcdm3 : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCabDadbdcdm4 : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCabDadbdcdeq : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCabDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDadbdcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadbdcdeq HOoABCabDadbdcdm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: B :: C :: D :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadbdcdmtmp;try rewrite HT2 in HOoABCabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCabDadbdcdmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HABCabDadbdcdM : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabDadbdcdm : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCabDadbdcdeq HABCabDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabDadbdcdm3 : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ABCApabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabDadbdcd requis par la preuve de (?)ACabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabDadbdcdm2 : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabDadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabDadbdcdeq HABCApabDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: D :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabDadbdcdmtmp;try rewrite HT2 in HABCApabDadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabDadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabDadbdcdm3 : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabDadbdcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabDadbdcdeq HABCabDadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadbdcdmtmp;try rewrite HT2 in HABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabDadbdcdm4 : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabDadbdcdeq : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) = 4) by (apply LABCabDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabDadbdcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabDadbdcdeq HABCabDadbdcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadbdcdmtmp;try rewrite HT2 in HABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabDadbdcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HACabDadbdcdM : rk(A :: C :: ab :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabDadbdcdm : rk(A :: C :: ab :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HACabDadbdcdeq HACabDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCabDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ab :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm2 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabDadbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm3 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApabDadbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm4 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCabDadbdcdeq : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCabDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDadbdcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadbdcdeq HOoABCabDadbdcdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadbdcdmtmp;try rewrite HT2 in HOoABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 4 2 2 HOoABCabDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabDadbdcd requis par la preuve de (?)ABCabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabDadbdcdm3 : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabDadbdcd requis par la preuve de (?)CabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabDadbdcdm2 : rk(C :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabDadbdcdmtmp : rk(A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabDadbdcdeq HABCabDadbdcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabDadbdcdmtmp;try rewrite HT2 in HABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : Oo :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : C :: D ::  de rang :  2 et 2 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HCabDadbdcdm3 : rk(C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoBCabDadbdcdmtmp : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoBCabDadbdcdeq HOoBCabDadbdcdm4).
	assert(HCDeq : rk(C :: D :: nil) = 2) by (apply LCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCDmtmp : rk(C :: D :: nil) >= 2) by (solve_hyps_min HCDeq HCDm2).
	assert(Hincl : incl (C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: B :: C :: D :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoBCabDadbdcdmtmp;try rewrite HT2 in HOoBCabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil) (C :: D :: nil) 4 2 3 HOoBCabDadbdcdmtmp HCDmtmp HOoBCDMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCabDadbdcdm4 : rk(C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACabDadbdcdeq : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) = 4) by (apply LACabDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabDadbdcdmtmp : rk(A :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HACabDadbdcdeq HACabDadbdcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabDadbdcdmtmp;try rewrite HT2 in HACabDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ab :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HACabDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

assert(HCabDadbdcdM : rk(C :: ab :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCabDadbdcdm : rk(C :: ab :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCabDadbdcdeq HCabDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LOoBCabDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoBCabDadbdcd requis par la preuve de (?)OoBCabDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm2 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApMtmp : rk(A :: Ap :: nil) <= 2) by (solve_hyps_max HAApeq HAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabDadbdcdmtmp Hmtmp HAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : Oo ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm3 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HOomtmp : rk(Oo :: nil) >= 1) by (solve_hyps_min HOoeq HOom1).
	assert(Hincl : incl (Oo :: nil) (list_inter (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: nil) 4 1 2 HOoABCApabDadbdcdmtmp HOomtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HOoBCabDadbdcdm4 : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HOoABCabDadbdcdeq : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCabDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabDadbdcdmtmp : rk(Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabDadbdcdeq HOoABCabDadbdcdm4).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabDadbdcdmtmp;try rewrite HT2 in HOoABCabDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (Oo :: B :: C :: ab :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 4 2 2 HOoABCabDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

assert(HOoBCabDadbdcdM : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoBCabDadbdcdm : rk(Oo :: B :: C :: ab :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoBCabDadbdcdeq HOoBCabDadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabDadbdcd *)
(* dans la couche 0 *)
Lemma LOoABCApabDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabDadbdcd requis par la preuve de (?)OoABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabDadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabDadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ABCApabDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabDadbdcd requis par la preuve de (?)ABCApabDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabDadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabDadbdcdeq HOoABCApabDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabDadbdcdmtmp;try rewrite HT2 in HOoABCApabDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabDadbdcdM : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabDadbdcdm : rk(A :: B :: C :: Ap :: ab :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabDadbdcdeq HABCApabDadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LCabbcDadbdcd *)
(* dans constructLemma(), requis par LACabbcDadbdcd *)
(* dans constructLemma(), requis par LABCabbcDadbdcd *)
(* dans la couche 0 *)
Lemma LOoABCabbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCabbcDadbdcd requis par la preuve de (?)OoABCabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCabbcDadbdcdm4 : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCabbcDadbdcdM : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCabbcDadbdcdm : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCabbcDadbdcdeq HOoABCabbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCabbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)OoABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadbdcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : B :: C :: D ::  de rang :  3 et 3 	 A : Oo :: B :: C :: D ::   de rang : 3 et 3 *)
assert(HABCabbcDadbdcdm4 : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoBCDMtmp : rk(Oo :: B :: C :: D :: nil) <= 3) by (solve_hyps_max HOoBCDeq HOoBCDM3).
	assert(HOoABCabbcDadbdcdeq : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCabbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCabbcDadbdcdeq HOoABCabbcDadbdcdm4).
	assert(HBCDeq : rk(B :: C :: D :: nil) = 3) by (apply LBCD with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBCDmtmp : rk(B :: C :: D :: nil) >= 3) by (solve_hyps_min HBCDeq HBCDm3).
	assert(Hincl : incl (B :: C :: D :: nil) (list_inter (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: B :: C :: D :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: B :: C :: D :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCabbcDadbdcdmtmp;try rewrite HT2 in HOoABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: B :: C :: D :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: C :: D :: nil) 4 3 3 HOoABCabbcDadbdcdmtmp HBCDmtmp HOoBCDMtmp Hincl); apply HT.
}

assert(HABCabbcDadbdcdM : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCabbcDadbdcdm : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LACabbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)OoABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadbdcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ABCApabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 5 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabbcDadbdcd requis par la preuve de (?)ACabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabbcDadbdcdm2 : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabbcDadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabbcDadbdcdeq HABCApabbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabbcDadbdcdmtmp;try rewrite HT2 in HABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabbcDadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabbcDadbdcdm3 : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabbcDadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: ab :: ad ::  de rang :  3 et 3 	 A : A :: B :: ab :: ad ::   de rang : 3 et 3 *)
assert(HACabbcDadbdcdm4 : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HABabadeq : rk(A :: B :: ab :: ad :: nil) = 3) by (apply LABabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABabadMtmp : rk(A :: B :: ab :: ad :: nil) <= 3) by (solve_hyps_max HABabadeq HABabadM3).
	assert(HABCabbcDadbdcdeq : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LABCabbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm4).
	assert(HAabadeq : rk(A :: ab :: ad :: nil) = 3) by (apply LAabad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabadmtmp : rk(A :: ab :: ad :: nil) >= 3) by (solve_hyps_min HAabadeq HAabadm3).
	assert(Hincl : incl (A :: ab :: ad :: nil) (list_inter (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: ad :: A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: ad :: nil) ++ (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: ad :: nil) (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: ab :: ad :: nil) 4 3 3 HABCabbcDadbdcdmtmp HAabadmtmp HABabadMtmp Hincl); apply HT.
}

assert(HACabbcDadbdcdM : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HACabbcDadbdcdm : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HACabbcDadbdcdeq HACabbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LCabbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour CabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour BCabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)BCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 4 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)OoABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabbcDadbdcd requis par la preuve de (?)ABCabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabbcDadbdcdm3 : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabbcDadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour BCabbcDadbdcd requis par la preuve de (?)BCabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour BCabbcDadbdcd requis par la preuve de (?)BCabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -1 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HBCabbcDadbdcdm2 : rk(B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (nil) 4 0 2 HOoABCApabbcDadbdcdmtmp Hmtmp HOoAApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : B :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HBCabbcDadbdcdm3 : rk(B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm3).
	assert(HBabeq : rk(B :: ab :: nil) = 2) by (apply LBab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBabmtmp : rk(B :: ab :: nil) >= 2) by (solve_hyps_min HBabeq HBabm2).
	assert(Hincl : incl (B :: ab :: nil) (list_inter (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: ab :: nil) 3 2 2 HABCabbcDadbdcdmtmp HBabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour CabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour CabbcDadbdcd requis par la preuve de (?)CabbcDadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ab ::  de rang :  1 et 1 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HCabbcDadbdcdm2 : rk(C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabbcDadbdcdmtmp : rk(A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabbcDadbdcdeq HABCabbcDadbdcdm3).
	assert(Habmtmp : rk(ab :: nil) >= 1) by (solve_hyps_min Habeq Habm1).
	assert(Hincl : incl (ab :: nil) (list_inter (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: B :: ab :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabbcDadbdcdmtmp;try rewrite HT2 in HABCabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (ab :: nil) 3 1 2 HABCabbcDadbdcdmtmp Habmtmp HABabMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : B :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : C :: bc ::  de rang :  2 et 2 	 A : B :: C :: bc ::   de rang : 2 et 2 *)
assert(HCabbcDadbdcdm3 : rk(C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HBCbcMtmp : rk(B :: C :: bc :: nil) <= 2) by (solve_hyps_max HBCbceq HBCbcM2).
	assert(HBCabbcDadbdcdmtmp : rk(B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HBCabbcDadbdcdeq HBCabbcDadbdcdm3).
	assert(HCbceq : rk(C :: bc :: nil) = 2) by (apply LCbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HCbcmtmp : rk(C :: bc :: nil) >= 2) by (solve_hyps_min HCbceq HCbcm2).
	assert(Hincl : incl (C :: bc :: nil) (list_inter (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (B :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (B :: C :: bc :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: C :: bc :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((B :: C :: bc :: nil) ++ (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HBCabbcDadbdcdmtmp;try rewrite HT2 in HBCabbcDadbdcdmtmp.
	assert(HT := rule_4 (B :: C :: bc :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (C :: bc :: nil) 3 2 2 HBCabbcDadbdcdmtmp HCbcmtmp HBCbcMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : D :: ad ::  de rang :  2 et 2 	 A : A :: D :: ad ::   de rang : 2 et 2 *)
assert(HCabbcDadbdcdm4 : rk(C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HADadMtmp : rk(A :: D :: ad :: nil) <= 2) by (solve_hyps_max HADadeq HADadM2).
	assert(HACabbcDadbdcdeq : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LACabbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabbcDadbdcdmtmp : rk(A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HACabbcDadbdcdeq HACabbcDadbdcdm4).
	assert(HDadeq : rk(D :: ad :: nil) = 2) by (apply LDad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HDadmtmp : rk(D :: ad :: nil) >= 2) by (solve_hyps_min HDadeq HDadm2).
	assert(Hincl : incl (D :: ad :: nil) (list_inter (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: D :: ad :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: D :: ad :: C :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((A :: D :: ad :: nil) ++ (C :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabbcDadbdcdmtmp;try rewrite HT2 in HACabbcDadbdcdmtmp.
	assert(HT := rule_4 (A :: D :: ad :: nil) (C :: ab :: bc :: D :: ad :: bd :: cd :: nil) (D :: ad :: nil) 4 2 2 HACabbcDadbdcdmtmp HDadmtmp HADadMtmp Hincl); apply HT.
}

assert(HCabbcDadbdcdM : rk(C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HCabbcDadbdcdm : rk(C :: ab :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HCabbcDadbdcdeq HCabbcDadbdcdm1).
intuition.
Qed.

(* dans constructLemma(), requis par LABCApabbcDadbdcd *)
(* dans la couche 0 *)
Lemma LOoABCApabbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour OoABCApabbcDadbdcd requis par la preuve de (?)OoABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HOoABCApabbcDadbdcdm4 : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoABCmtmp : rk(Oo :: A :: B :: C :: nil) >= 4) by (solve_hyps_min HOoABCeq HOoABCm4).
	assert(Hcomp : 4 <= 4) by (repeat constructor).
	assert(Hincl : incl (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (Oo :: A :: B :: C :: nil) (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 4 4 HOoABCmtmp Hcomp Hincl);apply HT.
}

assert(HOoABCApabbcDadbdcdM : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HOoABCApabbcDadbdcdm : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma LABCApabbcDadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  nil) = 4.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ABCApabbcDadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCApabbcDadbdcd requis par la preuve de (?)ABCApabbcDadbdcd pour la règle 5  *)
(* Application de la règle 5 code (1 ou 2 dans la thèse) *)
(* marque de l'antécédent : -4 *)
assert(HABCApabbcDadbdcdm2 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hcomp : 2 <= 2) by (repeat constructor).
	assert(Hincl : incl (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (repeat clear_all_rk;my_inO).
	assert(HT := rule_5 (A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) 2 2 HAApmtmp Hcomp Hincl);apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 4 et 4) *)
(* marque des antécédents AUB AiB A: 4 -4 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A :: Ap ::  de rang :  2 et 2 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCApabbcDadbdcdm4 : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabbcDadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabbcDadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabbcDadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabbcDadbdcdeq HOoABCApabbcDadbdcdm4).
	assert(HAApmtmp : rk(A :: Ap :: nil) >= 2) by (solve_hyps_min HAApeq HAApm2).
	assert(Hincl : incl (A :: Ap :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabbcDadbdcdmtmp;try rewrite HT2 in HOoABCApabbcDadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd :: nil) (A :: Ap :: nil) 4 2 2 HOoABCApabbcDadbdcdmtmp HAApmtmp HOoAApMtmp Hincl); apply HT.
}

assert(HABCApabbcDadbdcdM : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(HABCApabbcDadbdcdm : rk(A :: B :: C :: Ap :: ab :: bc :: D :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min HABCApabbcDadbdcdeq HABCApabbcDadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Lemma Labacbcadbdcd : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 3.
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.

(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 1  *)
(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 3 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ABCabacbcadbdcd requis par la preuve de (?)ABCabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 -2 et -4*)
(* ensembles concernés AUB : Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : A ::  de rang :  1 et 1 	 A : Oo :: A :: Ap ::   de rang : 2 et 2 *)
assert(HABCabacbcadbdcdm3 : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HOoAApMtmp : rk(Oo :: A :: Ap :: nil) <= 2) by (solve_hyps_max HOoAApeq HOoAApM2).
	assert(HOoABCApabacbcadbdcdeq : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LOoABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HOoABCApabacbcadbdcdmtmp : rk(Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HOoABCApabacbcadbdcdeq HOoABCApabacbcadbdcdm4).
	assert(HAmtmp : rk(A :: nil) >= 1) by (solve_hyps_min HAeq HAm1).
	assert(Hincl : incl (A :: nil) (list_inter (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (Oo :: A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (Oo :: A :: Ap :: A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((Oo :: A :: Ap :: nil) ++ (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HOoABCApabacbcadbdcdmtmp;try rewrite HT2 in HOoABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (Oo :: A :: Ap :: nil) (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: nil) 4 1 2 HOoABCApabacbcadbdcdmtmp HAmtmp HOoAApMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 2 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour ACabacbcadbdcd requis par la preuve de (?)ACabacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 4 -1 et 4*)
(* ensembles concernés AUB : A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB :  de rang :  0 et 0 	 A : B :: Ap ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm2 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HBApeq : rk(B :: Ap :: nil) = 2) by (apply LBAp with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HBApMtmp : rk(B :: Ap :: nil) <= 2) by (solve_hyps_max HBApeq HBApM2).
	assert(HABCApabacbcadbdcdeq : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LABCApabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HABCApabacbcadbdcdmtmp : rk(A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HABCApabacbcadbdcdeq HABCApabacbcadbdcdm4).
	assert(Hmtmp : rk(nil) >= 0) by (solve_hyps_min Hnuleq Hm).
	assert(Hincl : incl (nil) (list_inter (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: Ap :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (B :: Ap :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((B :: Ap :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCApabacbcadbdcdmtmp;try rewrite HT2 in HABCApabacbcadbdcdmtmp.
	assert(HT := rule_4 (B :: Ap :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (nil) 4 0 2 HABCApabacbcadbdcdmtmp Hmtmp HBApMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 5 4 et -4*)
(* ensembles concernés AUB : A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : A :: ab ::  de rang :  2 et 2 	 A : A :: B :: ab ::   de rang : 2 et 2 *)
assert(HACabacbcadbdcdm3 : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HABabMtmp : rk(A :: B :: ab :: nil) <= 2) by (solve_hyps_max HABabeq HABabM2).
	assert(HABCabacbcadbdcdmtmp : rk(A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HABCabacbcadbdcdeq HABCabacbcadbdcdm3).
	assert(HAabeq : rk(A :: ab :: nil) = 2) by (apply LAab with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HAabmtmp : rk(A :: ab :: nil) >= 2) by (solve_hyps_min HAabeq HAabm2).
	assert(Hincl : incl (A :: ab :: nil) (list_inter (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: B :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: B :: ab :: A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: B :: ab :: nil) ++ (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HABCabacbcadbdcdmtmp;try rewrite HT2 in HABCabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: B :: ab :: nil) (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: ab :: nil) 3 2 2 HABCabacbcadbdcdmtmp HAabmtmp HABabMtmp Hincl); apply HT.
}

(* dans constructProofaux(), preuve de 1 <= rg <= 4 pour abacbcadbdcd requis par la preuve de (?)abacbcadbdcd pour la règle 4  *)
(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 2 et 4) *)
(* marque des antécédents AUB AiB A: 5 -2 et -4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  3 et 4 	 AiB : ac ::  de rang :  1 et 1 	 A : A :: C :: ac ::   de rang : 2 et 2 *)
assert(Habacbcadbdcdm2 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 2).
{
	assert(HACacMtmp : rk(A :: C :: ac :: nil) <= 2) by (solve_hyps_max HACaceq HACacM2).
	assert(HACabacbcadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3) by (solve_hyps_min HACabacbcadbdcdeq HACabacbcadbdcdm3).
	assert(Hacmtmp : rk(ac :: nil) >= 1) by (solve_hyps_min Haceq Hacm1).
	assert(Hincl : incl (ac :: nil) (list_inter (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: C :: ac :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadbdcdmtmp;try rewrite HT2 in HACabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ac :: nil) 3 1 2 HACabacbcadbdcdmtmp Hacmtmp HACacMtmp Hincl); apply HT.
}

(* Application de la règle 4 code (7 ou 8 dans la thèse) concerne B (rang 3 et 4) *)
(* marque des antécédents AUB AiB A: 4 4 et 4*)
(* ensembles concernés AUB : A :: C :: ab :: ac :: bc :: ad :: bd :: cd ::  de rang :  4 et 4 	 AiB : ac :: ad ::  de rang :  2 et 2 	 A : A :: C :: ac :: ad ::   de rang : 3 et 3 *)
assert(Habacbcadbdcdm3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 3).
{
	assert(HACacadeq : rk(A :: C :: ac :: ad :: nil) = 3) by (apply LACacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACacadMtmp : rk(A :: C :: ac :: ad :: nil) <= 3) by (solve_hyps_max HACacadeq HACacadM3).
	assert(HACabacbcadbdcdeq : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) = 4) by (apply LACabacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HACabacbcadbdcdmtmp : rk(A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) >= 4) by (solve_hyps_min HACabacbcadbdcdeq HACabacbcadbdcdm4).
	assert(Hacadeq : rk(ac :: ad :: nil) = 2) by (apply Lacad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Hacadmtmp : rk(ac :: ad :: nil) >= 2) by (solve_hyps_min Hacadeq Hacadm2).
	assert(Hincl : incl (ac :: ad :: nil) (list_inter (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (A :: C :: ab :: ac :: bc :: ad :: bd :: cd :: nil) (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: bd :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (A :: C :: ac :: ad :: ab :: ac :: bc :: ad :: bd :: cd :: nil) ((A :: C :: ac :: ad :: nil) ++ (ab :: ac :: bc :: ad :: bd :: cd :: nil))) by (clear_all_rk;my_inO).
	try rewrite HT1 in HACabacbcadbdcdmtmp;try rewrite HT2 in HACabacbcadbdcdmtmp.
	assert(HT := rule_4 (A :: C :: ac :: ad :: nil) (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ac :: ad :: nil) 4 2 3 HACabacbcadbdcdmtmp Hacadmtmp HACacadMtmp Hincl); apply HT.
}

(* Application de la règle 1 code (5 dans la thèse) conclusion AUB *)
(* marque des antécédents A B AiB : 4 4 et 4*)
assert(HabacbcadbdcdM3 : rk(ab :: ac :: bc :: ad :: bd :: cd :: nil) <= 3).
{
	assert(Habadbdeq : rk(ab :: ad :: bd :: nil) = 2) by (apply Labadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabadbdMtmp : rk(ab :: ad :: bd :: nil) <= 2) by (solve_hyps_max Habadbdeq HabadbdM2).
	assert(Habacbcadcdeq : rk(ab :: ac :: bc :: ad :: cd :: nil) = 3) by (apply Labacbcadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(HabacbcadcdMtmp : rk(ab :: ac :: bc :: ad :: cd :: nil) <= 3) by (solve_hyps_max Habacbcadcdeq HabacbcadcdM3).
	assert(Habadeq : rk(ab :: ad :: nil) = 2) by (apply Labad with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption).
	assert(Habadmtmp : rk(ab :: ad :: nil) >= 2) by (solve_hyps_min Habadeq Habadm2).
	assert(Hincl : incl (ab :: ad :: nil) (list_inter (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil))) by (repeat clear_all_rk;my_inO).
	assert(HT1 : equivlist (ab :: ac :: bc :: ad :: bd :: cd :: nil) (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil)) by (clear_all_rk;my_inO).
	assert(HT2 : equivlist (ab :: ad :: bd :: ab :: ac :: bc :: ad :: cd :: nil) ((ab :: ad :: bd :: nil) ++ (ab :: ac :: bc :: ad :: cd :: nil))) by (clear_all_rk;my_inO).
	assert(HT := rule_1 (ab :: ad :: bd :: nil) (ab :: ac :: bc :: ad :: cd :: nil) (ab :: ad :: nil) 2 3 2 HabadbdMtmp HabacbcadcdMtmp Habadmtmp Hincl);
	rewrite <-HT2 in HT;try rewrite <-HT1 in HT;apply HT.
}

assert(HabacbcadbdcdM : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) <= 4) by (apply rk_upper_dim).
assert(Habacbcadbdcdm : rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) >= 1) by (solve_hyps_min Habacbcadbdcdeq Habacbcadbdcdm1).
intuition.
Qed.

(* dans la couche 0 *)
Theorem def_Conclusion : forall Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd ,
rk(Oo :: A :: B :: C ::  nil) = 4 -> rk(A :: Ap ::  nil) = 2 -> rk(Oo :: A :: Ap ::  nil) = 2 ->
rk(A :: B :: Ap ::  nil) = 3 -> rk(A :: C :: Ap ::  nil) = 3 -> rk(B :: Bp ::  nil) = 2 ->
rk(Oo :: B :: Bp ::  nil) = 2 -> rk(A :: B :: Bp ::  nil) = 3 -> rk(B :: C :: Bp ::  nil) = 3 ->
rk(A :: Ap :: Bp ::  nil) = 3 -> rk(B :: Ap :: Bp ::  nil) = 3 -> rk(C :: Cp ::  nil) = 2 ->
rk(Oo :: C :: Cp ::  nil) = 2 -> rk(A :: C :: Cp ::  nil) = 3 -> rk(B :: C :: Cp ::  nil) = 3 ->
rk(A :: Ap :: Cp ::  nil) = 3 -> rk(C :: Ap :: Cp ::  nil) = 3 -> rk(B :: Bp :: Cp ::  nil) = 3 ->
rk(C :: Bp :: Cp ::  nil) = 3 -> rk(A :: B :: ab ::  nil) = 2 -> rk(Ap :: Bp :: ab ::  nil) = 2 ->
rk(A :: C :: ac ::  nil) = 2 -> rk(Ap :: Cp :: ac ::  nil) = 2 -> rk(B :: C :: bc ::  nil) = 2 ->
rk(Bp :: Cp :: bc ::  nil) = 2 -> rk(Oo :: A :: B :: D ::  nil) = 4 -> rk(Oo :: A :: C :: D ::  nil) = 4 ->
rk(Oo :: B :: C :: D ::  nil) = 3 -> rk(A :: B :: C :: D ::  nil) = 4 -> rk(A :: Ap :: D ::  nil) = 3 ->
rk(B :: Bp :: D ::  nil) = 3 -> rk(C :: Cp :: D ::  nil) = 3 -> rk(A :: Ap :: Dp ::  nil) = 3 ->
rk(B :: Bp :: Dp ::  nil) = 3 -> rk(C :: Cp :: Dp ::  nil) = 3 -> rk(Ap :: Bp :: Cp :: Dp ::  nil) = 4 ->
rk(D :: Dp ::  nil) = 2 -> rk(Oo :: D :: Dp ::  nil) = 2 -> rk(A :: D :: Dp ::  nil) = 3 ->
rk(B :: D :: Dp ::  nil) = 3 -> rk(C :: D :: Dp ::  nil) = 3 -> rk(Ap :: D :: Dp ::  nil) = 3 ->
rk(Bp :: D :: Dp ::  nil) = 3 -> rk(Cp :: D :: Dp ::  nil) = 3 -> rk(A :: D :: ad ::  nil) = 2 ->
rk(Ap :: Dp :: ad ::  nil) = 2 -> rk(B :: D :: bd ::  nil) = 2 -> rk(Bp :: Dp :: bd ::  nil) = 2 ->
rk(C :: D :: cd ::  nil) = 2 -> rk(Cp :: Dp :: cd ::  nil) = 2 -> 
	 rk(ab :: ac :: bc :: ad :: bd :: cd ::  nil) = 3  /\ 
	 rk(bc :: bd :: cd ::  nil) = 2  /\ 
	 rk(ac :: ad :: cd ::  nil) = 2  /\ 
	 rk(ab :: ad :: bd ::  nil) = 2  /\ 
	 rk(ab :: ac :: bc ::  nil) = 2  .
Proof.

intros Oo A B C Ap Bp Cp ab ac bc D Dp ad bd cd 
HOoABCeq HAApeq HOoAApeq HABApeq HACApeq HBBpeq HOoBBpeq HABBpeq HBCBpeq HAApBpeq
HBApBpeq HCCpeq HOoCCpeq HACCpeq HBCCpeq HAApCpeq HCApCpeq HBBpCpeq HCBpCpeq HABabeq
HApBpabeq HACaceq HApCpaceq HBCbceq HBpCpbceq HOoABDeq HOoACDeq HOoBCDeq HABCDeq HAApDeq
HBBpDeq HCCpDeq HAApDpeq HBBpDpeq HCCpDpeq HApBpCpDpeq HDDpeq HOoDDpeq HADDpeq HBDDpeq
HCDDpeq HApDDpeq HBpDDpeq HCpDDpeq HADadeq HApDpadeq HBDbdeq HBpDpbdeq HCDcdeq HCpDpcdeq
.
repeat split.

	apply Labacbcadbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Lbcbdcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Lacadcd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Labadbd with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.

	apply Labacbc with (Oo := Oo) (A := A) (B := B) (C := C) (Ap := Ap) (Bp := Bp) (Cp := Cp) (ab := ab) (ac := ac) (bc := bc) (D := D) (Dp := Dp) (ad := ad) (bd := bd) (cd := cd) ; assumption.
Qed .
